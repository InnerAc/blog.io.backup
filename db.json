{"meta":{"version":1,"warehouse":"1.0.2"},"models":{"Asset":[{"_id":"source/favicon.png","path":"favicon.png","modified":1},{"_id":"source/favicon.ico","path":"favicon.ico","modified":1},{"_id":"themes/yilia/source/js/pc.js","path":"js/pc.js","modified":1},{"_id":"themes/yilia/source/js/mobile.js","path":"js/mobile.js","modified":1},{"_id":"themes/yilia/source/js/main.js","path":"js/main.js","modified":1},{"_id":"themes/yilia/source/js/jquery.lazyload.js","path":"js/jquery.lazyload.js","modified":1},{"_id":"themes/yilia/source/js/instagram.js","path":"js/instagram.js","modified":1},{"_id":"themes/yilia/source/img/zhihu.png","path":"img/zhihu.png","modified":1},{"_id":"themes/yilia/source/img/weibo.png","path":"img/weibo.png","modified":1},{"_id":"themes/yilia/source/img/twitter.png","path":"img/twitter.png","modified":1},{"_id":"themes/yilia/source/img/stackoverflow.png","path":"img/stackoverflow.png","modified":1},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","path":"img/scrollbar_arrow.png","modified":1},{"_id":"themes/yilia/source/img/rss.png","path":"img/rss.png","modified":1},{"_id":"themes/yilia/source/img/pinterest.png","path":"img/pinterest.png","modified":1},{"_id":"themes/yilia/source/img/pinboard.png","path":"img/pinboard.png","modified":1},{"_id":"themes/yilia/source/img/mail.png","path":"img/mail.png","modified":1},{"_id":"themes/yilia/source/img/linkedin.png","path":"img/linkedin.png","modified":1},{"_id":"themes/yilia/source/img/img-loading.png","path":"img/img-loading.png","modified":1},{"_id":"themes/yilia/source/img/img-err.png","path":"img/img-err.png","modified":1},{"_id":"themes/yilia/source/img/google.png","path":"img/google.png","modified":1},{"_id":"themes/yilia/source/img/github.png","path":"img/github.png","modified":1},{"_id":"themes/yilia/source/img/facebook.png","path":"img/facebook.png","modified":1},{"_id":"themes/yilia/source/img/douban.png","path":"img/douban.png","modified":1},{"_id":"themes/yilia/source/img/delicious.png","path":"img/delicious.png","modified":1},{"_id":"themes/yilia/source/img/coderwall.png","path":"img/coderwall.png","modified":1},{"_id":"themes/yilia/source/favicon.png","path":"favicon.png","modified":1},{"_id":"themes/yilia/source/favicon.ico","path":"favicon.ico","modified":1},{"_id":"themes/yilia/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":1},{"_id":"themes/yilia/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":1},{"_id":"themes/yilia/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":1},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":1},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":1},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":1},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":1},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":1},{"_id":"themes/yilia/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":1},{"_id":"themes/yilia/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":1},{"_id":"themes/yilia/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":1},{"_id":"themes/yilia/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":1},{"_id":"themes/yilia/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":1},{"_id":"themes/yilia/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":1},{"_id":"themes/yilia/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":1},{"_id":"themes/yilia/source/css/style.styl","path":"css/style.styl","modified":1},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":1},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":1},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.svgz","path":"css/fonts/fontawesome-webfont.svgz","modified":1},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":1},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":1},{"_id":"themes/yilia/source/ava.png","path":"ava.png","modified":1}],"Cache":[{"_id":"source/_posts/1.md","shasum":"6ef6f8b57eff176229e73cda0690557205cbf1d8","modified":1440422435000},{"_id":"source/_posts/10.md","shasum":"759dd2a661d30c72258280b705bb39de12205100","modified":1440462561000},{"_id":"source/_posts/11.md","shasum":"09164aec3e2ba3d15b994c148615fb426736c186","modified":1440462657000},{"_id":"source/_posts/12.md","shasum":"7f1adfd4cc4e3d7d15644972a913248f0b4251ef","modified":1440462823000},{"_id":"source/_posts/13.md","shasum":"575f440384e6928feabe0ac266295e8774dfc6a2","modified":1440462867000},{"_id":"source/_posts/14.md","shasum":"c9d5279de75e70c44ed563d44151ec664a521147","modified":1440462911000},{"_id":"source/_posts/15.md","shasum":"d2f4697465c6bd2c3be27482d91a893411900cae","modified":1440463046000},{"_id":"source/_posts/16.md","shasum":"aa2db55368bcb6dda180492da70f268d7cd3f4bf","modified":1440463078000},{"_id":"source/_posts/17.md","shasum":"b0fe6f90baba8029eed4b414fc9e72cafee8e135","modified":1440463219000},{"_id":"source/_posts/18.md","shasum":"491778c3384bf17f3e642d989a5a85c646b273ce","modified":1440464799000},{"_id":"source/_posts/19.md","shasum":"19981951815594f3c334869c46c56a54eb5d3871","modified":1440463278000},{"_id":"source/_posts/2.md","shasum":"39b3c570095fa3599c166554b12a161488f78c1d","modified":1440422428000},{"_id":"source/_posts/20.md","shasum":"93eb9ab3b31009554164e67aa80512ef19cf8007","modified":1440463301000},{"_id":"source/_posts/21.md","shasum":"f2f50cc041bb45555764b6fefbe1ca31123b8aa2","modified":1440463321000},{"_id":"source/_posts/22.md","shasum":"0a35abaf12d3c1a7a4c2cb5efe12815b1b85d213","modified":1440463340000},{"_id":"source/_posts/23.md","shasum":"c6a80fd696ad51a04f40ba6fdaee02aaec7e51af","modified":1440463361000},{"_id":"source/_posts/24.md","shasum":"c474cf4b5cf3bd99b6349921e9e0c201e98e8836","modified":1440463404000},{"_id":"source/_posts/25.md","shasum":"baf6b370464322b78f149fb9b6b287451c397a76","modified":1440463456000},{"_id":"source/_posts/26.md","shasum":"f75f1a4e852de95faa040fe1cecb3f996d818725","modified":1440550902000},{"_id":"source/_posts/3.md","shasum":"9585aa543c4d777ea6dcc4209e3f15e2480c864d","modified":1440422441000},{"_id":"source/_posts/4.md","shasum":"e1ce386353a887e65ac605d24d1cffa418a9450b","modified":1440461492000},{"_id":"source/_posts/5.md","shasum":"aadf7fd96a6e9c7c38a121c9d0301922e6b0ebd0","modified":1440461616000},{"_id":"source/_posts/6.md","shasum":"5a0d70324858592a132b427201cbcb4b0c01f882","modified":1440461692000},{"_id":"source/_posts/7.md","shasum":"617d2a168db056edfd03031e20eae2a4209d561a","modified":1440461976000},{"_id":"source/_posts/8.md","shasum":"e2e391c5d385df3d58c36ccb02c0851613f45540","modified":1440462437000},{"_id":"source/_posts/9.md","shasum":"31b07a0843dab3866fce194d20724e6b742490cb","modified":1440462511000},{"_id":"source/favicon.ico","shasum":"7255c8f02a52fd8aa8d54f36fcb8e97314dc9e8b","modified":1426402513000},{"_id":"source/favicon.png","shasum":"9f2b514e6f43dbe8a5d698a4c07fe0e2740a9296","modified":1437901589000},{"_id":"themes/yilia/README.md","shasum":"8648a81b3ae08a4accd6b0541533e662511e6400","modified":1440410838000},{"_id":"themes/yilia/_config.yml","shasum":"fcc25c4f9abc636b528ac2791a9287aa4da0d2b0","modified":1440465703000},{"_id":"themes/yilia/_config.yml~","shasum":"17bd76d3553a3d36f9ae421ddc7cbf60c674627f","modified":1440422457000},{"_id":"themes/yilia/layout/_partial/after-footer.ejs","shasum":"082504c9fd8600306d4ca55f03e3cbb0ddd99dd7","modified":1440410838000},{"_id":"themes/yilia/layout/_partial/archive-post.ejs","shasum":"8dfb6d68aa8a0661d26c32ce1ce1f45815364c3a","modified":1440410838000},{"_id":"themes/yilia/layout/_partial/archive.ejs","shasum":"a6e94061ac55b9eb55275f87b608d62f6ea35659","modified":1440410838000},{"_id":"themes/yilia/layout/_partial/article.ejs","shasum":"ef8dd558f908f293c34123c0b7ff879d2fd0c09f","modified":1440410838000},{"_id":"themes/yilia/layout/_partial/footer.ejs","shasum":"f2994e0acd1d606ebf4680afc4fa652e148ccf4e","modified":1440410838000},{"_id":"themes/yilia/layout/_partial/google-analytics.ejs","shasum":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1440410838000},{"_id":"themes/yilia/layout/_partial/head.ejs","shasum":"963c106412a3ab142871976978ecc9884aeca17a","modified":1440410838000},{"_id":"themes/yilia/layout/_partial/header.ejs","shasum":"6387a93dad7c3d778eb91e3821852fbf6813880c","modified":1440410838000},{"_id":"themes/yilia/layout/_partial/left-col.ejs","shasum":"70a9951e4e2d30aabba88e75c3fa54b9235ce6a6","modified":1440410838000},{"_id":"themes/yilia/layout/_partial/mathjax.ejs","shasum":"54fab4d3d64cb937d6baec7324ffabf9f202b883","modified":1440410838000},{"_id":"themes/yilia/layout/_partial/mobile-nav.ejs","shasum":"cd0af87ee781ac9c2b0e6a2a05b063d4bd497d9c","modified":1440410838000},{"_id":"themes/yilia/layout/_partial/post/category.ejs","shasum":"d4f0e36f9a2167e91082dbd7d52425a06d2bebbf","modified":1440410838000},{"_id":"themes/yilia/layout/_partial/post/date.ejs","shasum":"c0c988334e857a77ba455a056dfa21809e7e76a5","modified":1440410838000},{"_id":"themes/yilia/layout/_partial/post/duoshuo.ejs","shasum":"e8399025ed3b980aedb821c92855889f5f12fd5b","modified":1440410838000},{"_id":"themes/yilia/layout/_partial/post/nav.ejs","shasum":"d19dee2082528e1844bed3aa4e4bd59f15fd7a7a","modified":1440410838000},{"_id":"themes/yilia/layout/_partial/post/share.ejs","shasum":"da39b4ba0c0ce4e1932fd45c5aee10e8aca41f28","modified":1440410838000},{"_id":"themes/yilia/layout/_partial/post/tag.ejs","shasum":"78612cfc091d7d861a70455a0dc8c3036e460879","modified":1440410838000},{"_id":"themes/yilia/layout/_partial/post/title.ejs","shasum":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1440410838000},{"_id":"themes/yilia/layout/archive.ejs","shasum":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1440410838000},{"_id":"themes/yilia/layout/category.ejs","shasum":"765426a9c8236828dc34759e604cc2c52292835a","modified":1440410838000},{"_id":"themes/yilia/layout/index.ejs","shasum":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1440410838000},{"_id":"themes/yilia/layout/layout.ejs","shasum":"4a5566f704f3246f5ef77badddf18d2e16750328","modified":1440410838000},{"_id":"themes/yilia/layout/page.ejs","shasum":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1440410838000},{"_id":"themes/yilia/layout/post.ejs","shasum":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1440410838000},{"_id":"themes/yilia/layout/tag.ejs","shasum":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1440410838000},{"_id":"themes/yilia/package.json","shasum":"00357ef6f24eb049074da81809e98f973f528cca","modified":1440410838000},{"_id":"themes/yilia/source/ava.png","shasum":"de9bf8f3bb0690a8c13426c8cdf71b5182b729cd","modified":1437901123000},{"_id":"themes/yilia/source/css/_extend.styl","shasum":"8ab1ad313bd6707d248c5ca1ee9a5eab8d815e42","modified":1440410838000},{"_id":"themes/yilia/source/css/_partial/archive.styl","shasum":"8b349f1605024dcdae054e04f02d71a2e84957c2","modified":1440410838000},{"_id":"themes/yilia/source/css/_partial/article.styl","shasum":"872fc4e63509fef885c939e5fd70e6ed439beced","modified":1440410838000},{"_id":"themes/yilia/source/css/_partial/footer.styl","shasum":"7ca837a4cc34db1c35f01baec85eb10ccc64ea86","modified":1440410838000},{"_id":"themes/yilia/source/css/_partial/header.styl","shasum":"67e59feb18eee6026717cb440d86ab9551782628","modified":1440410838000},{"_id":"themes/yilia/source/css/_partial/highlight.styl","shasum":"8cadf8437ce6f372802d3d28617a1ab97e7c818e","modified":1440410838000},{"_id":"themes/yilia/source/css/_partial/instagram.styl","shasum":"8a7b07bf5ea2d3588c0019f722c245bb1a8696af","modified":1440410838000},{"_id":"themes/yilia/source/css/_partial/main.styl","shasum":"4268f759920106a576c6037264076b36018ff73b","modified":1440410838000},{"_id":"themes/yilia/source/css/_partial/mobile-slider.styl","shasum":"e19c7fae6968ad3ea6cfc110900a991f9b5fce31","modified":1440410838000},{"_id":"themes/yilia/source/css/_partial/mobile.styl","shasum":"3a03b04ef8ac305aa5dbf7b9db99cd9377d07383","modified":1440410838000},{"_id":"themes/yilia/source/css/_partial/page.styl","shasum":"720b5b169bc28ccba3794efce9b7cd39f243dec7","modified":1440410838000},{"_id":"themes/yilia/source/css/_partial/scroll.styl","shasum":"5539a38f9acd603d453a0ea0d8ce10893cf83d22","modified":1440410838000},{"_id":"themes/yilia/source/css/_partial/share.styl","shasum":"22697b9a9877ab9f018364feb57aeea4a8313c9a","modified":1440410838000},{"_id":"themes/yilia/source/css/_partial/tagcloud.styl","shasum":"af0115de5c6455f899a2e09225b50224982c039d","modified":1440410838000},{"_id":"themes/yilia/source/css/_partial/wheelmenu.styl","shasum":"74630c56944e27bef53ef0c0e391611a2eec2ed0","modified":1440410838000},{"_id":"themes/yilia/source/css/_util/grid.styl","shasum":"1aa883ab432d9e4139c89dcbd40ae2bd1528d029","modified":1440410838000},{"_id":"themes/yilia/source/css/_util/mixin.styl","shasum":"429bad87fc156eacf226c5e35b0eafc277f2504b","modified":1440410838000},{"_id":"themes/yilia/source/css/_variables.styl","shasum":"8b63ea3c7199524b9a1541075c6f8fb2c0d0ea3d","modified":1440410838000},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.eot","shasum":"3ce87b82c7a4ffdf65e96765c2ffda10b1a283c6","modified":1440410838000},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.svgz","shasum":"4bfdd33ed702e32ae01399fcc2652377f78e7626","modified":1440410838000},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.ttf","shasum":"1480b8101b02da9bc4c60341b5e185e63e585064","modified":1440410838000},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.woff","shasum":"cafc4ac5761a0a252d33dce4ea3952cf9a38d832","modified":1440410838000},{"_id":"themes/yilia/source/css/style.styl","shasum":"456e8cfe3b0b0371e81848ea9b0bc7ffd5360921","modified":1440410838000},{"_id":"themes/yilia/source/fancybox/blank.gif","shasum":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1440410838000},{"_id":"themes/yilia/source/fancybox/fancybox_loading.gif","shasum":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1440410838000},{"_id":"themes/yilia/source/fancybox/fancybox_loading@2x.gif","shasum":"273b123496a42ba45c3416adb027cd99745058b0","modified":1440410838000},{"_id":"themes/yilia/source/fancybox/fancybox_overlay.png","shasum":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1440410838000},{"_id":"themes/yilia/source/fancybox/fancybox_sprite.png","shasum":"17df19f97628e77be09c352bf27425faea248251","modified":1440410838000},{"_id":"themes/yilia/source/fancybox/fancybox_sprite@2x.png","shasum":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1440410838000},{"_id":"themes/yilia/source/fancybox/helpers/fancybox_buttons.png","shasum":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1440410838000},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-buttons.css","shasum":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1440410838000},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-buttons.js","shasum":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1440410838000},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-media.js","shasum":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1440410838000},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-thumbs.css","shasum":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1440410838000},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-thumbs.js","shasum":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1440410838000},{"_id":"themes/yilia/source/fancybox/jquery.fancybox.css","shasum":"b6aa6692c2e5f8bd74d96827b78570f0c5683c20","modified":1440410838000},{"_id":"themes/yilia/source/fancybox/jquery.fancybox.js","shasum":"a82597493d75ea989ca586e09173cff332efe41e","modified":1440410838000},{"_id":"themes/yilia/source/fancybox/jquery.fancybox.pack.js","shasum":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1440410838000},{"_id":"themes/yilia/source/favicon.ico","shasum":"7255c8f02a52fd8aa8d54f36fcb8e97314dc9e8b","modified":1426402513000},{"_id":"themes/yilia/source/favicon.png","shasum":"9f2b514e6f43dbe8a5d698a4c07fe0e2740a9296","modified":1437901589000},{"_id":"themes/yilia/source/img/coderwall.png","shasum":"fa84676c4d654e040e51fd34bfcd9f9348cd5331","modified":1440410838000},{"_id":"themes/yilia/source/img/delicious.png","shasum":"9553a5f5189e4a953e04a58a49dbfa74b86b73dd","modified":1440410838000},{"_id":"themes/yilia/source/img/douban.png","shasum":"e2ade003ffadd5826ee66ec23901c2d6e8607e4e","modified":1440410838000},{"_id":"themes/yilia/source/img/facebook.png","shasum":"d19ad7a0903daf26817afd8753cd97e0cc714f54","modified":1440410838000},{"_id":"themes/yilia/source/img/github.png","shasum":"b84d03b32fa388dcbf149296ebd16dce6223d48d","modified":1440410838000},{"_id":"themes/yilia/source/img/google.png","shasum":"61a21fec7346fa3400b747ac9a201cf3d5bc013d","modified":1440410838000},{"_id":"themes/yilia/source/img/img-err.png","shasum":"23a63ea26eb3c1d5e677d9883cf36cc1a1a1228b","modified":1440410838000},{"_id":"themes/yilia/source/img/img-loading.png","shasum":"a9cd5cd11866824f31e3d1c5e23badfeb3f73031","modified":1440410838000},{"_id":"themes/yilia/source/img/linkedin.png","shasum":"e203138fb53c257cb214e97f4e30091b9c568d2c","modified":1440410838000},{"_id":"themes/yilia/source/img/mail.png","shasum":"fca8199cc77fdbd700a45bf56d091c82f4a67fe7","modified":1440410838000},{"_id":"themes/yilia/source/img/pinboard.png","shasum":"0891fbb6d092fa012bf936019923383d84c6aeb0","modified":1440410838000},{"_id":"themes/yilia/source/img/pinterest.png","shasum":"9c72917f8779c083157c6ce7a5d62ed4874f0630","modified":1440410838000},{"_id":"themes/yilia/source/img/rss.png","shasum":"430fd47340e75214c081abd05cd7410cf7c71b86","modified":1440410838000},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","shasum":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1440410838000},{"_id":"themes/yilia/source/img/stackoverflow.png","shasum":"da5dfe9043055c95e479d49c78cd3b020de608f2","modified":1440410838000},{"_id":"themes/yilia/source/img/twitter.png","shasum":"14dbb8e62d056525253bc0de13acd1723da7a934","modified":1440410838000},{"_id":"themes/yilia/source/img/weibo.png","shasum":"280dae3fd38086158b4a1b57edb94c06b1a5014b","modified":1440410838000},{"_id":"themes/yilia/source/img/zhihu.png","shasum":"a6d6ef65e9ac82e613a311810391ebb90d9b1c1d","modified":1440410838000},{"_id":"themes/yilia/source/js/instagram.js","shasum":"81e13cacf4947118ed1920e59b04ccf6beef6b86","modified":1440410838000},{"_id":"themes/yilia/source/js/jquery.lazyload.js","shasum":"c11a2e7b330d16d06feabd0a8477099adf9d6799","modified":1440410838000},{"_id":"themes/yilia/source/js/main.js","shasum":"e2633f282e377a4169649c9f17dc96036ad4fc64","modified":1440410838000},{"_id":"themes/yilia/source/js/mobile.js","shasum":"b68cc01d24e80973c48205f551da87f3f3427644","modified":1440410838000},{"_id":"themes/yilia/source/js/pc.js","shasum":"a5397d34a04084ee089b4b1e26457ab46ecea63e","modified":1440410838000},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.svg","shasum":"ba13657479b46daecb6336bfe376f84cef3ae58b","modified":1440410838000}],"Category":[{"name":"编程与算法","_id":"cids4qf2t0001oj5uirou0yn9"},{"name":"日常维护","_id":"cids4qf3v000eoj5ul5muqjtu"}],"Data":[],"Page":[],"Post":[{"title":"汇编输出十进制数","date":"2015-08-24T09:34:25.000Z","_content":"最近，老师让写一个汇编程序，结果除了helloworld 其他都不会输出，输出个数字 还变成乱码，查阅资料后，发现输出到是ASCII码对应到字符，无奈只能一个一个输出。\n贴代码之前先补充一下：\n\nBIOS 中断 INT 10H 显示字符 AH = 0EH 显示 AL 里面的数据简单来说就是\nMOV AH,0EH\nINT 10H\n屏幕就会输出 AL 里面ASCII 码 对应到字符 \n\n\n<!--more-->\n\n\n其他的注释都有了，也没什么好说到了，感谢 baidu \n```asm\nCOUTD:              ;将双字AX化为10 进制并显示  \n    PUSH BX         ;BX,CX,DX 入栈，保存现场  \n    PUSH CX  \n    PUSH DX  \n    MOV BX,10       ;转换成10进制，所以BX <= 10  \n    XOR CX,CX       ;清空 CX  \nC0: XOR DX,DX       ;清空 DX  \n    DIV BX          ;AX 除以 BX,DX <= 余数, AX <= 商  \n    OR DX,0E30H     ;DX|0E30H 结果 DH = 0EH DL =30H+余数    \n    PUSH DX         ;商的ASCII码入栈   \n    INC CX          ;CX 自加 用于 出栈时计数  \n    CMP AX,0        ;比较AX 与 0   \n    JNZ C0          ;若AX(商) 不为 0 则 高位还有数 跳转到C0 继续进行计算   \nC1: POP AX          ;出栈到AX 此时 AH = 0EH AL = 十进制数到ASCII码  \n    INT 10H         ;AH = 0EH 将AL 输出到屏幕  \n    LOOP C1         ;CX 不为0 则跳转到C1继续出栈 输出  \n    POP DX          ;BX,CX,DX 出栈，恢复现场  \n    POP CX  \n    POP BX  \n    RET  \n```\n","source":"_posts/1.md","raw":"title: 汇编输出十进制数\ndate: 2015-08-24 17:34:25\ncategories: 编程与算法\ntags: [asm,课后练习]\n---\n最近，老师让写一个汇编程序，结果除了helloworld 其他都不会输出，输出个数字 还变成乱码，查阅资料后，发现输出到是ASCII码对应到字符，无奈只能一个一个输出。\n贴代码之前先补充一下：\n\nBIOS 中断 INT 10H 显示字符 AH = 0EH 显示 AL 里面的数据简单来说就是\nMOV AH,0EH\nINT 10H\n屏幕就会输出 AL 里面ASCII 码 对应到字符 \n\n\n<!--more-->\n\n\n其他的注释都有了，也没什么好说到了，感谢 baidu \n```asm\nCOUTD:              ;将双字AX化为10 进制并显示  \n    PUSH BX         ;BX,CX,DX 入栈，保存现场  \n    PUSH CX  \n    PUSH DX  \n    MOV BX,10       ;转换成10进制，所以BX <= 10  \n    XOR CX,CX       ;清空 CX  \nC0: XOR DX,DX       ;清空 DX  \n    DIV BX          ;AX 除以 BX,DX <= 余数, AX <= 商  \n    OR DX,0E30H     ;DX|0E30H 结果 DH = 0EH DL =30H+余数    \n    PUSH DX         ;商的ASCII码入栈   \n    INC CX          ;CX 自加 用于 出栈时计数  \n    CMP AX,0        ;比较AX 与 0   \n    JNZ C0          ;若AX(商) 不为 0 则 高位还有数 跳转到C0 继续进行计算   \nC1: POP AX          ;出栈到AX 此时 AH = 0EH AL = 十进制数到ASCII码  \n    INT 10H         ;AH = 0EH 将AL 输出到屏幕  \n    LOOP C1         ;CX 不为0 则跳转到C1继续出栈 输出  \n    POP DX          ;BX,CX,DX 出栈，恢复现场  \n    POP CX  \n    POP BX  \n    RET  \n```\n","slug":"1","published":1,"updated":"2015-08-24T13:20:35.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cids4qf2p0000oj5uh8l0btmg"},{"title":"并查集 poj食物链","date":"2015-08-25T00:28:04.000Z","_content":"一般父类便为更节点更新节点时 kin = 0 \n\n\n<!--more-->\n\n\n```cpp\n#include <iostream>  \n#include <stdio.h>  \nusing namespace std;  \nint par[50000],kin[50000];  \nvoid init(int n){  \n        int i;  \n        for(i=0;i<n;i++){  \n                par[i] = i;  \n                kin[i] = 0;  \n        }  \n}  \nvoid uniun(int xroot,int yroot,int x,int y,int o){  \n        par[yroot] = xroot;  \n        kin[yroot] = (kin[x]-kin[y]-o+3)%3;  \n}  \nint find(int x){  \n    if(par[x] == x)return x;  \n    int xroot;  \n    xroot = find(par[x]);  \n    kin[x] = (kin[par[x]]+kin[x]+3)%3;  \n    par[x] = xroot;  \n    return xroot;  \n}  \nint main(){  \n        int n,k;  \n        int x,y,o;  \n        int count = 0;  \n        scanf(\"%d%d\",&n,&k);  \n        init(n);  \n        while(k--){  \n            scanf(\"%d%d%d\",&o,&x,&y);  \n            x--;  \n            y--;  \n            if(x>=n||y>=n){  \n                count++;  \n                continue;  \n            }  \n            int xroot = find(x);  \n            int yroot = find(y);  \n            if(xroot == yroot){  \n                    int u = (kin[x] - kin[y]+3)%3;  \n                    if(u==0 && o == 1){  \n                        continue;  \n                    }  \n                    if(u == 1 && o == 2){  \n                            continue;  \n                    }  \n                    count++;  \n            }else{  \n                    uniun(xroot,yroot,x,y,o-1);  \n            }  \n        }  \n        printf(\"%d\\n\",count);  \n        return 0;  \n}  \n```","source":"_posts/9.md","raw":"title: 并查集 poj食物链\ncategories: 编程与算法\ndate: 2015-08-25 08:28:04\ntags: [poj,uniun]\n---\n一般父类便为更节点更新节点时 kin = 0 \n\n\n<!--more-->\n\n\n```cpp\n#include <iostream>  \n#include <stdio.h>  \nusing namespace std;  \nint par[50000],kin[50000];  \nvoid init(int n){  \n        int i;  \n        for(i=0;i<n;i++){  \n                par[i] = i;  \n                kin[i] = 0;  \n        }  \n}  \nvoid uniun(int xroot,int yroot,int x,int y,int o){  \n        par[yroot] = xroot;  \n        kin[yroot] = (kin[x]-kin[y]-o+3)%3;  \n}  \nint find(int x){  \n    if(par[x] == x)return x;  \n    int xroot;  \n    xroot = find(par[x]);  \n    kin[x] = (kin[par[x]]+kin[x]+3)%3;  \n    par[x] = xroot;  \n    return xroot;  \n}  \nint main(){  \n        int n,k;  \n        int x,y,o;  \n        int count = 0;  \n        scanf(\"%d%d\",&n,&k);  \n        init(n);  \n        while(k--){  \n            scanf(\"%d%d%d\",&o,&x,&y);  \n            x--;  \n            y--;  \n            if(x>=n||y>=n){  \n                count++;  \n                continue;  \n            }  \n            int xroot = find(x);  \n            int yroot = find(y);  \n            if(xroot == yroot){  \n                    int u = (kin[x] - kin[y]+3)%3;  \n                    if(u==0 && o == 1){  \n                        continue;  \n                    }  \n                    if(u == 1 && o == 2){  \n                            continue;  \n                    }  \n                    count++;  \n            }else{  \n                    uniun(xroot,yroot,x,y,o-1);  \n            }  \n        }  \n        printf(\"%d\\n\",count);  \n        return 0;  \n}  \n```","slug":"9","published":1,"updated":"2015-08-25T00:28:31.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cids4qf3r0007oj5us3dyj23g"},{"title":"在ubuntu下配置VPN","date":"2015-08-25T00:26:53.000Z","_content":"好久不写博客了，大部分东西都写进了为知笔记，本来想更换typecho，最后还是用的wp。\n为什么要在ubuntu下用vpn，因为很多时候就在ubuntu下作业啊。\n\n\n<!--more-->\n\n\n废话不多说：首先来最简单的就是\nPPTP 点对点隧道协议：\n这个是ubuntu自带的vpn啦，单击新建一个vpn然后填入网关，用户名和密码。其实网关那里就是填的学长给的地址，本来以为这样就完成了，可是死活连不上。后来打开右下角有个高级设置：\n![vpn.png][1]\n\n然后勾掉PAP、CHAP、EAP 就可以成功连接了。\n再一个就是安装L2TP这个要自己通过包管理来安装了：\n```sh\nsudo apt-add-repository ppa:seriy-pr/network-manager-l2tp\nsudo apt-get install network-manager-l2tp-gnome\nsudo service xl2tpd start\n```\n然后就可以在vpn列表中找到了。\n\n  [1]: http://www.eternalac.com/usr/uploads/2015/07/1129759032.png","source":"_posts/8.md","raw":"title: 在ubuntu下配置VPN\ncategories: 日常维护\ndate: 2015-08-25 08:26:53\ntags: [ubuntu,vpn]\n---\n好久不写博客了，大部分东西都写进了为知笔记，本来想更换typecho，最后还是用的wp。\n为什么要在ubuntu下用vpn，因为很多时候就在ubuntu下作业啊。\n\n\n<!--more-->\n\n\n废话不多说：首先来最简单的就是\nPPTP 点对点隧道协议：\n这个是ubuntu自带的vpn啦，单击新建一个vpn然后填入网关，用户名和密码。其实网关那里就是填的学长给的地址，本来以为这样就完成了，可是死活连不上。后来打开右下角有个高级设置：\n![vpn.png][1]\n\n然后勾掉PAP、CHAP、EAP 就可以成功连接了。\n再一个就是安装L2TP这个要自己通过包管理来安装了：\n```sh\nsudo apt-add-repository ppa:seriy-pr/network-manager-l2tp\nsudo apt-get install network-manager-l2tp-gnome\nsudo service xl2tpd start\n```\n然后就可以在vpn列表中找到了。\n\n  [1]: http://www.eternalac.com/usr/uploads/2015/07/1129759032.png","slug":"8","published":1,"updated":"2015-08-25T00:27:17.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cids4qf3u000doj5u787jvddr"},{"title":"Cash Machine poj1276","date":"2015-08-25T00:18:00.000Z","_content":"这是以前在csdn写的博客，因为图太多就仅贴代码吧。如果想看图请移步：http://blog.csdn.net/anjicun/article/details/37772091\n\n\n----------\n动态规划的题 第一次超时 修改后A过\n//做好了图片 可以进行解释此题代码了\n状态方程应该都没问题 fin[i] = max{fin[i],fin[i-w]+w}(w 为价值，fin[i] 表示 当价值为i 时 所能承载的最大价值 )\n//下面这段代码是重点\n```cpp\nwhile (k <= num){  \n        for (int i = cash; i>= k*wei; i--){  \n            fin[i] = max(fin[i],fin[i - k*wei] + k*wei);  \n        }  \n        num -= k;  \n        k <<= 1;  \n    }  \n    for (int i = cash; i>=num * wei; i--){  \n        fin[i] = max(fin[i],fin[i-num * wei] + num * wei);  \n    }  \n```\n\n\n<!--more-->\n\n\n\n下面 用 num = 6 cash = 10w 的例子来解释一下 请看动态图：\n![20140715102713728.gif][1]\n\n第一次循环(灰色) k = 1 < num = 6        fin[10w]~fin[1w] = w\n第二次循环(桔色) k = 2 < num = 5        fin[10w]~fin[3w] = 3w     fin[3w]~fin[2w] = 2w\n第三次无法循环 k = 4 > num = 3 所以到下一段代码进行补充\n\n    for (int i = cash; i>=num * wei; i--)\n\n状态方程 `fin[i] = max{fin[i], fin[i-num*w]+num*w]} (num = 3,3w <= i <= 10w)`\n(黄色)`fin[10w]~fin[6w] = 6w     fin[6w]~fin[5w] = 5w ......`\n其实将 k <<= 1 换成 k++ 同样可以AC 道理是一样的 也同样可以证明\n\n\n```cpp\n#include <iostream>  \n#include <string.h>  \n#include <stdio.h>  \nusing namespace std;  \nint cash;  \nint Num;  \nint fin[100001];  \nint n[1001],w[1001];  \nint max(int x,int y){  \n        if(x>y)return x;  \n        else return y;  \n}  \nvoid inpack(int num,int wei){  \n        if(num*wei >= cash){  \n                for(int i=wei;i<=cash;i++){  \n                        //fin[i] = max(fin[i],fin[i-wei]+wei);  \n                        fin[i] = (fin[i]>(fin[i-wei]+wei))?fin[i]:(fin[i-wei]+wei);  \n                }  \n                return;  \n        }  \n    int k = 1;  \n    while (k <= num){  \n        for (int i = cash; i>= k*wei; i--){  \n            fin[i] = max(fin[i],fin[i - k*wei] + k*wei);  \n        }  \n        num -= k;  \n        k <<= 1;  \n    }  \n    for (int i = cash; i>=num * wei; i--){  \n        fin[i] = max(fin[i],fin[i-num * wei] + num * wei);  \n    }  \n}  \nint main(){  \n    int M,i;  \n    while(scanf(\"%d%d\",&cash,&M)!=EOF){  \n        memset(fin,0,sizeof(fin));  \n        for(i=1;i<=M;i++){  \n            scanf(\"%d%d\",&n[i],&w[i]);  \n        }  \n        for(i=1;i<=M;i++){  \n            inpack(n[i],w[i]);  \n        }  \n        printf(\"%d\\n\",fin[cash]);  \n    }  \n    return 0;     \n}  \n```\n  [1]: http://www.eternalac.com/usr/uploads/2015/07/3191629053.gif","source":"_posts/7.md","raw":"title: Cash Machine poj1276\ncategories: 编程与算法\ndate: 2015-08-25 08:18:00\ntags: [acm,poj]\n---\n这是以前在csdn写的博客，因为图太多就仅贴代码吧。如果想看图请移步：http://blog.csdn.net/anjicun/article/details/37772091\n\n\n----------\n动态规划的题 第一次超时 修改后A过\n//做好了图片 可以进行解释此题代码了\n状态方程应该都没问题 fin[i] = max{fin[i],fin[i-w]+w}(w 为价值，fin[i] 表示 当价值为i 时 所能承载的最大价值 )\n//下面这段代码是重点\n```cpp\nwhile (k <= num){  \n        for (int i = cash; i>= k*wei; i--){  \n            fin[i] = max(fin[i],fin[i - k*wei] + k*wei);  \n        }  \n        num -= k;  \n        k <<= 1;  \n    }  \n    for (int i = cash; i>=num * wei; i--){  \n        fin[i] = max(fin[i],fin[i-num * wei] + num * wei);  \n    }  \n```\n\n\n<!--more-->\n\n\n\n下面 用 num = 6 cash = 10w 的例子来解释一下 请看动态图：\n![20140715102713728.gif][1]\n\n第一次循环(灰色) k = 1 < num = 6        fin[10w]~fin[1w] = w\n第二次循环(桔色) k = 2 < num = 5        fin[10w]~fin[3w] = 3w     fin[3w]~fin[2w] = 2w\n第三次无法循环 k = 4 > num = 3 所以到下一段代码进行补充\n\n    for (int i = cash; i>=num * wei; i--)\n\n状态方程 `fin[i] = max{fin[i], fin[i-num*w]+num*w]} (num = 3,3w <= i <= 10w)`\n(黄色)`fin[10w]~fin[6w] = 6w     fin[6w]~fin[5w] = 5w ......`\n其实将 k <<= 1 换成 k++ 同样可以AC 道理是一样的 也同样可以证明\n\n\n```cpp\n#include <iostream>  \n#include <string.h>  \n#include <stdio.h>  \nusing namespace std;  \nint cash;  \nint Num;  \nint fin[100001];  \nint n[1001],w[1001];  \nint max(int x,int y){  \n        if(x>y)return x;  \n        else return y;  \n}  \nvoid inpack(int num,int wei){  \n        if(num*wei >= cash){  \n                for(int i=wei;i<=cash;i++){  \n                        //fin[i] = max(fin[i],fin[i-wei]+wei);  \n                        fin[i] = (fin[i]>(fin[i-wei]+wei))?fin[i]:(fin[i-wei]+wei);  \n                }  \n                return;  \n        }  \n    int k = 1;  \n    while (k <= num){  \n        for (int i = cash; i>= k*wei; i--){  \n            fin[i] = max(fin[i],fin[i - k*wei] + k*wei);  \n        }  \n        num -= k;  \n        k <<= 1;  \n    }  \n    for (int i = cash; i>=num * wei; i--){  \n        fin[i] = max(fin[i],fin[i-num * wei] + num * wei);  \n    }  \n}  \nint main(){  \n    int M,i;  \n    while(scanf(\"%d%d\",&cash,&M)!=EOF){  \n        memset(fin,0,sizeof(fin));  \n        for(i=1;i<=M;i++){  \n            scanf(\"%d%d\",&n[i],&w[i]);  \n        }  \n        for(i=1;i<=M;i++){  \n            inpack(n[i],w[i]);  \n        }  \n        printf(\"%d\\n\",fin[cash]);  \n    }  \n    return 0;     \n}  \n```\n  [1]: http://www.eternalac.com/usr/uploads/2015/07/3191629053.gif","slug":"7","published":1,"updated":"2015-08-25T00:19:36.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cids4qf3w000koj5uv7ajnnmx"},{"title":"Ubuntu 重裝後必做操作(二)安裝必備軟件","date":"2015-08-25T00:13:54.000Z","_content":"<!--more-->\n\n\n安裝爲知筆記\n```sh\nsudo add-apt-repository ppa:wiznote-team\nsudo apt-get update\nsudo apt-get install wiznote\n```\n安裝java\n```sh\nsudo add-apt-repository ppa:webupd8team/java\nsudo apt-get update\nsudo apt-get install oracle-java8-installer\n```\n安装zsh\n```sh\nsudo apt-get install zsh\ngit clone https://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh\ncp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc\nchsh -s /bin/zsh\n```\n爲Firefox安裝flash\n在Adobe官网下载flash\n\n    sudo cp libflashplayer.so /usr/lib/mozilla/plugins/","source":"_posts/6.md","raw":"title: Ubuntu 重裝後必做操作(二)安裝必備軟件\ndate: 2015-08-25 08:13:54\ncategories: 日常维护\ntags: [ubuntu,software]\n---\n<!--more-->\n\n\n安裝爲知筆記\n```sh\nsudo add-apt-repository ppa:wiznote-team\nsudo apt-get update\nsudo apt-get install wiznote\n```\n安裝java\n```sh\nsudo add-apt-repository ppa:webupd8team/java\nsudo apt-get update\nsudo apt-get install oracle-java8-installer\n```\n安装zsh\n```sh\nsudo apt-get install zsh\ngit clone https://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh\ncp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc\nchsh -s /bin/zsh\n```\n爲Firefox安裝flash\n在Adobe官网下载flash\n\n    sudo cp libflashplayer.so /usr/lib/mozilla/plugins/","slug":"6","published":1,"updated":"2015-08-25T00:14:52.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cids4qf40000poj5uppsz5wz4"},{"title":"Ubuntu 重裝後必做操作(一)科學上網","date":"2015-08-25T00:11:58.000Z","_content":"由於今天爲了體驗ubuntu15.04 的Nvidia驅動導致在登錄界面無線循環，無奈重裝了系統，現在重新將步驟記錄一下，以待不時之需：\n\n\n<!--more-->\n\n\n1、首先是科學上網安裝shadowsocks\n\n    sudo apt-get install python-gevent python-pip\n    sudo pip install shadowsocks\n創建json配置文件shadow.json\n\n    {\n        \"server\":\"xxx.xxx.xxx.xxx\",\n        \"server_port\":8080,\n        \"local_port\":1080,\n        \"password\":\"xxxxxx\",\n        \"timeout\":600,\n        \"method\":\"aes-256-cfb\"\n    }\n編寫腳本運行shadows.sh\n\n    #!/bin/sh \n    sslocal -c shadow.json\n讓其後臺運行\n\n    nohup ./shadows.sh > log &","source":"_posts/5.md","raw":"title: Ubuntu 重裝後必做操作(一)科學上網\ndate: 2015-08-25 08:11:58\ncategories: 日常维护\ntags: [ubuntu,shadowsocks,ss]\n---\n由於今天爲了體驗ubuntu15.04 的Nvidia驅動導致在登錄界面無線循環，無奈重裝了系統，現在重新將步驟記錄一下，以待不時之需：\n\n\n<!--more-->\n\n\n1、首先是科學上網安裝shadowsocks\n\n    sudo apt-get install python-gevent python-pip\n    sudo pip install shadowsocks\n創建json配置文件shadow.json\n\n    {\n        \"server\":\"xxx.xxx.xxx.xxx\",\n        \"server_port\":8080,\n        \"local_port\":1080,\n        \"password\":\"xxxxxx\",\n        \"timeout\":600,\n        \"method\":\"aes-256-cfb\"\n    }\n編寫腳本運行shadows.sh\n\n    #!/bin/sh \n    sslocal -c shadow.json\n讓其後臺運行\n\n    nohup ./shadows.sh > log &","slug":"5","published":1,"updated":"2015-08-25T00:13:36.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cids4qf42000uoj5uvntzdgdl"},{"title":"Androidx86 ubuntu 引导","date":"2015-08-25T00:10:48.000Z","_content":"閒極無聊，把自己很老的一個上網本裝了個ubuntu與Android X86的雙系統，由於Android的引導式grub1,所以沒辦法引導ubuntu，所以使用Ubuntu的引導來啓動Android。\n\n\n<!--more-->\n\n\n首先修改啓動文件\n\n    sudo gedit /etc/grub.d/40_custom\n在文件下添加下面內容，注意sda3，與hd0,3這些要根據你自己的實際情況來修改\n\n    menuentry “Android-x86 4.4.2 r2″ {\n    set root=(hd0,3)\n    linux /android-4.4-r2/kernel quiet root=/dev/sda3 androidboot.hardware=android_x86 video=-16 SRC=/android-4.4-r2\n    initrd /android-4.4-r2/initrd.img\n    }\n然後更新引導\n\n    sudo grub-mkconfig\n    sudo update-grub\n\n添加完成後，總是無法進入到選擇頁面，後來發現，講快速啓動設爲0就可以了\n\n    sudo gedit /etc/grub.d/00_header\n\n    quick_boot=”0”\n    if [ “$quick_boot” = 1 ];\n    then\n    ([ “$quick_boot” = 1 ] || [ “x${1}” != “x0″ ]) ;\n    then\n\n修改後完美啓動","source":"_posts/4.md","raw":"title: Androidx86 ubuntu 引导\ndate: 2015-08-25 08:10:48\ncategories: 日常维护\ntags: [Android,ubuntu]\n---\n閒極無聊，把自己很老的一個上網本裝了個ubuntu與Android X86的雙系統，由於Android的引導式grub1,所以沒辦法引導ubuntu，所以使用Ubuntu的引導來啓動Android。\n\n\n<!--more-->\n\n\n首先修改啓動文件\n\n    sudo gedit /etc/grub.d/40_custom\n在文件下添加下面內容，注意sda3，與hd0,3這些要根據你自己的實際情況來修改\n\n    menuentry “Android-x86 4.4.2 r2″ {\n    set root=(hd0,3)\n    linux /android-4.4-r2/kernel quiet root=/dev/sda3 androidboot.hardware=android_x86 video=-16 SRC=/android-4.4-r2\n    initrd /android-4.4-r2/initrd.img\n    }\n然後更新引導\n\n    sudo grub-mkconfig\n    sudo update-grub\n\n添加完成後，總是無法進入到選擇頁面，後來發現，講快速啓動設爲0就可以了\n\n    sudo gedit /etc/grub.d/00_header\n\n    quick_boot=”0”\n    if [ “$quick_boot” = 1 ];\n    then\n    ([ “$quick_boot” = 1 ] || [ “x${1}” != “x0″ ]) ;\n    then\n\n修改後完美啓動","slug":"4","published":1,"updated":"2015-08-25T00:11:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cids4qf470011oj5u55fee596"},{"title":"初学python（一）语法","date":"2015-08-24T13:14:00.000Z","_content":"本来是想学ruby的，后来感觉到python的社区更完善一些，等对于这些脚本语言有了基础，再去学习其他。\n这次学的是python的语法。\n\n\n<!--more-->\n\n\n1、标识符：这个不用多说，和其他的语言差不多，以字母(包括下划线)开头。\n2、保留字，一般也不会触碰到的吧：\n\n    'False', 'None', 'True', 'and', 'as', 'assert', 'break', 'class', 'continue', 'def', 'del',             'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield'\n\n3、注释，单行用`#`，这个不用多说，多行用`'''`或`\"\"\"`，有点意思，不过还是可以理解的。\n4、缩进，用缩进表示代码块，还好有代码格式强迫症，要不一不留神是不是就不在同一个块中了。缩进的空格数一样的话，表示语句处于同一个代码块中。\n5、数据类型，整数、长整数、浮点数、复数。\n6、字符串，单引号和多引号完全相同、三个引号可以指定一个多行字符串、'\\'是转义字符、R或r是自然字符串、字符串是不可变的！看到这个简直毁三观，赶紧写个代码调试一下。\n\n    print (\"Hello World!\")\n    #我是单行注释\n    '''\n    我是多行注释\n    我是多行注释\n    我是多行注释\n    我是多行注释\n    '''\n    string1 = '我是单行字符串'\n    string2 = ''' 我是多行字符串\n    我是多行字符串\n    \t\t\t多行'''\n    string3 = '我是要转义的字符串\\n'\n    string4 = r'我是不想转义的字符串\\n'\n    print (string1)\n    print (string2)\n    print (string3)\n    print (string4)\n    string1 = '听说字符串是不可变的'\n    print (string1)\n输出结果：\n\n    Hello World!\n    我是单行字符串\n     我是多行字符串\n    我是多行字符串\n    \t\t\t多行\n    我是要转义的字符串\n    \n    我是不想转义的字符串\\n\n    听说字符串是不可变的\n这个不可变并不是指的不可修改，应该是修改之后生成了新的字符串。\n","source":"_posts/3.md","raw":"title: 初学python（一）语法\ndate: 2015-08-24 21:14:00\ncategories: 编程与算法\ntags: [python,编程]\n---\n本来是想学ruby的，后来感觉到python的社区更完善一些，等对于这些脚本语言有了基础，再去学习其他。\n这次学的是python的语法。\n\n\n<!--more-->\n\n\n1、标识符：这个不用多说，和其他的语言差不多，以字母(包括下划线)开头。\n2、保留字，一般也不会触碰到的吧：\n\n    'False', 'None', 'True', 'and', 'as', 'assert', 'break', 'class', 'continue', 'def', 'del',             'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield'\n\n3、注释，单行用`#`，这个不用多说，多行用`'''`或`\"\"\"`，有点意思，不过还是可以理解的。\n4、缩进，用缩进表示代码块，还好有代码格式强迫症，要不一不留神是不是就不在同一个块中了。缩进的空格数一样的话，表示语句处于同一个代码块中。\n5、数据类型，整数、长整数、浮点数、复数。\n6、字符串，单引号和多引号完全相同、三个引号可以指定一个多行字符串、'\\'是转义字符、R或r是自然字符串、字符串是不可变的！看到这个简直毁三观，赶紧写个代码调试一下。\n\n    print (\"Hello World!\")\n    #我是单行注释\n    '''\n    我是多行注释\n    我是多行注释\n    我是多行注释\n    我是多行注释\n    '''\n    string1 = '我是单行字符串'\n    string2 = ''' 我是多行字符串\n    我是多行字符串\n    \t\t\t多行'''\n    string3 = '我是要转义的字符串\\n'\n    string4 = r'我是不想转义的字符串\\n'\n    print (string1)\n    print (string2)\n    print (string3)\n    print (string4)\n    string1 = '听说字符串是不可变的'\n    print (string1)\n输出结果：\n\n    Hello World!\n    我是单行字符串\n     我是多行字符串\n    我是多行字符串\n    \t\t\t多行\n    我是要转义的字符串\n    \n    我是不想转义的字符串\\n\n    听说字符串是不可变的\n这个不可变并不是指的不可修改，应该是修改之后生成了新的字符串。\n","slug":"3","published":1,"updated":"2015-08-24T13:20:41.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cids4qf4a0016oj5uxang2yl6"},{"title":"ubuntu+hexo搭建github博客","date":"2015-08-25T23:44:08.000Z","_content":"本来博客是使用阿里云的虚拟主机通过`typecho`搭建的，不过后来担心域名和主机到期的续费问题（还是穷学生），所以决定专向`github`。\n\n经过多方面的比较，最终决定使用hexo来生成静态页面。现在主要介绍一下在ubuntu先如何进行配置和部署。\n\n<!--more-->\n## 安装nodejs\n首先安装`nodejs`。有两个方法可以进行安装。\n### apt-get安装\n一个是通过ubuntu自带的包管理进行安装。不过它自带的版本可能过低，所以需要添加源：\n```shell\nsudo add-apt-repository ppa:chris-lea/node.js\nsudo apt-get update\nsudo apt-get install nodejs\n```\n同时安装所需要的依赖即可。\n\n### nvm安装\n据说这个是官方推荐的安装方法。首先你要有shell下的下载工具`curl`或者`wget`。\n然后安装`nvm`,下面两天命令二选一即可。\n```shell\ncurl https://raw.github.com/creationix/nvm/master/install.sh | sh  \nwget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh\n```\n\n等待`nvm`安装之后，然后安装`nodejs`，可以通过`nvm ls`查看版本。\n```shell\nnvm install 0.10\n```\n\n## 安装hexo\n安装完`nodejs`后就要安装`hexo`了。首先全局安装：\n```shell\nnpm install -g hexo\n```\n安装完后就可以进行部署写作了。\n首先创建一个hexo博客\n```shell\nhexo init blog_name\n```\n如果这里报错`node command not found`，那就创建一个`nodejs`到`node`的软链接：\n```shell\nsudo ln -s /usr/bin/nodejs /usr/bin/node\n```\n创建好博客后，就可以生成博客：\n```shell\nhexo g\n```\n然后启动服务(`debug`可以不用加)：\n```shell\nhexo s [--debug]\n```\n然后就可以在`4000`端口看到我们的页面了。\n关于如何创建一个新页面（`post`是页面类型，你自己创建的，可以不填）：\n```shell\nhexo new [post] page_name\n```\n然后你就可以在`source/_posts`目录下看到你的md文件，只要编写好这个md文件再次运行`hexo g`便可生成静态页面。\n\n## 上传到github\n在github首先创建一个仓库，`username.github.io`，请严格使用这样的命名。然后复制仓库地址，打开博客的根目录下的`_config.yml`文件，在`deploy`那里进行填写\n```yml\ndeploy:\n  type: git\n  repo: git@github.com:username/username.github.io.git\n  branch: master\n```\n然后运行：\n```shell\nhexo d\n```\n输入github账号和密码(只有第一次需要)。然后就完成了部署。","source":"_posts/26.md","raw":"title: ubuntu+hexo搭建github博客\ndate: 2015-08-26 07:44:08\ncategories: 日常维护\ntags: [hexo,github,blog]\n---\n本来博客是使用阿里云的虚拟主机通过`typecho`搭建的，不过后来担心域名和主机到期的续费问题（还是穷学生），所以决定专向`github`。\n\n经过多方面的比较，最终决定使用hexo来生成静态页面。现在主要介绍一下在ubuntu先如何进行配置和部署。\n\n<!--more-->\n## 安装nodejs\n首先安装`nodejs`。有两个方法可以进行安装。\n### apt-get安装\n一个是通过ubuntu自带的包管理进行安装。不过它自带的版本可能过低，所以需要添加源：\n```shell\nsudo add-apt-repository ppa:chris-lea/node.js\nsudo apt-get update\nsudo apt-get install nodejs\n```\n同时安装所需要的依赖即可。\n\n### nvm安装\n据说这个是官方推荐的安装方法。首先你要有shell下的下载工具`curl`或者`wget`。\n然后安装`nvm`,下面两天命令二选一即可。\n```shell\ncurl https://raw.github.com/creationix/nvm/master/install.sh | sh  \nwget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh\n```\n\n等待`nvm`安装之后，然后安装`nodejs`，可以通过`nvm ls`查看版本。\n```shell\nnvm install 0.10\n```\n\n## 安装hexo\n安装完`nodejs`后就要安装`hexo`了。首先全局安装：\n```shell\nnpm install -g hexo\n```\n安装完后就可以进行部署写作了。\n首先创建一个hexo博客\n```shell\nhexo init blog_name\n```\n如果这里报错`node command not found`，那就创建一个`nodejs`到`node`的软链接：\n```shell\nsudo ln -s /usr/bin/nodejs /usr/bin/node\n```\n创建好博客后，就可以生成博客：\n```shell\nhexo g\n```\n然后启动服务(`debug`可以不用加)：\n```shell\nhexo s [--debug]\n```\n然后就可以在`4000`端口看到我们的页面了。\n关于如何创建一个新页面（`post`是页面类型，你自己创建的，可以不填）：\n```shell\nhexo new [post] page_name\n```\n然后你就可以在`source/_posts`目录下看到你的md文件，只要编写好这个md文件再次运行`hexo g`便可生成静态页面。\n\n## 上传到github\n在github首先创建一个仓库，`username.github.io`，请严格使用这样的命名。然后复制仓库地址，打开博客的根目录下的`_config.yml`文件，在`deploy`那里进行填写\n```yml\ndeploy:\n  type: git\n  repo: git@github.com:username/username.github.io.git\n  branch: master\n```\n然后运行：\n```shell\nhexo d\n```\n输入github账号和密码(只有第一次需要)。然后就完成了部署。","slug":"26","published":1,"updated":"2015-08-26T01:01:42.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cids4qf4c001coj5usjwuz3jc"},{"title":"一个用python写的科学上网小脚本（下）","date":"2015-08-25T00:43:53.000Z","_content":"现在来填坑，把整个脚本的流程写出来。在上一部分已经得到了ss的账号密码，服务器地址，端口号和加密方式，接下来就是把这些信息转换成json然后运行即可\n\n\n<!--more-->\n\n## 生成json文件 ##\n这个转换json对于python来说是很方便的，因为，python的字典这个结构就和json是类似的。可以直接通过`json.dumps(dic)`进行转换。\n首先我们要确定json文件中有哪些内容。\n```json\n{\n    \"server\":\"US1.SSSERVER.PW\",\n    \"server_port\":8989,\n    \"local_port\":1080,\n    \"password\":\"01916771\",\n    \"timeout\":600,\n    \"method\":\"aes-256-cfb\"\n}\n```\n这是它所有的信息。我们需要自己固定的是本地端口号和超时。其他的都通过python的字典创建进去。\n还是直接上代码清楚：\n```python\ndic = {}\ndic['server'] = eval(repr(ip)[1:])\ndic['server_port'] = string.atoi(eval(repr(port)[1:]))\ndic['local_port'] = 1080\ndic['password'] = eval(repr(pwd)[1:])\ndic['timeout'] = 600\ndic['method'] = eval(repr(met)[1:])\nshadow = json.dumps(dic)\n```\n然后将得到的json保存：\n```python\nf = open('xxx.json','w')\nf.write(shadow)\nf.close()\n```\n这样我们就得到了json文件。\n## 开启ss连接 ##\n得到json文件后，我们就可以手动在终端进行ss连接了，但是人懒嘛，生成后直接连接多好。\n所以就在python中执行终端命令咯。如下：\n```python\nos.system('sslocal -c xxx.json > log')\n```\n基本上到这里就结束了。算是边学边练吧。","source":"_posts/25.md","raw":"title: 一个用python写的科学上网小脚本（下）\ncategories: 编程与算法\ndate: 2015-08-25 08:43:53\ntags: [python,ss]\n---\n现在来填坑，把整个脚本的流程写出来。在上一部分已经得到了ss的账号密码，服务器地址，端口号和加密方式，接下来就是把这些信息转换成json然后运行即可\n\n\n<!--more-->\n\n## 生成json文件 ##\n这个转换json对于python来说是很方便的，因为，python的字典这个结构就和json是类似的。可以直接通过`json.dumps(dic)`进行转换。\n首先我们要确定json文件中有哪些内容。\n```json\n{\n    \"server\":\"US1.SSSERVER.PW\",\n    \"server_port\":8989,\n    \"local_port\":1080,\n    \"password\":\"01916771\",\n    \"timeout\":600,\n    \"method\":\"aes-256-cfb\"\n}\n```\n这是它所有的信息。我们需要自己固定的是本地端口号和超时。其他的都通过python的字典创建进去。\n还是直接上代码清楚：\n```python\ndic = {}\ndic['server'] = eval(repr(ip)[1:])\ndic['server_port'] = string.atoi(eval(repr(port)[1:]))\ndic['local_port'] = 1080\ndic['password'] = eval(repr(pwd)[1:])\ndic['timeout'] = 600\ndic['method'] = eval(repr(met)[1:])\nshadow = json.dumps(dic)\n```\n然后将得到的json保存：\n```python\nf = open('xxx.json','w')\nf.write(shadow)\nf.close()\n```\n这样我们就得到了json文件。\n## 开启ss连接 ##\n得到json文件后，我们就可以手动在终端进行ss连接了，但是人懒嘛，生成后直接连接多好。\n所以就在python中执行终端命令咯。如下：\n```python\nos.system('sslocal -c xxx.json > log')\n```\n基本上到这里就结束了。算是边学边练吧。","slug":"25","published":1,"updated":"2015-08-25T00:44:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cids4qf4h001koj5u0peg7smc"},{"title":"一个用python写的科学上网小脚本（上）","date":"2015-08-25T00:42:47.000Z","_content":"之前写过一篇科学上网的文章。关于什么是科学上网，大家都懂的。详情请见：[点我传送][1]\n但是科学上网要有ss账号啊，咱还是个穷学生，舍不得买vpn。好吧较便宜的ss账号也舍不得买。还要很多网站都提供免费的ss账号。这可是良心啊。当然啦，网站神马的就不推荐了，想用的话百度之。\n\n\n<!--more-->\n\n我们就来说说，如何不用打开网站就可完成一键获取ss账号并且完成ss连接。\n大神勿喷，这都是我自己想的，所以肯定有大神们看不上的地方，欢迎指出不足，谢谢。(毕竟刚刚接触python)\n简单来说一下实现的步骤：\n\n 1. 抓取网页\n 2. 解析网页\n 3. 得到服务器ip、端口、密码、加密方式等。\n 4. 生成json文件\n 5. 执行科学上网命令(见之前的文章 [点我传送][2])\n## 抓取网页 ##\n首先，我们应该抓取网页。这里我使用的是python的urllib2库。据说这个库很强大。\n通过这个库，使用get的方式请求了html。大部分都写了个这个函数\n```python\ndef getHtml(url):\n    page = urllib2.urlopen(url)\n    html = page.read()\n    return html\n```\n然而，当我去请求目标url的时候，并没有得到访问结果。我猜，估计是没有加浏览器头的原因吧。这真是猜的，因为好多网站防爬虫什么的会进行个判断。那我只能改进一下这个函数了，把user-agent加进去。如下：\n```python\ndef getHtml(url):\n    req = urllib2.Request(url)\n    req.add_header('User-Agent','Mozilla/5.0 (Windows NT 6.2; rv:16.0) Gecko/20100101 Firefox/16.0')\n    page = urllib2.urlopen(req)\n    html = page.read()\n    return html\n```\n再次运行脚本，成功得到html。\n这是要用到的部分：\n![aaddress.png][3]\n## 解析网页 ##\n本来想直接用正则去匹配就结束了，可是谁知道为毛成功不了。所以就用了一个看起来很吊的一个库`BeautifulSoup`，使用这个库时要先安装。\nubuntu用户直接执行`sudo apt-get install Python-bs4`即可。其他发行版的话，自行百度吧。\n导入的话就是这个咯`from bs4 import BeautifulSoup`\n然后将得到的html转换为beautifulsoup格式。同时找到相应的div\n```python\nsoup = BeautifulSoup(html)\ndiv = soup.find('div',{'class':\"col-lg-4 text-center\"})\nhfs = div.findAll('h4')\n```\n`find`就是找到第一个，`findAll`就是找到所有的然后返回一个list\n这样我们就得到包含所有想要信息的list啦。\n`hfs[i].string`就可以得到想要的字符串了。\n不过它的字符串还包括前面的说明，所以要通过正则过滤掉。\n正则如下：\n`regexAll = r'\\:(.*)'`就是把`:`后面的字符留下啦。\n比如：\n`port = re.search(regexAll,hfs[1].string).group(1)`\n就可以得到它的端口u'8989'\n因为是一个unicode所以会在前面加`u`，这个转换是我百度的，如下：\n`string.atoi(eval(repr(port)[1:]))`\n前面是用来转换为数字的，括号内是把`u`去掉的。\n现在我们已经得到所有该得到的信息了。\n后面两个先留着吧，困死了，睡午觉去。\n\n  [1]: http://www.eternalac.com/index.php/archives/7/\n  [2]: http://www.eternalac.com/index.php/archives/7/\n  [3]: http://www.eternalac.com/usr/uploads/2015/08/879485559.png","source":"_posts/24.md","raw":"title: 一个用python写的科学上网小脚本（上）\ncategories: 编程与算法\ntags: [python,ss]\ndate: 2015-08-25 08:42:47\n---\n之前写过一篇科学上网的文章。关于什么是科学上网，大家都懂的。详情请见：[点我传送][1]\n但是科学上网要有ss账号啊，咱还是个穷学生，舍不得买vpn。好吧较便宜的ss账号也舍不得买。还要很多网站都提供免费的ss账号。这可是良心啊。当然啦，网站神马的就不推荐了，想用的话百度之。\n\n\n<!--more-->\n\n我们就来说说，如何不用打开网站就可完成一键获取ss账号并且完成ss连接。\n大神勿喷，这都是我自己想的，所以肯定有大神们看不上的地方，欢迎指出不足，谢谢。(毕竟刚刚接触python)\n简单来说一下实现的步骤：\n\n 1. 抓取网页\n 2. 解析网页\n 3. 得到服务器ip、端口、密码、加密方式等。\n 4. 生成json文件\n 5. 执行科学上网命令(见之前的文章 [点我传送][2])\n## 抓取网页 ##\n首先，我们应该抓取网页。这里我使用的是python的urllib2库。据说这个库很强大。\n通过这个库，使用get的方式请求了html。大部分都写了个这个函数\n```python\ndef getHtml(url):\n    page = urllib2.urlopen(url)\n    html = page.read()\n    return html\n```\n然而，当我去请求目标url的时候，并没有得到访问结果。我猜，估计是没有加浏览器头的原因吧。这真是猜的，因为好多网站防爬虫什么的会进行个判断。那我只能改进一下这个函数了，把user-agent加进去。如下：\n```python\ndef getHtml(url):\n    req = urllib2.Request(url)\n    req.add_header('User-Agent','Mozilla/5.0 (Windows NT 6.2; rv:16.0) Gecko/20100101 Firefox/16.0')\n    page = urllib2.urlopen(req)\n    html = page.read()\n    return html\n```\n再次运行脚本，成功得到html。\n这是要用到的部分：\n![aaddress.png][3]\n## 解析网页 ##\n本来想直接用正则去匹配就结束了，可是谁知道为毛成功不了。所以就用了一个看起来很吊的一个库`BeautifulSoup`，使用这个库时要先安装。\nubuntu用户直接执行`sudo apt-get install Python-bs4`即可。其他发行版的话，自行百度吧。\n导入的话就是这个咯`from bs4 import BeautifulSoup`\n然后将得到的html转换为beautifulsoup格式。同时找到相应的div\n```python\nsoup = BeautifulSoup(html)\ndiv = soup.find('div',{'class':\"col-lg-4 text-center\"})\nhfs = div.findAll('h4')\n```\n`find`就是找到第一个，`findAll`就是找到所有的然后返回一个list\n这样我们就得到包含所有想要信息的list啦。\n`hfs[i].string`就可以得到想要的字符串了。\n不过它的字符串还包括前面的说明，所以要通过正则过滤掉。\n正则如下：\n`regexAll = r'\\:(.*)'`就是把`:`后面的字符留下啦。\n比如：\n`port = re.search(regexAll,hfs[1].string).group(1)`\n就可以得到它的端口u'8989'\n因为是一个unicode所以会在前面加`u`，这个转换是我百度的，如下：\n`string.atoi(eval(repr(port)[1:]))`\n前面是用来转换为数字的，括号内是把`u`去掉的。\n现在我们已经得到所有该得到的信息了。\n后面两个先留着吧，困死了，睡午觉去。\n\n  [1]: http://www.eternalac.com/index.php/archives/7/\n  [2]: http://www.eternalac.com/index.php/archives/7/\n  [3]: http://www.eternalac.com/usr/uploads/2015/08/879485559.png","slug":"24","published":1,"updated":"2015-08-25T00:43:24.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cids4qf4l001ooj5urbfohrlc"},{"title":"初学python（十一）文件的读写","date":"2015-08-25T00:42:29.000Z","_content":"python的入门学习马上就进入尾声了，现在来学习文件的读写。\n\n\n<!--more-->\n\n## open() ##\n`f = open('dir\\fileName','r')`\n该函数是用来打开一个文件，其中 mode 可以是 'r' 如果文件只读, 'w' 只用于写 (如果存在同名文件则将被删除), 和 'a' 用于追加文件内容; 所写的任何数据都会被自动增加到末尾. 'r+' 同时用于读写。 mode 参数是可选的; 'r' 将是默认值。\n## 读 ##\nf.read() 表示从文件中读取n个字符。如果参数为负或者为空，则全部读取。\nf.readline() 表示从文件中读取一行，如果读取到为空的，则返回一个空字符串。\nf.readlines() 表示以list的形式返回该文件中包含的所有行。如果设置可选参数 sizehint, 则读取指定长度的字节, 并且将这些字节按行分割。\n以下是来源于网络的示例：\n```python\n>>> f.read()\n'This is the entire file.\\n'\n>>> f.read()\n''\n>>> f.readline()\n'This is the first line of the file.\\n'\n>>> f.readline()\n'Second line of the file\\n'\n>>> f.readline()\n''\n>>> f.readlines()\n['This is the first line of the file.\\n', 'Second line of the file\\n']\n```\n## 写 ##\n写的话就，简单了。\n```python\n>>> f.write('This is a test\\n')\n15\n```\n## 关 ##\n调用完成后记得关闭文件。\n```python\nf.close()\n```","source":"_posts/23.md","raw":"title: 初学python（十一）文件的读写\ncategories: 编程与算法\ntags:\n  - python\ndate: 2015-08-25 08:42:29\n---\npython的入门学习马上就进入尾声了，现在来学习文件的读写。\n\n\n<!--more-->\n\n## open() ##\n`f = open('dir\\fileName','r')`\n该函数是用来打开一个文件，其中 mode 可以是 'r' 如果文件只读, 'w' 只用于写 (如果存在同名文件则将被删除), 和 'a' 用于追加文件内容; 所写的任何数据都会被自动增加到末尾. 'r+' 同时用于读写。 mode 参数是可选的; 'r' 将是默认值。\n## 读 ##\nf.read() 表示从文件中读取n个字符。如果参数为负或者为空，则全部读取。\nf.readline() 表示从文件中读取一行，如果读取到为空的，则返回一个空字符串。\nf.readlines() 表示以list的形式返回该文件中包含的所有行。如果设置可选参数 sizehint, 则读取指定长度的字节, 并且将这些字节按行分割。\n以下是来源于网络的示例：\n```python\n>>> f.read()\n'This is the entire file.\\n'\n>>> f.read()\n''\n>>> f.readline()\n'This is the first line of the file.\\n'\n>>> f.readline()\n'Second line of the file\\n'\n>>> f.readline()\n''\n>>> f.readlines()\n['This is the first line of the file.\\n', 'Second line of the file\\n']\n```\n## 写 ##\n写的话就，简单了。\n```python\n>>> f.write('This is a test\\n')\n15\n```\n## 关 ##\n调用完成后记得关闭文件。\n```python\nf.close()\n```","slug":"23","published":1,"updated":"2015-08-25T00:42:41.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cids4qf5k001soj5um2ot6sn4"},{"title":"初学python（十）格式化输出","date":"2015-08-25T00:42:07.000Z","_content":"之前用python的时候只会用`print()`来输出。现在来学习一些其他的输出方式。\n本次主要学习这几个功能：\n\n - str() 函数返回一个用户易读的表达形式。\n - repr() 产生一个解释器易读的表达形式。\n - ljust()、rjust()、center() 左对齐、右对齐、居中。\n - zfill() 左边填充'0'\n - str.format() 格式化字段\n\n\n<!--more-->\n\n## str() ##\nstr() 是用来返回一个字符串的正常形式，就是显示在命令行或展示窗的字符串。其实就是用来将其他类型转换为字符串用的。例如：\n```python\n>>> s = 'Hello \\n World!'\n>>> s\n'Hello \\n World!'\n>>> str(s)\n'Hello \\n World!'\n>>> print(str(s))\nHello \n World!\n```\n## repr() ##\nrepr()函数是用来将字符串或其他类型转换为解释器可以识别的形式，例如将转义符再次进行转义。例如：\n```python\n>>> s = 'Hello \\n World!'\n>>> repr(s)\n\"'Hello \\\\n World!'\"\n>>> print(repr(s))\n'Hello \\n World!'\n```\n## ljust()、rjust()、center() ##\n```python\n>>> for i in range(1,4):\n...     print('|',repr(i).ljust(3),'|',repr(i*i).center(3),'|',repr(i**i).rjust(3),'|')\n... \n| 1   |  1  |   1 |\n| 2   |  4  |   4 |\n| 3   |  9  |  27 |\n```\n## zfill() ##\n这个函数是在左边填充'0'。\n```python\n>>> 'xx'.zfill(5)\n'000xx'\n```\n## format() ##\n就是用format()里的参数替换字符串中的通配符`{}`.例如：\n```python\n>>> 'this is {} test of {}!'.format('a','str.format()')\n'this is a test of str.format()!'\n```\n还可以在`{}`中写入关键字，这样就可以通过关机字赋值。例如：\n\n    >>> 'this is {a} test of {b}!'.format(b='str.format()',a='a')\n    'this is a test of str.format()!'\n还可以在`{}`加入`:参数`，用来格式化输入。例如：\n\n    >>> '{:.3f} * {:.3f} = {:3d}'.format(10,10,100)\n    '10.000 * 10.000 = 100'","source":"_posts/22.md","raw":"title: 初学python（十）格式化输出\ncategories: 编程与算法\ntags:\n  - python\ndate: 2015-08-25 08:42:07\n---\n之前用python的时候只会用`print()`来输出。现在来学习一些其他的输出方式。\n本次主要学习这几个功能：\n\n - str() 函数返回一个用户易读的表达形式。\n - repr() 产生一个解释器易读的表达形式。\n - ljust()、rjust()、center() 左对齐、右对齐、居中。\n - zfill() 左边填充'0'\n - str.format() 格式化字段\n\n\n<!--more-->\n\n## str() ##\nstr() 是用来返回一个字符串的正常形式，就是显示在命令行或展示窗的字符串。其实就是用来将其他类型转换为字符串用的。例如：\n```python\n>>> s = 'Hello \\n World!'\n>>> s\n'Hello \\n World!'\n>>> str(s)\n'Hello \\n World!'\n>>> print(str(s))\nHello \n World!\n```\n## repr() ##\nrepr()函数是用来将字符串或其他类型转换为解释器可以识别的形式，例如将转义符再次进行转义。例如：\n```python\n>>> s = 'Hello \\n World!'\n>>> repr(s)\n\"'Hello \\\\n World!'\"\n>>> print(repr(s))\n'Hello \\n World!'\n```\n## ljust()、rjust()、center() ##\n```python\n>>> for i in range(1,4):\n...     print('|',repr(i).ljust(3),'|',repr(i*i).center(3),'|',repr(i**i).rjust(3),'|')\n... \n| 1   |  1  |   1 |\n| 2   |  4  |   4 |\n| 3   |  9  |  27 |\n```\n## zfill() ##\n这个函数是在左边填充'0'。\n```python\n>>> 'xx'.zfill(5)\n'000xx'\n```\n## format() ##\n就是用format()里的参数替换字符串中的通配符`{}`.例如：\n```python\n>>> 'this is {} test of {}!'.format('a','str.format()')\n'this is a test of str.format()!'\n```\n还可以在`{}`中写入关键字，这样就可以通过关机字赋值。例如：\n\n    >>> 'this is {a} test of {b}!'.format(b='str.format()',a='a')\n    'this is a test of str.format()!'\n还可以在`{}`加入`:参数`，用来格式化输入。例如：\n\n    >>> '{:.3f} * {:.3f} = {:3d}'.format(10,10,100)\n    '10.000 * 10.000 = 100'","slug":"22","published":1,"updated":"2015-08-25T00:42:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cids4qf5n001voj5uytt73wrd"},{"title":"初学python（九）模块","date":"2015-08-25T00:41:48.000Z","_content":"python的模块就是在其他的python程序中调用写好的python文件。额，好乱的样子，就是使用已经封装好的python类和函数。我自己是这么理解的。\n这里先说怎样导入其他模块、怎样区别是自己调用还是其他程序调用、和创建一个包。\n关于导入父级包后同时导入其他子包，本人查阅了数多资料还是没找到解决方法。等以后知道了再来补充。\n\n\n<!--more-->\n\n## \\_\\_name__  的使用方法##\n每个*.py都有一个\\_\\_name__变量，如果调用该*.py的程序是它自己，那么\\_\\_name__的值为'\\_\\_main__'。这样就可以写一个函数如下:\n\n    #hello.py\n    #author innerac\n    def helloworld():\n    \tif __name__ == '__main__':\n    \t\tprint('Hello World!')\n    \telse:\n    \t\tprint('Hello the other World!!!')\n\n如果是本程序调用则会输出'`Hello World!`'，如果是其他程序调用的话就会输出'`Hello the other World!!!`'\n## 导入模块 ##\n这里仅仅学习简单的导入模块。首先我们有如下结构的包(包是已经建好的)\n\n    com/\n    \t__init__.py\n    \tinnerac/\n    \t\t__init__.py\n    \t\thello.py\n我们在程序中通过import导入\n```python\nimport com.innerac.hello\n#调用函数的方法\ncom.innerac.hello.helloworld()\n```\n也可以通过`from xxx import xxx`\n```python\nfrom com.innerac import hello\n#调用\nhello.helloworld()\n```\n也可以直接导入函数\n```python\nfrom com.innerac.hello import helloworld\n#调用\nhelloworld()\n```\n以上3个*.py都是和com是同目录的。他们的输出均为'`Hello the other World!!!`'\n## 创建一个包 ##\n如何创建一个包，首先应该在被当做包的目录下新建一个空的'`__init__.py`'文件。该文件声明了这是一个包结构。如上图我们的结构。\n起始只要有了空的文件我们就可以完成了我们所需要的功能。可是咱有强迫症，想导入父目录就同时把子目录也导入了。这个查阅了许多资料均没有找到想要的结果，后来只能自己写了个`import`这个方法仅供参考，欢迎指正。\n我想要的功能就是在与`com`同级的python文件下只写一句\"`import com`\"就可以直接使用\"`hello.py`\"下的函数。为此，我在\"`com/__init__.py`\"下加入语句:\n\n    #com/\n    #author innerac\n    import com.innerac\n    __all__ = []\n在\"`com/innerac/__init__.py`\"下加入语句：\n\n    #com/\n    #author innerac\n    import com.innerac.hello\n    __all__ = [\"hello\"]\n然后就可以直接调用了：\n\n    #start.py\n    #author innerac\n    import com\n    #直接调用\n    com.innerac.hello.helloworld()\n输出结果\"`Hello the other World!!!`\"\n\n还有一种导入方式就是'`*`'，如上图的包结构，只要我在\"`__init__.py`\"中创建一个\"`__all__`\"的list，然后将需要导入的模块都放进去。如\"`com/innerac/__init__.py`\"里的代码。只要在程序中书写：\n\n    #start.py\n    #author innerac\n    from com.innerac import *\n    #全部导入\n    hello.helloworld()\n就可以得到想要的结果了。\n如果\"`__all__`\"不写或者为空的话，将不会导入任何模块。","source":"_posts/21.md","raw":"title: 初学python（九）模块\ncategories: 编程与算法\ntags:\n  - python\ndate: 2015-08-25 08:41:48\n---\npython的模块就是在其他的python程序中调用写好的python文件。额，好乱的样子，就是使用已经封装好的python类和函数。我自己是这么理解的。\n这里先说怎样导入其他模块、怎样区别是自己调用还是其他程序调用、和创建一个包。\n关于导入父级包后同时导入其他子包，本人查阅了数多资料还是没找到解决方法。等以后知道了再来补充。\n\n\n<!--more-->\n\n## \\_\\_name__  的使用方法##\n每个*.py都有一个\\_\\_name__变量，如果调用该*.py的程序是它自己，那么\\_\\_name__的值为'\\_\\_main__'。这样就可以写一个函数如下:\n\n    #hello.py\n    #author innerac\n    def helloworld():\n    \tif __name__ == '__main__':\n    \t\tprint('Hello World!')\n    \telse:\n    \t\tprint('Hello the other World!!!')\n\n如果是本程序调用则会输出'`Hello World!`'，如果是其他程序调用的话就会输出'`Hello the other World!!!`'\n## 导入模块 ##\n这里仅仅学习简单的导入模块。首先我们有如下结构的包(包是已经建好的)\n\n    com/\n    \t__init__.py\n    \tinnerac/\n    \t\t__init__.py\n    \t\thello.py\n我们在程序中通过import导入\n```python\nimport com.innerac.hello\n#调用函数的方法\ncom.innerac.hello.helloworld()\n```\n也可以通过`from xxx import xxx`\n```python\nfrom com.innerac import hello\n#调用\nhello.helloworld()\n```\n也可以直接导入函数\n```python\nfrom com.innerac.hello import helloworld\n#调用\nhelloworld()\n```\n以上3个*.py都是和com是同目录的。他们的输出均为'`Hello the other World!!!`'\n## 创建一个包 ##\n如何创建一个包，首先应该在被当做包的目录下新建一个空的'`__init__.py`'文件。该文件声明了这是一个包结构。如上图我们的结构。\n起始只要有了空的文件我们就可以完成了我们所需要的功能。可是咱有强迫症，想导入父目录就同时把子目录也导入了。这个查阅了许多资料均没有找到想要的结果，后来只能自己写了个`import`这个方法仅供参考，欢迎指正。\n我想要的功能就是在与`com`同级的python文件下只写一句\"`import com`\"就可以直接使用\"`hello.py`\"下的函数。为此，我在\"`com/__init__.py`\"下加入语句:\n\n    #com/\n    #author innerac\n    import com.innerac\n    __all__ = []\n在\"`com/innerac/__init__.py`\"下加入语句：\n\n    #com/\n    #author innerac\n    import com.innerac.hello\n    __all__ = [\"hello\"]\n然后就可以直接调用了：\n\n    #start.py\n    #author innerac\n    import com\n    #直接调用\n    com.innerac.hello.helloworld()\n输出结果\"`Hello the other World!!!`\"\n\n还有一种导入方式就是'`*`'，如上图的包结构，只要我在\"`__init__.py`\"中创建一个\"`__all__`\"的list，然后将需要导入的模块都放进去。如\"`com/innerac/__init__.py`\"里的代码。只要在程序中书写：\n\n    #start.py\n    #author innerac\n    from com.innerac import *\n    #全部导入\n    hello.helloworld()\n就可以得到想要的结果了。\n如果\"`__all__`\"不写或者为空的话，将不会导入任何模块。","slug":"21","published":1,"updated":"2015-08-25T00:42:01.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cids4qf5q001yoj5u1yx9tcox"},{"title":"初学python（八）函数","date":"2015-08-25T00:41:26.000Z","_content":"python的函数第一眼把我震惊了。没有函数结尾标识，只能通过严格的缩进来保证函数的健壮。还有它的参数是可变的，还可以带参数名传递。\n\n\n<!--more-->\n\n## 普通函数：\n\n    #函数开始\n    def fun():\n        print('Hello World!')\n    #函数结束\n    #函数开始\n    def fun(str):\n        print(str)\n    #函数结束\n    #函数开始\n    def fun(str):\n        str += 'a'\n        return str\n    #函数结束\n## 关键字参数 ##\n\n    def fun(a,b='b',c='c',d='d'):\n        return a+b+c+d\n    fun('a')\n    fun('a',b='b1')\n## 可变参数 ##\n\n    def fun(*args):\n        sum = 0\n        for x in args:\n            sum += x\n        return sum\n要强调的是，写函数时不要忘了加`:`","source":"_posts/20.md","raw":"title: 初学python（八）函数\ncategories: 编程与算法\ntags:\n  - python\ndate: 2015-08-25 08:41:26\n---\npython的函数第一眼把我震惊了。没有函数结尾标识，只能通过严格的缩进来保证函数的健壮。还有它的参数是可变的，还可以带参数名传递。\n\n\n<!--more-->\n\n## 普通函数：\n\n    #函数开始\n    def fun():\n        print('Hello World!')\n    #函数结束\n    #函数开始\n    def fun(str):\n        print(str)\n    #函数结束\n    #函数开始\n    def fun(str):\n        str += 'a'\n        return str\n    #函数结束\n## 关键字参数 ##\n\n    def fun(a,b='b',c='c',d='d'):\n        return a+b+c+d\n    fun('a')\n    fun('a',b='b1')\n## 可变参数 ##\n\n    def fun(*args):\n        sum = 0\n        for x in args:\n            sum += x\n        return sum\n要强调的是，写函数时不要忘了加`:`","slug":"20","published":1,"updated":"2015-08-25T00:41:41.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cids4qf5s0021oj5ucmbst30q"},{"title":"鞍山赛区D题","date":"2015-08-24T10:34:59.000Z","_content":"好吧，我承认这道题是水题，由于我的原因导致大家没有在赛场上A出这道题，现在把代码发上来，将n^2的复杂度降到线性的\n\n\n<!--more-->\n\n\n```cpp\n#include <iostream>  \n#include <cstdio>  \n#include <cstring>  \n#include <algorithm>  \n  \nusing namespace std;  \n  \nint d[50001];  \n  \nint main(){  \n    int T,n,k;  \n    double sum;  \n    double sum_xi_2,sum_xi,ave,tmp;  \n    double minx;  \n    cin>>T;  \n    while(T--){  \n        cin>>n>>k;  \n        memset(d,0,sizeof(d));  \n        sum = 0;  \n        sum_xi_2 = 0;  \n        sum_xi = 0;  \n        minx = 0;  \n        for (int i = 0; i < n; ++i){  \n            cin>>d[i];  \n        }  \n        sort(d,d+n);  \n        for(int i=0;i<n-k;i++){  \n            sum += d[i];  \n            sum_xi_2 += d[i]*d[i];            \n        }  \n        sum_xi = sum;  \n        ave = sum/(n-k);  \n        minx = sum_xi_2 + (n-k)*ave*ave - 2*ave*sum_xi;  \n        for(int i=1;i<=k;i++){  \n            sum -= d[i-1];  \n            sum += d[n-k+i-1];  \n            sum_xi_2 -= d[i-1]*d[i-1];  \n            sum_xi_2 += d[n-k+i-1]*d[n-k+i-1];  \n            sum_xi = sum;  \n            ave = sum/(n-k);  \n            tmp = sum_xi_2 + (n-k)*ave*ave - 2*ave*sum_xi;  \n            if(tmp < minx)  \n                minx = tmp;  \n        }  \n        printf(\"%.9f\\n\",minx);  \n    }  \n}  \n```\n","source":"_posts/2.md","raw":"title: 鞍山赛区D题\ndate: 2015-08-24 18:34:59\ncategories: 编程与算法\ntags: [ACM,区域赛]\n---\n好吧，我承认这道题是水题，由于我的原因导致大家没有在赛场上A出这道题，现在把代码发上来，将n^2的复杂度降到线性的\n\n\n<!--more-->\n\n\n```cpp\n#include <iostream>  \n#include <cstdio>  \n#include <cstring>  \n#include <algorithm>  \n  \nusing namespace std;  \n  \nint d[50001];  \n  \nint main(){  \n    int T,n,k;  \n    double sum;  \n    double sum_xi_2,sum_xi,ave,tmp;  \n    double minx;  \n    cin>>T;  \n    while(T--){  \n        cin>>n>>k;  \n        memset(d,0,sizeof(d));  \n        sum = 0;  \n        sum_xi_2 = 0;  \n        sum_xi = 0;  \n        minx = 0;  \n        for (int i = 0; i < n; ++i){  \n            cin>>d[i];  \n        }  \n        sort(d,d+n);  \n        for(int i=0;i<n-k;i++){  \n            sum += d[i];  \n            sum_xi_2 += d[i]*d[i];            \n        }  \n        sum_xi = sum;  \n        ave = sum/(n-k);  \n        minx = sum_xi_2 + (n-k)*ave*ave - 2*ave*sum_xi;  \n        for(int i=1;i<=k;i++){  \n            sum -= d[i-1];  \n            sum += d[n-k+i-1];  \n            sum_xi_2 -= d[i-1]*d[i-1];  \n            sum_xi_2 += d[n-k+i-1]*d[n-k+i-1];  \n            sum_xi = sum;  \n            ave = sum/(n-k);  \n            tmp = sum_xi_2 + (n-k)*ave*ave - 2*ave*sum_xi;  \n            if(tmp < minx)  \n                minx = tmp;  \n        }  \n        printf(\"%.9f\\n\",minx);  \n    }  \n}  \n```\n","slug":"2","published":1,"updated":"2015-08-24T13:20:28.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cids4qf5w0024oj5umck4d53v"},{"title":"初学python（七）循环与条件","date":"2015-08-25T00:41:08.000Z","_content":"在python中，条件后边必须要加上`:`从C那边转过来感觉挺别扭的，不过这样跟能区别赋值与条件吧。\n\n\n<!--more-->\n\n## 条件 ##\n\n    if 条件1:\n        <statements>\n    elif 条件2:\n        <statements>\n    elif 条件3:\n        <statements>\n    else:\n        <statements>\n恩，条件大概就是这样的。\n## for循环 ##\nfor循环在各个语言中应该都有的。额，汇编也是可以通过jump 和 goto 实现的。\n在python中，遍历起来会更方便。很像java的那个for遍历。它的for循环中有一个`else`，开始不太理解，后来想明白就是类似于收尾的一个工作，如果循环中没有通过`break`跳出循环的话，在循环结束后就执行`else`中的代码。如果执行了`break`则不会执行`else`中的内容。\n\n    for <variable> in <sequence>:\n    \t<statements>    #变量在队列中\n    else:\n    \t<statements>    #循环结束且没有通过break跳出循环\n如果`for`循环中有`if`，就一定要注意代码的格式问题了，要不就不知道`else`是`if`的还是`for`的。例如\n\n    for x in [1]:\n        if x == 1:\n            print(\"Hello\")\n    else:\n        print(\"World!\")\n它是执行结果就是：\n\n    Hello\n    World!\n## range() ##\n对于数字的遍历，可以使用range函数，废话不多说，看样例：\n\n    >>> for i in range(3):\\    #遍历[0,n)\n    ...     print(i)\n    ... \n    0\n    1\n    2\n    >>> for i in range(3,5):\\    #遍历[x,y)\n    ...     print(i)\n    ... \n    3\n    4\n    >>> for i in range(0,10,3):\\    #以z为步长遍历[x,y)\n    ...     print(i)\n    ... \n    0\n    3\n    6\n    9\n    >>> for i in range(0,-10,-3):\\    #同上\n    ...     print(i)\n    ... \n    0\n    -3\n    -6\n    -9\n还可以通过range()和len()函数结合来遍历有索引的序列。如：\n\n    >>> list = ['a','b','c','d']\n    >>> for i in range(len(list)):\\\n    ...     print(i,list[i])\n    ... \n    0 a\n    1 b\n    2 c\n    3 d\n还可以通过range()得到一个list\n\n    >>> list(range(5))\n    [0, 1, 2, 3, 4]\n## while ##\n额，忘了这个基本的循环结构了。\n\n    while 判断条件：\n        <statements>\n其实在python中只要注意好缩进就可以了。\n还有个奇葩的函数，类似于system.pause，就是`pass`\n写两行代码：\n\n    while True:\n        pass  # 等待键盘中断 (Ctrl+C)\n就可以无限的敲回车了。2333333","source":"_posts/19.md","raw":"title: 初学python（七）循环与条件\ncategories: 编程与算法\ntags:\n  - python\ndate: 2015-08-25 08:41:08\n---\n在python中，条件后边必须要加上`:`从C那边转过来感觉挺别扭的，不过这样跟能区别赋值与条件吧。\n\n\n<!--more-->\n\n## 条件 ##\n\n    if 条件1:\n        <statements>\n    elif 条件2:\n        <statements>\n    elif 条件3:\n        <statements>\n    else:\n        <statements>\n恩，条件大概就是这样的。\n## for循环 ##\nfor循环在各个语言中应该都有的。额，汇编也是可以通过jump 和 goto 实现的。\n在python中，遍历起来会更方便。很像java的那个for遍历。它的for循环中有一个`else`，开始不太理解，后来想明白就是类似于收尾的一个工作，如果循环中没有通过`break`跳出循环的话，在循环结束后就执行`else`中的代码。如果执行了`break`则不会执行`else`中的内容。\n\n    for <variable> in <sequence>:\n    \t<statements>    #变量在队列中\n    else:\n    \t<statements>    #循环结束且没有通过break跳出循环\n如果`for`循环中有`if`，就一定要注意代码的格式问题了，要不就不知道`else`是`if`的还是`for`的。例如\n\n    for x in [1]:\n        if x == 1:\n            print(\"Hello\")\n    else:\n        print(\"World!\")\n它是执行结果就是：\n\n    Hello\n    World!\n## range() ##\n对于数字的遍历，可以使用range函数，废话不多说，看样例：\n\n    >>> for i in range(3):\\    #遍历[0,n)\n    ...     print(i)\n    ... \n    0\n    1\n    2\n    >>> for i in range(3,5):\\    #遍历[x,y)\n    ...     print(i)\n    ... \n    3\n    4\n    >>> for i in range(0,10,3):\\    #以z为步长遍历[x,y)\n    ...     print(i)\n    ... \n    0\n    3\n    6\n    9\n    >>> for i in range(0,-10,-3):\\    #同上\n    ...     print(i)\n    ... \n    0\n    -3\n    -6\n    -9\n还可以通过range()和len()函数结合来遍历有索引的序列。如：\n\n    >>> list = ['a','b','c','d']\n    >>> for i in range(len(list)):\\\n    ...     print(i,list[i])\n    ... \n    0 a\n    1 b\n    2 c\n    3 d\n还可以通过range()得到一个list\n\n    >>> list(range(5))\n    [0, 1, 2, 3, 4]\n## while ##\n额，忘了这个基本的循环结构了。\n\n    while 判断条件：\n        <statements>\n其实在python中只要注意好缩进就可以了。\n还有个奇葩的函数，类似于system.pause，就是`pass`\n写两行代码：\n\n    while True:\n        pass  # 等待键盘中断 (Ctrl+C)\n就可以无限的敲回车了。2333333","slug":"19","published":1,"updated":"2015-08-25T00:41:18.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cids4qf5z002aoj5uaeq03bbo"},{"title":"初学python（六）List常用操作","date":"2015-08-25T00:40:35.000Z","_content":"python的list的用法其实有很多，这里就练习几个常用的吧。\n这里是S的几个函数\n\n<table> <tr> <td>Operation</td> <td>Result</td> <td>Notes</td></tr><tr> <td>s[i] = x</td> <td>item i of s is replaced by x</td> <td> </td></tr><tr> <td>s[i:j] = t</td>  <td>slice of s from i to j is replaced by the contents of the iterable t</td> <td> </td></tr><tr> <td>del s[i:j]</td> <td>same as s[i:j] = []</td> <td> </td></tr><tr> <td>s[i:j:k] = t</td> <td>the elements of s[i:j:k] are replaced by those of t</td>  <td>-1</td></tr><tr> <td>del s[i:j:k]</td> <td>removes the elements of s[i:j:k] from the list</td> <td> </td></tr><tr> <td>s.append(x)</td>  <td>appends x to the end of the sequence (same as s[len(s):len(s)] = [x])</td> <td> </td></tr><tr> <td>s.clear()</td> <td>removes all items from s (same as del s[:])</td> <td>-5</td></tr><tr> <td>s.copy()</td> <td>creates a shallow copy of s (same as s[:])</td> <td>-5</td></tr><tr> <td>s.extend(t)</td> <td>extends s with the contents of t (same as s[len(s):len(s)] = t)</td> <td> </td></tr><tr> <td>s.insert(i, x)</td> <td>inserts x into s at the index given by i (same as s[i:i] = [x])</td> <td> </td></tr><tr>  <td>s.pop([i])</td> <td>retrieves the item at i and also removes it from s</td> <td>-2</td></tr><tr>  <td>s.remove(x)</td> <td>remove the first item from s where s[i] == x</td>  <td>-3</td></tr><tr> <td>s.reverse()</td> <td>reverses the items of s in place</td>  <td>-4</td></tr></table>\n\n\n<!--more-->\n好像找到中文版了，补充一下哈：\n<table class=\"table-bordered table-striped table-condensed\"> <tr> <th>方法</th> <th>描述</th> </tr> <tr> <td>list.append(x) </td> <td>把一个元素添加到列表的结尾，相当于 a[len(a):] = [x]。 </td> </tr> <tr> <td>list.extend(L) </td> <td>通过添加指定列表的所有元素来扩充列表，相当于 a[len(a):] = L。 </td> </tr> <tr> <td>list.insert(i, x) </td> <td>在指定位置插入一个元素。第一个参数是准备插入到其前面的那个元素的索引，例如 a.insert(0, x) 会插入到整个列表之前，而 a.insert(len(a), x) 相当于 a.append(x) 。 </td> </tr> <tr> <td>list.remove(x) </td> <td>删除列表中值为 x 的第一个元素。如果没有这样的元素，就会返回一个错误。 </td> </tr> <tr> <td>list.pop([i]) </td> <td>从列表的指定位置删除元素，并将其返回。如果没有指定索引，a.pop()返回最后一个元素。元素随即从列表中被删除。（方法中 i 两边的方括号表示这个参数是可选的，而不是要求你输入一对方括号，你会经常在 Python 库参考手册中遇到这样的标记。） </td> </tr> <tr> <td>list.clear() </td> <td>移除列表中的所有项，等于del a[:]。 </td> </tr> <tr> <td>list.index(x) </td> <td>返回列表中第一个值为 x 的元素的索引。如果没有匹配的元素就会返回一个错误。 </td> </tr> <tr> <td>list.count(x) </td> <td>返回 x 在列表中出现的次数。 </td> </tr> <tr> <td>list.sort() </td> <td>对列表中的元素进行排序。 </td> </tr> <tr> <td>list.reverse() </td> <td>倒排列表中的元素。 </td> </tr> <tr> <td>list.copy() </td> <td>返回列表的浅复制，等于a[:]。 </td> </tr> </table>\n\n接下来是我的测试：\n## 定义 ##\n    >>> list = ['a','b','c','d']\n    >>> list\n    ['a', 'b', 'c', 'd']\n## 索引 ##\n    >>> list[0]\n    'a'\n    >>> list[-1]\n    'd'\n    >>> list[1:3]    #获取[1,3)区间的元素\n    ['b', 'c']\n## 追加和插入 ##\n    >>> list.append('e')    #尾部追加\n    >>> list\n    ['a', 'b', 'c', 'd', 'e']\n    >>> list.insert(1,'a2')    #下标插入\n    >>> list\n    ['a', 'a2', 'b', 'c', 'd', 'e']\n    >>> list.extend(['f','g','h'])    #尾部追加list\n    >>> list\n    ['a', 'a2', 'b', 'c', 'd', 'e', 'f', 'g', 'h']\n## 检索 ##\n    >>> list.index('a2')\n    1\n    >>> 'b2' in list\n    False\n## 运算符 ##\n    >>> list += ['i','j']\n    >>> list\n    ['a', 'a2', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j']\n    >>> list = ['a','b']*3\n    >>> list\n    ['a', 'b', 'a', 'b', 'a', 'b']\n## join用法 ##\n    >>> params ={'one':'first','two':'twice','three':'third'}\n    >>> ['%s=%s' % (k,v) for k,v in params.items()]\n    ['three=third', 'one=first', 'two=twice']\n    >>> list = '&&'.join(['%s=%s' % (k,v) for k,v in params.items()])\n    >>> list\n    'three=third&&one=first&&two=twice'\n## 分割 ##\n    >>> list.split('&&')\n    ['three=third', 'one=first', 'two=twice']\n    >>> list.split('&&',1)    #第二个参数为分割次数\n    ['three=third', 'one=first&&two=twice']\n## 映射和过滤 ##\n    >>> list = [1,2,3,4]\n    >>> list = [elem*2 for elem in list]\n    >>> list\n    [2, 4, 6, 8]\n    >>> list = [elem for elem in list if elem >2]\n    >>> list\n    [4, 6, 8]\n    >>> list = [1,2,3,4,5,6,1,1,2,3,4]\n    >>> list\n    [1, 2, 3, 4, 5, 6, 1, 1, 2, 3, 4]\n    >>> list = [elem for elem in list if list.count(elem) > 1]\n    >>> list\n    [1, 2, 3, 4, 1, 1, 2, 3, 4]\n\n## 删除操作 ##\n\n    >>> list.remove(1)    #删除首次出现的值\n    >>> list\n    [2, 3, 4, 1, 1, 2, 3, 4]\n    >>> list.pop()    #删除尾部元素，并且返回\n    4\n    >>> list\n    [2, 3, 4, 1, 1, 2, 3]\n\n","source":"_posts/18.md","raw":"title: 初学python（六）List常用操作\ncategories: 编程与算法\ntags:\n  - python\ndate: 2015-08-25 08:40:35\n---\npython的list的用法其实有很多，这里就练习几个常用的吧。\n这里是S的几个函数\n\n<table> <tr> <td>Operation</td> <td>Result</td> <td>Notes</td></tr><tr> <td>s[i] = x</td> <td>item i of s is replaced by x</td> <td> </td></tr><tr> <td>s[i:j] = t</td>  <td>slice of s from i to j is replaced by the contents of the iterable t</td> <td> </td></tr><tr> <td>del s[i:j]</td> <td>same as s[i:j] = []</td> <td> </td></tr><tr> <td>s[i:j:k] = t</td> <td>the elements of s[i:j:k] are replaced by those of t</td>  <td>-1</td></tr><tr> <td>del s[i:j:k]</td> <td>removes the elements of s[i:j:k] from the list</td> <td> </td></tr><tr> <td>s.append(x)</td>  <td>appends x to the end of the sequence (same as s[len(s):len(s)] = [x])</td> <td> </td></tr><tr> <td>s.clear()</td> <td>removes all items from s (same as del s[:])</td> <td>-5</td></tr><tr> <td>s.copy()</td> <td>creates a shallow copy of s (same as s[:])</td> <td>-5</td></tr><tr> <td>s.extend(t)</td> <td>extends s with the contents of t (same as s[len(s):len(s)] = t)</td> <td> </td></tr><tr> <td>s.insert(i, x)</td> <td>inserts x into s at the index given by i (same as s[i:i] = [x])</td> <td> </td></tr><tr>  <td>s.pop([i])</td> <td>retrieves the item at i and also removes it from s</td> <td>-2</td></tr><tr>  <td>s.remove(x)</td> <td>remove the first item from s where s[i] == x</td>  <td>-3</td></tr><tr> <td>s.reverse()</td> <td>reverses the items of s in place</td>  <td>-4</td></tr></table>\n\n\n<!--more-->\n好像找到中文版了，补充一下哈：\n<table class=\"table-bordered table-striped table-condensed\"> <tr> <th>方法</th> <th>描述</th> </tr> <tr> <td>list.append(x) </td> <td>把一个元素添加到列表的结尾，相当于 a[len(a):] = [x]。 </td> </tr> <tr> <td>list.extend(L) </td> <td>通过添加指定列表的所有元素来扩充列表，相当于 a[len(a):] = L。 </td> </tr> <tr> <td>list.insert(i, x) </td> <td>在指定位置插入一个元素。第一个参数是准备插入到其前面的那个元素的索引，例如 a.insert(0, x) 会插入到整个列表之前，而 a.insert(len(a), x) 相当于 a.append(x) 。 </td> </tr> <tr> <td>list.remove(x) </td> <td>删除列表中值为 x 的第一个元素。如果没有这样的元素，就会返回一个错误。 </td> </tr> <tr> <td>list.pop([i]) </td> <td>从列表的指定位置删除元素，并将其返回。如果没有指定索引，a.pop()返回最后一个元素。元素随即从列表中被删除。（方法中 i 两边的方括号表示这个参数是可选的，而不是要求你输入一对方括号，你会经常在 Python 库参考手册中遇到这样的标记。） </td> </tr> <tr> <td>list.clear() </td> <td>移除列表中的所有项，等于del a[:]。 </td> </tr> <tr> <td>list.index(x) </td> <td>返回列表中第一个值为 x 的元素的索引。如果没有匹配的元素就会返回一个错误。 </td> </tr> <tr> <td>list.count(x) </td> <td>返回 x 在列表中出现的次数。 </td> </tr> <tr> <td>list.sort() </td> <td>对列表中的元素进行排序。 </td> </tr> <tr> <td>list.reverse() </td> <td>倒排列表中的元素。 </td> </tr> <tr> <td>list.copy() </td> <td>返回列表的浅复制，等于a[:]。 </td> </tr> </table>\n\n接下来是我的测试：\n## 定义 ##\n    >>> list = ['a','b','c','d']\n    >>> list\n    ['a', 'b', 'c', 'd']\n## 索引 ##\n    >>> list[0]\n    'a'\n    >>> list[-1]\n    'd'\n    >>> list[1:3]    #获取[1,3)区间的元素\n    ['b', 'c']\n## 追加和插入 ##\n    >>> list.append('e')    #尾部追加\n    >>> list\n    ['a', 'b', 'c', 'd', 'e']\n    >>> list.insert(1,'a2')    #下标插入\n    >>> list\n    ['a', 'a2', 'b', 'c', 'd', 'e']\n    >>> list.extend(['f','g','h'])    #尾部追加list\n    >>> list\n    ['a', 'a2', 'b', 'c', 'd', 'e', 'f', 'g', 'h']\n## 检索 ##\n    >>> list.index('a2')\n    1\n    >>> 'b2' in list\n    False\n## 运算符 ##\n    >>> list += ['i','j']\n    >>> list\n    ['a', 'a2', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j']\n    >>> list = ['a','b']*3\n    >>> list\n    ['a', 'b', 'a', 'b', 'a', 'b']\n## join用法 ##\n    >>> params ={'one':'first','two':'twice','three':'third'}\n    >>> ['%s=%s' % (k,v) for k,v in params.items()]\n    ['three=third', 'one=first', 'two=twice']\n    >>> list = '&&'.join(['%s=%s' % (k,v) for k,v in params.items()])\n    >>> list\n    'three=third&&one=first&&two=twice'\n## 分割 ##\n    >>> list.split('&&')\n    ['three=third', 'one=first', 'two=twice']\n    >>> list.split('&&',1)    #第二个参数为分割次数\n    ['three=third', 'one=first&&two=twice']\n## 映射和过滤 ##\n    >>> list = [1,2,3,4]\n    >>> list = [elem*2 for elem in list]\n    >>> list\n    [2, 4, 6, 8]\n    >>> list = [elem for elem in list if elem >2]\n    >>> list\n    [4, 6, 8]\n    >>> list = [1,2,3,4,5,6,1,1,2,3,4]\n    >>> list\n    [1, 2, 3, 4, 5, 6, 1, 1, 2, 3, 4]\n    >>> list = [elem for elem in list if list.count(elem) > 1]\n    >>> list\n    [1, 2, 3, 4, 1, 1, 2, 3, 4]\n\n## 删除操作 ##\n\n    >>> list.remove(1)    #删除首次出现的值\n    >>> list\n    [2, 3, 4, 1, 1, 2, 3, 4]\n    >>> list.pop()    #删除尾部元素，并且返回\n    4\n    >>> list\n    [2, 3, 4, 1, 1, 2, 3]\n\n","slug":"18","published":1,"updated":"2015-08-25T01:06:39.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cids4qf64002doj5ul0qtu0nz"},{"title":"初学python（五）字符串操作","date":"2015-08-25T00:40:02.000Z","_content":"现在列举一些字符串判断的函数。\n\n```python\nprint(str.isalnum())     # 判断所有字符都是数字或者字母\nprint(str.isalpha())     # 判断所有字符都是字母\nprint(str.isdigit())     # 判断所有字符都是数字\nprint(str.islower())     # 判断所有字符都是小写\nprint(str.isupper())     # 判断所有字符都是大写\nprint(str.istitle())     # 判断所有单词都是首字母大写，像标题\nprint(str.isspace())     # 判断所有字符都是空白字符、\\t、\\n、\\r\nprint(str.upper())       # 把所有字符中的小写字母转换成大写字母\nprint(str.lower())       # 把所有字符中的大写字母转换成小写字母\nprint(str.capitalize())  # 把第一个字母转化为大写字母，其余小写\nprint(str.title())       # 把每个单词的第一个字母转化为大写，其余小写 \n```","source":"_posts/17.md","raw":"title: 初学python（五）字符串操作\ncategories: 编程与算法\ntags:\n  - python\ndate: 2015-08-25 08:40:02\n---\n现在列举一些字符串判断的函数。\n\n```python\nprint(str.isalnum())     # 判断所有字符都是数字或者字母\nprint(str.isalpha())     # 判断所有字符都是字母\nprint(str.isdigit())     # 判断所有字符都是数字\nprint(str.islower())     # 判断所有字符都是小写\nprint(str.isupper())     # 判断所有字符都是大写\nprint(str.istitle())     # 判断所有单词都是首字母大写，像标题\nprint(str.isspace())     # 判断所有字符都是空白字符、\\t、\\n、\\r\nprint(str.upper())       # 把所有字符中的小写字母转换成大写字母\nprint(str.lower())       # 把所有字符中的大写字母转换成小写字母\nprint(str.capitalize())  # 把第一个字母转化为大写字母，其余小写\nprint(str.title())       # 把每个单词的第一个字母转化为大写，其余小写 \n```","slug":"17","published":1,"updated":"2015-08-25T00:40:19.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cids4qf66002goj5u32lnenmg"},{"title":"初学python（四）进制与字符转换和文件读写","date":"2015-08-25T00:37:36.000Z","_content":"现在学到了如何将十进制转换为其他进制，和字符与ASCII码之间的转换。\n还有文件的读写。\n\n<!--more-->\n\n    dec = 12\n    print(bin(dec))    #二进制\n    print(oct(dec))    #八进制\n    print(hex(dec))    #十六进制\n    c = 'a'\n    a = '10'\n    print(ord(c))    #字符 -> ASCII码\n    print(chr(a))    #ASCII码 -> 字符\n文件的读写：\n\n    # 写文件\n    with open(\"out\", \"wt\") as out_file:\n        out_file.write(\"该文本会写入到文件中\\n看到我了吧!\")\n    # Read a file\n    with open(\"in\", \"rt\") as in_file:\n        text = in_file.read()\n    print(text)","source":"_posts/16.md","raw":"title: 初学python（四）进制与字符转换和文件读写\ncategories: 编程与算法\ntags:\n  - python\ndate: 2015-08-25 08:37:36\n---\n现在学到了如何将十进制转换为其他进制，和字符与ASCII码之间的转换。\n还有文件的读写。\n\n<!--more-->\n\n    dec = 12\n    print(bin(dec))    #二进制\n    print(oct(dec))    #八进制\n    print(hex(dec))    #十六进制\n    c = 'a'\n    a = '10'\n    print(ord(c))    #字符 -> ASCII码\n    print(chr(a))    #ASCII码 -> 字符\n文件的读写：\n\n    # 写文件\n    with open(\"out\", \"wt\") as out_file:\n        out_file.write(\"该文本会写入到文件中\\n看到我了吧!\")\n    # Read a file\n    with open(\"in\", \"rt\") as in_file:\n        text = in_file.read()\n    print(text)","slug":"16","published":1,"updated":"2015-08-25T00:37:58.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cids4qf68002joj5uh4la8wbg"},{"title":"初学python（三）一些练习","date":"2015-08-25T00:36:49.000Z","_content":"学习了部分的语法，现在来练习一些。\n\n - A+B\n - 交换两个变量\n - 随机数\n - 条件语句\n\n\n<!--more-->\n\n## A+B ##\n这个我以为很简单，不过发现python将所有的输入都当做了字符串，所以需要输入的时候进行转换\n\n    a = int(input())\n    b = int(input())\n    print (a+b)\n## SWAP ##\n交换变量比C要简单，不用异或或者使用临时变量\n\n    x,y = y,x\n## Rand ##\n\n    import random\n    print(random.randint(0,9))\n## if else ##\n条件语句写着挺别扭的，条件和else后面要加`:`\n而且0为false，字符串的'0'却为true\n\n    if 0:    #false\n        print('0 is true!')\n    elif '0':    #true\n        print('\\'0\\' is true!')\n    else:\n        print(0 & \\'0\\' are false!)","source":"_posts/15.md","raw":"title: 初学python（三）一些练习\ncategories: 编程与算法\ndate: 2015-08-25 08:36:49\ntags: [python]\n---\n学习了部分的语法，现在来练习一些。\n\n - A+B\n - 交换两个变量\n - 随机数\n - 条件语句\n\n\n<!--more-->\n\n## A+B ##\n这个我以为很简单，不过发现python将所有的输入都当做了字符串，所以需要输入的时候进行转换\n\n    a = int(input())\n    b = int(input())\n    print (a+b)\n## SWAP ##\n交换变量比C要简单，不用异或或者使用临时变量\n\n    x,y = y,x\n## Rand ##\n\n    import random\n    print(random.randint(0,9))\n## if else ##\n条件语句写着挺别扭的，条件和else后面要加`:`\n而且0为false，字符串的'0'却为true\n\n    if 0:    #false\n        print('0 is true!')\n    elif '0':    #true\n        print('\\'0\\' is true!')\n    else:\n        print(0 & \\'0\\' are false!)","slug":"15","published":1,"updated":"2015-08-25T00:37:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cids4qf6a002moj5uiwivdxs7"},{"title":"初学python（二）数据类型","date":"2015-08-25T00:34:52.000Z","_content":"据说python里有6个标准的数据类型：\n\n - Numbers（数字）\n - String（字符串）\n - List（列表） \n - Tuple（元组） \n - Sets（集合）\n - Dictionaries（字典）\n\n\n<!--more-->\n\n## Numbers（数字） ##\npython3 支持int、float、bool、complex\n还可以通过一个叫`type()`的函数来输出类型，自己测试了一下\n\n    Python 3.4.0 (default, Apr 11 2014, 13:05:18) \n    [GCC 4.8.2] on linux\n    Type \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n    >>> a,b,c,d = 10,2.5,True,4+3j\n    >>> print(type(a),type(b),type(c),type(d))\n    <class 'int'> <class 'float'> <class 'bool'> <class 'complex'>\n    >>> \n还有运算：\n\n    >>> 1 + 1 #加\n    2\n    >>> 1 - 1 #减\n    0\n    >>> 1 × 1 #乘\n      File \"<stdin>\", line 1\n        1 × 1 #乘\n          ^\n    SyntaxError: invalid character in identifier\n    >>> 1 * 1 #乘\n    1\n    >>> 3 / 2 #浮点数除\n    1.5\n    >>> 3 // 2 #整除\n    1\n    >>> 3 % 2 #取模\n    1\n    >>> 2 ** 4 #幂\n    16\n    >>> pow(2,4) #幂\n    16\n## String（字符串） ##\n这个没什么好说的，上一节感觉熟练了一下。\n可以用`*`来重复字符串，用`+`来拼接字符串，用`string[index]`来取字符，或者用`string[-index]`来倒着取字符。和ruby一样一样的。\n还有字符串分割`string[index_x:index_y]`\n但是不能通`过string[index] = x`进行赋值，因为字符串是不可改变的。\n## List（列表） ##\n先说列表的赋值吧，一个列表中可以扔进任何一个类型的数据，不用在意类型。例如\n\n    >>> a = ['him', 25, 100, 'her']\n    >>> print(a)\n    ['him', 25, 100, 'her']\n它还支持拼接、修改、分割操作，\n\n    >>> a = [1, 2, 3, 4, 5]\n    >>> a + [6, 7, 8]\n    [1, 2, 3, 4, 5, 6, 7, 8]\n    >>> a = [1, 2, 3, 4, 5, 6]\n    >>> a[0] = 9\n    >>> a[2:5] = [13, 14, 15]\n    >>> a\n    [9, 2, 13, 14, 15, 6]\n    >>> a[2:5] = []   # 删除\n    >>> a\n    [9, 2, 6]\n## （元组） ##\n元组（tuple）与列表类似，不同之处在于元组的元素不能修改。元组写在小括号里，元素之间用逗号隔开。\n例如：\n\n    >>> a = (1991, 2014, 'physics', 'math')\n    >>> print(a, type(a), len(a))\n    (1991, 2014, 'physics', 'math') <class 'tuple'> 4\n元组与字符串类似，可以被索引且下标索引从0开始，也可以进行截取/切片（看上面，这里不再赘述）。\n其实，可以把字符串看作一种特殊的元组。\n\n    >>> tup = (1, 2, 3, 4, 5, 6)\n    >>> print(tup[0], tup[1:5])\n    1 (2, 3, 4, 5)\n    >>> tup[0] = 11  # 修改元组元素的操作是非法的\n\n虽然tuple的元素不可改变，但它可以包含可变的对象，比如list列表。\n构造包含0个或1个元素的tuple是个特殊的问题，所以有一些额外的语法规则：\n\n    tup1 = () # 空元组\n    tup2 = (20,) # 一个元素，需要在元素后添加逗号\n\n另外，元组也支持用+操作符：\n\n    >>> tup1, tup2 = (1, 2, 3), (4, 5, 6)\n    >>> print(tup1+tup2)\n    (1, 2, 3, 4, 5, 6)\n## Sets（集合） ##\n集合（set）是一个无序不重复元素的集。\n好熟悉的结构，哈哈哈。\n基本功能是进行成员关系测试和消除重复元素。\n可以使用大括号 或者 set()函数创建set集合，注意：创建一个空集合必须用 set() 而不是 { }，因为{ }是用来创建一个空字典。\n下面来个例子吧：\n\n    >>> set_text = {'item0','item1','item2','item3','item4','item5','item6'}\n    >>> print(set_text)\n    {'item1', 'item4', 'item3', 'item2', 'item6', 'item5', 'item0'}\n    >>> #果然是无序的\n    ... \n    >>> 'item3' in set_text #成员测试?\n    True\n    >>> 'item7' in set_text #成员测试?\n    False\n    >>> #据说还可以进行集合运算\n    ... \n    >>> a = set(sadfdsafsdfas)\n    Traceback (most recent call last):\n      File \"<stdin>\", line 1, in <module>\n    NameError: name 'sadfdsafsdfas' is not defined\n    >>> a = set('sadfdsafsdfas')\n    >>> b = set('sdlifjxz')\n    >>> a\n    {'d', 'a', 'f', 's'}\n    >>> b\n    {'z', 'd', 'l', 'f', 'x', 'j', 's', 'i'}\n    >>> b-a    #差\n    {'x', 'l', 'j', 'i', 'z'}\n    >>> a | b    #并\n    {'z', 'd', 'f', 'l', 'x', 'j', 'a', 's', 'i'}\n    >>> a & b    #交\n    {'d', 'f', 's'}\n    >>> a ^ b    #a和b中不同时存在的元素\n    {'z', 'l', 'x', 'j', 'a', 'i'}\n\n## Dictionaries（字典） ##\n这应该就是在C里用的`map`吧，一个映射类型。其中的key必须是不可变类型，`list`和`tuple`就不行了。\n基本操作：添删改查\n\n    >>> dic = {} #空字典\n    >>> dic\n    {}\n    >>> dics = {'tom':1,'jerry':10,'cat':11}\n    >>> dics\n    {'jerry': 10, 'cat': 11, 'tom': 1}\n    >>> dics['tom'] #查\n    1\n    >>> dics['toms'] #查空\n    Traceback (most recent call last):\n      File \"<stdin>\", line 1, in <module>\n    KeyError: 'toms'\n    >>> del dics['tom'] #删\n    >>> dics\n    {'jerry': 10, 'cat': 11}\n    >>> dics['mouse'] = 100 #添\n    >>> dics\n    {'mouse': 100, 'jerry': 10, 'cat': 11}\n    >>> dics['mouse'] = 101 #改\n    >>> dics\n    {'mouse': 101, 'jerry': 10, 'cat': 11}\n进阶操作：\n\n    >>> list (dics.keys()) #返回所有key组成的list\n    ['mouse', 'jerry', 'cat']\n    >>> list (dics.values()) #返回所有value组成的list\n    [101, 10, 11]\n    >>> sorted (dics.keys()) #按key排序\n    ['cat', 'jerry', 'mouse']\n    >>> 'cat' in dics #成员测试?\n    True\n    >>> 'cats' in dics #成员测试?\n    False\n奇葩的构造方式，从sequence中构建\n\n    >>> dict([('sape', 4139), ('guido', 4127), ('jack', 4098)])\n    {'jack': 4098, 'sape': 4139, 'guido': 4127}\n    >>> {x: x**2 for x in (2, 4, 6)}\n    {2: 4, 4: 16, 6: 36}\n    >>> dict(sape=4139, guido=4127, jack=4098)\n    {'jack': 4098, 'sape': 4139, 'guido': 4127}\n\n","source":"_posts/14.md","raw":"title: 初学python（二）数据类型\ncategories: 编程与算法\ndate: 2015-08-25 08:34:52\ntags: [python]\n---\n据说python里有6个标准的数据类型：\n\n - Numbers（数字）\n - String（字符串）\n - List（列表） \n - Tuple（元组） \n - Sets（集合）\n - Dictionaries（字典）\n\n\n<!--more-->\n\n## Numbers（数字） ##\npython3 支持int、float、bool、complex\n还可以通过一个叫`type()`的函数来输出类型，自己测试了一下\n\n    Python 3.4.0 (default, Apr 11 2014, 13:05:18) \n    [GCC 4.8.2] on linux\n    Type \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n    >>> a,b,c,d = 10,2.5,True,4+3j\n    >>> print(type(a),type(b),type(c),type(d))\n    <class 'int'> <class 'float'> <class 'bool'> <class 'complex'>\n    >>> \n还有运算：\n\n    >>> 1 + 1 #加\n    2\n    >>> 1 - 1 #减\n    0\n    >>> 1 × 1 #乘\n      File \"<stdin>\", line 1\n        1 × 1 #乘\n          ^\n    SyntaxError: invalid character in identifier\n    >>> 1 * 1 #乘\n    1\n    >>> 3 / 2 #浮点数除\n    1.5\n    >>> 3 // 2 #整除\n    1\n    >>> 3 % 2 #取模\n    1\n    >>> 2 ** 4 #幂\n    16\n    >>> pow(2,4) #幂\n    16\n## String（字符串） ##\n这个没什么好说的，上一节感觉熟练了一下。\n可以用`*`来重复字符串，用`+`来拼接字符串，用`string[index]`来取字符，或者用`string[-index]`来倒着取字符。和ruby一样一样的。\n还有字符串分割`string[index_x:index_y]`\n但是不能通`过string[index] = x`进行赋值，因为字符串是不可改变的。\n## List（列表） ##\n先说列表的赋值吧，一个列表中可以扔进任何一个类型的数据，不用在意类型。例如\n\n    >>> a = ['him', 25, 100, 'her']\n    >>> print(a)\n    ['him', 25, 100, 'her']\n它还支持拼接、修改、分割操作，\n\n    >>> a = [1, 2, 3, 4, 5]\n    >>> a + [6, 7, 8]\n    [1, 2, 3, 4, 5, 6, 7, 8]\n    >>> a = [1, 2, 3, 4, 5, 6]\n    >>> a[0] = 9\n    >>> a[2:5] = [13, 14, 15]\n    >>> a\n    [9, 2, 13, 14, 15, 6]\n    >>> a[2:5] = []   # 删除\n    >>> a\n    [9, 2, 6]\n## （元组） ##\n元组（tuple）与列表类似，不同之处在于元组的元素不能修改。元组写在小括号里，元素之间用逗号隔开。\n例如：\n\n    >>> a = (1991, 2014, 'physics', 'math')\n    >>> print(a, type(a), len(a))\n    (1991, 2014, 'physics', 'math') <class 'tuple'> 4\n元组与字符串类似，可以被索引且下标索引从0开始，也可以进行截取/切片（看上面，这里不再赘述）。\n其实，可以把字符串看作一种特殊的元组。\n\n    >>> tup = (1, 2, 3, 4, 5, 6)\n    >>> print(tup[0], tup[1:5])\n    1 (2, 3, 4, 5)\n    >>> tup[0] = 11  # 修改元组元素的操作是非法的\n\n虽然tuple的元素不可改变，但它可以包含可变的对象，比如list列表。\n构造包含0个或1个元素的tuple是个特殊的问题，所以有一些额外的语法规则：\n\n    tup1 = () # 空元组\n    tup2 = (20,) # 一个元素，需要在元素后添加逗号\n\n另外，元组也支持用+操作符：\n\n    >>> tup1, tup2 = (1, 2, 3), (4, 5, 6)\n    >>> print(tup1+tup2)\n    (1, 2, 3, 4, 5, 6)\n## Sets（集合） ##\n集合（set）是一个无序不重复元素的集。\n好熟悉的结构，哈哈哈。\n基本功能是进行成员关系测试和消除重复元素。\n可以使用大括号 或者 set()函数创建set集合，注意：创建一个空集合必须用 set() 而不是 { }，因为{ }是用来创建一个空字典。\n下面来个例子吧：\n\n    >>> set_text = {'item0','item1','item2','item3','item4','item5','item6'}\n    >>> print(set_text)\n    {'item1', 'item4', 'item3', 'item2', 'item6', 'item5', 'item0'}\n    >>> #果然是无序的\n    ... \n    >>> 'item3' in set_text #成员测试?\n    True\n    >>> 'item7' in set_text #成员测试?\n    False\n    >>> #据说还可以进行集合运算\n    ... \n    >>> a = set(sadfdsafsdfas)\n    Traceback (most recent call last):\n      File \"<stdin>\", line 1, in <module>\n    NameError: name 'sadfdsafsdfas' is not defined\n    >>> a = set('sadfdsafsdfas')\n    >>> b = set('sdlifjxz')\n    >>> a\n    {'d', 'a', 'f', 's'}\n    >>> b\n    {'z', 'd', 'l', 'f', 'x', 'j', 's', 'i'}\n    >>> b-a    #差\n    {'x', 'l', 'j', 'i', 'z'}\n    >>> a | b    #并\n    {'z', 'd', 'f', 'l', 'x', 'j', 'a', 's', 'i'}\n    >>> a & b    #交\n    {'d', 'f', 's'}\n    >>> a ^ b    #a和b中不同时存在的元素\n    {'z', 'l', 'x', 'j', 'a', 'i'}\n\n## Dictionaries（字典） ##\n这应该就是在C里用的`map`吧，一个映射类型。其中的key必须是不可变类型，`list`和`tuple`就不行了。\n基本操作：添删改查\n\n    >>> dic = {} #空字典\n    >>> dic\n    {}\n    >>> dics = {'tom':1,'jerry':10,'cat':11}\n    >>> dics\n    {'jerry': 10, 'cat': 11, 'tom': 1}\n    >>> dics['tom'] #查\n    1\n    >>> dics['toms'] #查空\n    Traceback (most recent call last):\n      File \"<stdin>\", line 1, in <module>\n    KeyError: 'toms'\n    >>> del dics['tom'] #删\n    >>> dics\n    {'jerry': 10, 'cat': 11}\n    >>> dics['mouse'] = 100 #添\n    >>> dics\n    {'mouse': 100, 'jerry': 10, 'cat': 11}\n    >>> dics['mouse'] = 101 #改\n    >>> dics\n    {'mouse': 101, 'jerry': 10, 'cat': 11}\n进阶操作：\n\n    >>> list (dics.keys()) #返回所有key组成的list\n    ['mouse', 'jerry', 'cat']\n    >>> list (dics.values()) #返回所有value组成的list\n    [101, 10, 11]\n    >>> sorted (dics.keys()) #按key排序\n    ['cat', 'jerry', 'mouse']\n    >>> 'cat' in dics #成员测试?\n    True\n    >>> 'cats' in dics #成员测试?\n    False\n奇葩的构造方式，从sequence中构建\n\n    >>> dict([('sape', 4139), ('guido', 4127), ('jack', 4098)])\n    {'jack': 4098, 'sape': 4139, 'guido': 4127}\n    >>> {x: x**2 for x in (2, 4, 6)}\n    {2: 4, 4: 16, 6: 36}\n    >>> dict(sape=4139, guido=4127, jack=4098)\n    {'jack': 4098, 'sape': 4139, 'guido': 4127}\n\n","slug":"14","published":1,"updated":"2015-08-25T00:35:11.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cids4qf6c002poj5utcclaanm"},{"title":"Qt中实现将float类型转换为QString类型","date":"2015-08-25T00:34:04.000Z","_content":"原帖地址：http://blog.csdn.net/leo115/article/details/7757118\n\n在使用Qt Creator编程时，难免会用到将float类型转换为QString类型的时候下面是我所有的方法：\n1. 将QString类型转化为float类型，很简单\n\n    QString data;            \n    float num = data.toFloat();\n    即可很轻松的实现。\n2. 但是如何将float类型转化为QString类型呢？\n    查看API很难发现封装好的转化函数\n    可以尝试使用下面的代码转化：\n    float num = 1.222;\n    QString data = QString(\"float is %1\").arg(num);\n    输出结果是：float is 1.222\n    如果只要float转化成的数值，则使用如下：\n    QString data = QString(\"%1\").arg(num);\n\n至此完毕。。。。。。。。。。。。。。。。","source":"_posts/13.md","raw":"title: Qt中实现将float类型转换为QString类型\ncategories: 编程与算法\ndate: 2015-08-25 08:34:04\ntags: [QT,VS]\n---\n原帖地址：http://blog.csdn.net/leo115/article/details/7757118\n\n在使用Qt Creator编程时，难免会用到将float类型转换为QString类型的时候下面是我所有的方法：\n1. 将QString类型转化为float类型，很简单\n\n    QString data;            \n    float num = data.toFloat();\n    即可很轻松的实现。\n2. 但是如何将float类型转化为QString类型呢？\n    查看API很难发现封装好的转化函数\n    可以尝试使用下面的代码转化：\n    float num = 1.222;\n    QString data = QString(\"float is %1\").arg(num);\n    输出结果是：float is 1.222\n    如果只要float转化成的数值，则使用如下：\n    QString data = QString(\"%1\").arg(num);\n\n至此完毕。。。。。。。。。。。。。。。。","slug":"13","published":1,"updated":"2015-08-25T00:34:27.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cids4qf6f002soj5uff53n8m5"},{"title":"osgi luna 版本依赖问题","date":"2015-08-25T00:33:16.000Z","_content":"最新版的eclipse luna 对于osgi的依赖异常麻烦，为了运行jetty需要添加一下依赖的bundle\n就在这做个总结吧，方便参考，\n\n\n<!--more-->\n\n\n    id  State       Bundle  \n    0   ACTIVE      org.eclipse.osgi_3.10.1.v20140909-1633  \n    1   ACTIVE      org.apache.commons.logging_1.1.1.v201101211721  \n    2   ACTIVE      org.apache.felix.gogo.runtime_0.10.0.v201209301036  \n    3   ACTIVE      org.eclipse.equinox.http.jetty_3.0.200.v20131021-1843  \n    4   ACTIVE      org.eclipse.equinox.console_1.1.0.v20140131-1639  \n    5   ACTIVE      org.apache.felix.gogo.shell_0.10.0.v201212101605  \n    6   ACTIVE      javax.servlet_3.0.0.v201112011016  \n    7   ACTIVE      org.apache.commons.logging_1.0.4.v201101211617  \n    8   ACTIVE      org.eclipse.equinox.http.servlet_1.1.500.v20140318-1755  \n    9   ACTIVE      org.eclipse.osgi.services_3.4.0.v20140312-2051  \n    10  ACTIVE      org.eclipse.jetty.http_8.1.14.v20131031  \n    11  ACTIVE      org.eclipse.jetty.io_8.1.14.v20131031  \n    12  ACTIVE      org.eclipse.jetty.util_8.1.14.v20131031  \n    13  ACTIVE      org.eclipse.jetty.server_8.1.14.v20131031  \n    14  ACTIVE      org.eclipse.jetty.continuation_8.1.14.v20131031  \n    15  ACTIVE      org.eclipse.jetty.servlet_8.1.14.v20131031  \n    16  ACTIVE      org.eclipse.jetty.security_8.1.14.v20131031  \n    17  ACTIVE      org.eclipse.jetty.webapp_8.1.3.v20120522  \n    18  ACTIVE      org.eclipse.jetty.xml_8.1.3.v20120522  \n同时如果是linux下，访问80端口需要权限所以在Run Configurations 中运行配置里面的 Arguments 页签,在 VM arguments 中添加`-Dorg.osgi.service.http.port=8080`\n这样就可以运行了，一般同一版本的osgi不会出现版本问题，就是不用修改版本依赖","source":"_posts/12.md","raw":"title: osgi luna 版本依赖问题\ncategories: 编程与算法\ndate: 2015-08-25 08:33:16\ntags: [osgi]\n---\n最新版的eclipse luna 对于osgi的依赖异常麻烦，为了运行jetty需要添加一下依赖的bundle\n就在这做个总结吧，方便参考，\n\n\n<!--more-->\n\n\n    id  State       Bundle  \n    0   ACTIVE      org.eclipse.osgi_3.10.1.v20140909-1633  \n    1   ACTIVE      org.apache.commons.logging_1.1.1.v201101211721  \n    2   ACTIVE      org.apache.felix.gogo.runtime_0.10.0.v201209301036  \n    3   ACTIVE      org.eclipse.equinox.http.jetty_3.0.200.v20131021-1843  \n    4   ACTIVE      org.eclipse.equinox.console_1.1.0.v20140131-1639  \n    5   ACTIVE      org.apache.felix.gogo.shell_0.10.0.v201212101605  \n    6   ACTIVE      javax.servlet_3.0.0.v201112011016  \n    7   ACTIVE      org.apache.commons.logging_1.0.4.v201101211617  \n    8   ACTIVE      org.eclipse.equinox.http.servlet_1.1.500.v20140318-1755  \n    9   ACTIVE      org.eclipse.osgi.services_3.4.0.v20140312-2051  \n    10  ACTIVE      org.eclipse.jetty.http_8.1.14.v20131031  \n    11  ACTIVE      org.eclipse.jetty.io_8.1.14.v20131031  \n    12  ACTIVE      org.eclipse.jetty.util_8.1.14.v20131031  \n    13  ACTIVE      org.eclipse.jetty.server_8.1.14.v20131031  \n    14  ACTIVE      org.eclipse.jetty.continuation_8.1.14.v20131031  \n    15  ACTIVE      org.eclipse.jetty.servlet_8.1.14.v20131031  \n    16  ACTIVE      org.eclipse.jetty.security_8.1.14.v20131031  \n    17  ACTIVE      org.eclipse.jetty.webapp_8.1.3.v20120522  \n    18  ACTIVE      org.eclipse.jetty.xml_8.1.3.v20120522  \n同时如果是linux下，访问80端口需要权限所以在Run Configurations 中运行配置里面的 Arguments 页签,在 VM arguments 中添加`-Dorg.osgi.service.http.port=8080`\n这样就可以运行了，一般同一版本的osgi不会出现版本问题，就是不用修改版本依赖","slug":"12","published":1,"updated":"2015-08-25T00:33:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cids4qf6h002yoj5uara8ffe9"},{"title":"codeforces content#260 D A Lot of Games","date":"2015-08-25T00:29:53.000Z","_content":"D. A Lot of Games\ntime limit per test 1 second\nmemory limit per test 256 megabytes\ninput standard input\noutput standard output\n\nInput\nThe first line contains two integers, n and k (1≤n≤105; 1≤k≤109).\nEach of the next n lines contains a single non-empty string from the given group. The total length of all strings from the group doesn't exceed 105. Each string of the group consists only of lowercase English letters.\nOutput\nIf the player who moves first wins, print \"First\", otherwise print \"Second\" (without the quotes).\nSample test(s)\ninput\n\n    2 3\n    a\n    b\n\noutput\n\n    First\n\ninput\n\n    3 1\n    a\n    b\n    c\n\noutput\n\n    First\n\ninput\n\n    1 2\n    ab\n\noutput\n\n    Second\n\n\n<!--more-->\n\n\n----------\n题目大意：有两个人在玩一个游戏。首先输入n个字符串，然后这两个人就在一个空的字符串中填字母，填字母的规则是：保证添加字母后的字符串为n个字符串中某个字符串的前缀。二人每次轮流填一个字母，直到某人无法填入字母来满足规则。这个人就输了。然后开始下一局游戏。下一局的先手为上一局输的人。求在第k局的时候，是先手赢还是后手赢（这里说的先手为第一局的先手）。\n若先手赢则输出\"First\"否则输出\"Second\"\n\n在这里，对于先手（这里的先手为本局的先手）来说有四种情况，先手必输、先手必赢、先手可以控制自己的输赢、先手不可控自己的输赢（由后手控制）。\n\n我们用(xx)来表示这四种情况，第一位表示是否可以赢，第二位表示是否可以输。\n\n(01) 对于先手必输，那么下一局他还是先手(因为上一局他输了),然后一直输到k局，先手还是输，则输出\"Second\"。\n(10) 对于先手必赢，那么下一局他为后手，再下一局他又为先手，根据奇偶判断，当为奇数的时候先手赢，为偶数的时候后手赢。\n(11) 对于先手可控输赢，那么他可以使自己前k-1局都输，最后一局赢。\n(00) 对于先手不可控，那么对手可以让他前k-1局一直赢，最后一局输。\n  接下来就要开始思考，怎样来判断这四种情况。\n我们知道，当游戏结束的条件是，无法再往字符串中添加字母，也就是说，这个字符串已经和某个字符串相等了。因为是依次添加，所以只要知道这个字符串的长度的奇偶，就可以判断出先手的输赢。但是前缀可能不止一个串，例如：\nabcde abcedf\n这两个串，当填到abc的时候，就会发生分支，因为两个串的长度差1,所以会造成输赢的差异。当下一个填d的时候，先手赢，但是当c后面填e的时候，后手赢。所以本局游戏的胜负掌握在填第四个字母的人手里，4为偶，所以是后手掌握了输赢，所以用我们的数字表示即为(00)先手不可控输赢。但如果两个字符串的长度一样则会产生(10)或(01)的情况，因为不管选哪个，长度是一样的。\n所以我们需要保存每一次(xx)的情况。\n----------\n\n首先建立一颗字典树。数据结构如下\n\n    struct Trie;  \n    typedef struct Trie *PTrie;  \n    struct Trie{  \n        int info;   //字典值(0~25)  \n        int num;    //下节点数量  \n        PTrie next[M];  //下节点数;  \n        int aut;    //裁决人-下次选择的人  \n        //int val;  //返回值 (00 均不可控、01 输可控 10 赢可控 11 输赢均可控)  \n        Trie(int x, int y){  \n            info = x;  \n            num = 0;  \n            aut = y;  \n            for(int i=0;i<26;i++){  \n                next[i] = NULL;  \n            }  \n        }  \n    };  \n\n这不是一颗正常的字典树，info 值 在本程序里没有用上，不过不影响大局，只是内存多一点。\n首先根据叶子节点的aut值，来判断(xx)为多少，若aut == 1 那么 val = 2 (10)，若 aut == 0 那么 val = 1 (01) 。\n然后沿着字典树向上回溯，若他的上一个节点只有一个分支，那么就不需要判断，继续进行回溯，直到遇到有多个分支的节点。\n当如到有多个分支的节点，每个分支都有一个val值，如果这个节点的裁决人(aut)是先手，那么他便用有这些分支的所有情况，所以用'或'运算来统计该节点的val值，即 val |= next[i]->val\n同理，当该节点的裁决人是后手，那么，先手就无法控制这些情况，但是下属分支的val都一样，那么后手同样无法控制，则代表后手在这个节点的选择权无效，那么先手仍然有控制权，所以为了保证所有的情况都是一样的，进行与运算 val &= next[i]->val\n说的有点不清楚，自己举个例子就明白了。例如：abcde abcee 后手是有选择权的，但是结果最后还是(01)。\n基本上的思路有了，那么就进行回溯的操作。\n\n    int solo(PTrie pt){  \n        if(pt->num == 0){  \n            return pt->aut+1;    //1(01)为输,2(10)为赢  \n        }  \n        int i,va;  \n        if(pt->aut){  \n            va = 3;  \n            for(i=0;i<26;i++){  \n                if(pt->next[i]!=NULL){  \n                    va &= solo(pt->next[i]);  \n                }  \n            }  \n        }else{  \n            va = 0;  \n            for(i=0;i<26;i++){  \n                if(pt->next[i]!=NULL){  \n                    va |= solo(pt->next[i]);  \n                }  \n            }  \n        }  \n        return va;  \n    }  \n\n\n获得最后返回的va  然后根据va的值 转换成二进制 进行判断。\n\n    int x = solo(pt);  \n        //cout<<\"val = \"<<x<<endl;  \n        if(x == 1){  \n            cout<<\"Second\"<<endl;  \n        }else if(x == 3){  \n            cout<<\"First\"<<endl;  \n        }else if(x == 0){  \n            cout<<\"Second\"<<endl;  \n        }else if(k%2){  \n            cout<<\"First\"<<endl;  \n        }else{  \n            cout<<\"Second\"<<endl;  \n        }  \n\n最后贴完整代码，提示：内存可以优化，时间可以降低。因为这个递归进行了许多不必要的操作。\n因为不会用二维数组形式的字典树，只能用数据结构来写了\n\n    ///Time     Memory  \n    ///46 ms    12220 KB  \n    ///codeforces content#260 D A Lot of Games  \n      \n    #include <iostream>  \n    #include <string>  \n    using namespace std;  \n    const int M = 26;  \n    struct Trie;  \n    typedef struct Trie *PTrie;  \n    struct Trie{  \n        int info;   //字典值(0~25)  \n        int num;    //下节点数量  \n        PTrie next[M];  //下节点数;  \n        int aut;    //裁决人-下次选择的人  \n        int val;    //返回值 (00 均不可控一般不存在、01 输可控 10 赢可控 11 输赢均可控)  \n        Trie(int x, int y){  \n            info = x;  \n            num = 0;  \n            aut = y;  \n            for(int i=0;i<26;i++){  \n                next[i] = NULL;  \n            }  \n        }  \n    };  \n    int toi(char c){  \n            return c-'a';  \n    }  \n    PTrie new_t(int num,int aut){  \n        PTrie pt = new Trie(num,aut);  \n    }  \n    void insert(string s,PTrie pt){  \n        int n = s.length();  \n        int i,c;  \n        for(i=0;i<n;i++){  \n            c = toi(s[i]);  \n            if(pt->next[c]!=NULL){  \n                pt = pt->next[c];  \n                continue;  \n            }else{  \n                pt->next[c] = new Trie(c,(i+1)%2);  \n                pt->num++;  \n                pt = pt->next[c];  \n            }  \n        }  \n    }  \n    void output(PTrie pt){  \n        if(pt == NULL)return;  \n        cout<<\"==========\"<<endl;  \n        cout<<\"info= \"<<pt->info<<endl;  \n        cout<<\"num = \"<<pt->num<<endl;  \n        cout<<\"auto= \"<<pt->aut<<endl;  \n        if(pt->num == 0)return;  \n        int i;  \n        for(i=0;i<26;i++){  \n            if(pt->next[i]!=NULL)output(pt->next[i]);  \n        }  \n    }  \n    int solo(PTrie pt){  \n        if(pt->num == 0){  \n            return pt->aut+1;    //1(01)为输,2(10)为赢  \n        }  \n        int i,va;  \n        if(pt->aut){  \n            va = 3;  \n            for(i=0;i<26;i++){  \n                if(pt->next[i]!=NULL){  \n                    va &= solo(pt->next[i]);  \n                }  \n            }  \n        }else{  \n            va = 0;  \n            for(i=0;i<26;i++){  \n                if(pt->next[i]!=NULL){  \n                    va |= solo(pt->next[i]);  \n                }  \n            }  \n        }  \n        return va;  \n    }  \n    void test(){  \n        int y = 3&2;  \n        cout<<\"11&10 = \"<<y<<endl;  \n        y = 2|1;  \n        cout<<\"10|01 = \"<<y<<endl;  \n    }  \n    int main(){  \n        int n;  \n        long k;  \n        cin>>n>>k;  \n        string s;  \n        PTrie pt = new Trie(-1,0);  \n        for (int i = 0; i < n; ++i)  \n        {  \n            cin>>s;  \n            insert(s,pt);  \n        }  \n        //output(pt);  \n        int x = solo(pt);  \n        //cout<<\"val = \"<<x<<endl;  \n        if(x == 1){  \n            cout<<\"Second\"<<endl;  \n        }else if(x == 3){  \n            cout<<\"First\"<<endl;  \n        }else if(x == 0){  \n            cout<<\"Second\"<<endl;  \n        }else if(k%2){  \n            cout<<\"First\"<<endl;  \n        }else{  \n            cout<<\"Second\"<<endl;  \n        }  \n        return 0;  \n    }  \n\n","source":"_posts/11.md","raw":"title: codeforces content#260 D A Lot of Games\ncategories: 编程与算法\ndate: 2015-08-25 08:29:53\ntags: [codeforces,cf,trie]\n---\nD. A Lot of Games\ntime limit per test 1 second\nmemory limit per test 256 megabytes\ninput standard input\noutput standard output\n\nInput\nThe first line contains two integers, n and k (1≤n≤105; 1≤k≤109).\nEach of the next n lines contains a single non-empty string from the given group. The total length of all strings from the group doesn't exceed 105. Each string of the group consists only of lowercase English letters.\nOutput\nIf the player who moves first wins, print \"First\", otherwise print \"Second\" (without the quotes).\nSample test(s)\ninput\n\n    2 3\n    a\n    b\n\noutput\n\n    First\n\ninput\n\n    3 1\n    a\n    b\n    c\n\noutput\n\n    First\n\ninput\n\n    1 2\n    ab\n\noutput\n\n    Second\n\n\n<!--more-->\n\n\n----------\n题目大意：有两个人在玩一个游戏。首先输入n个字符串，然后这两个人就在一个空的字符串中填字母，填字母的规则是：保证添加字母后的字符串为n个字符串中某个字符串的前缀。二人每次轮流填一个字母，直到某人无法填入字母来满足规则。这个人就输了。然后开始下一局游戏。下一局的先手为上一局输的人。求在第k局的时候，是先手赢还是后手赢（这里说的先手为第一局的先手）。\n若先手赢则输出\"First\"否则输出\"Second\"\n\n在这里，对于先手（这里的先手为本局的先手）来说有四种情况，先手必输、先手必赢、先手可以控制自己的输赢、先手不可控自己的输赢（由后手控制）。\n\n我们用(xx)来表示这四种情况，第一位表示是否可以赢，第二位表示是否可以输。\n\n(01) 对于先手必输，那么下一局他还是先手(因为上一局他输了),然后一直输到k局，先手还是输，则输出\"Second\"。\n(10) 对于先手必赢，那么下一局他为后手，再下一局他又为先手，根据奇偶判断，当为奇数的时候先手赢，为偶数的时候后手赢。\n(11) 对于先手可控输赢，那么他可以使自己前k-1局都输，最后一局赢。\n(00) 对于先手不可控，那么对手可以让他前k-1局一直赢，最后一局输。\n  接下来就要开始思考，怎样来判断这四种情况。\n我们知道，当游戏结束的条件是，无法再往字符串中添加字母，也就是说，这个字符串已经和某个字符串相等了。因为是依次添加，所以只要知道这个字符串的长度的奇偶，就可以判断出先手的输赢。但是前缀可能不止一个串，例如：\nabcde abcedf\n这两个串，当填到abc的时候，就会发生分支，因为两个串的长度差1,所以会造成输赢的差异。当下一个填d的时候，先手赢，但是当c后面填e的时候，后手赢。所以本局游戏的胜负掌握在填第四个字母的人手里，4为偶，所以是后手掌握了输赢，所以用我们的数字表示即为(00)先手不可控输赢。但如果两个字符串的长度一样则会产生(10)或(01)的情况，因为不管选哪个，长度是一样的。\n所以我们需要保存每一次(xx)的情况。\n----------\n\n首先建立一颗字典树。数据结构如下\n\n    struct Trie;  \n    typedef struct Trie *PTrie;  \n    struct Trie{  \n        int info;   //字典值(0~25)  \n        int num;    //下节点数量  \n        PTrie next[M];  //下节点数;  \n        int aut;    //裁决人-下次选择的人  \n        //int val;  //返回值 (00 均不可控、01 输可控 10 赢可控 11 输赢均可控)  \n        Trie(int x, int y){  \n            info = x;  \n            num = 0;  \n            aut = y;  \n            for(int i=0;i<26;i++){  \n                next[i] = NULL;  \n            }  \n        }  \n    };  \n\n这不是一颗正常的字典树，info 值 在本程序里没有用上，不过不影响大局，只是内存多一点。\n首先根据叶子节点的aut值，来判断(xx)为多少，若aut == 1 那么 val = 2 (10)，若 aut == 0 那么 val = 1 (01) 。\n然后沿着字典树向上回溯，若他的上一个节点只有一个分支，那么就不需要判断，继续进行回溯，直到遇到有多个分支的节点。\n当如到有多个分支的节点，每个分支都有一个val值，如果这个节点的裁决人(aut)是先手，那么他便用有这些分支的所有情况，所以用'或'运算来统计该节点的val值，即 val |= next[i]->val\n同理，当该节点的裁决人是后手，那么，先手就无法控制这些情况，但是下属分支的val都一样，那么后手同样无法控制，则代表后手在这个节点的选择权无效，那么先手仍然有控制权，所以为了保证所有的情况都是一样的，进行与运算 val &= next[i]->val\n说的有点不清楚，自己举个例子就明白了。例如：abcde abcee 后手是有选择权的，但是结果最后还是(01)。\n基本上的思路有了，那么就进行回溯的操作。\n\n    int solo(PTrie pt){  \n        if(pt->num == 0){  \n            return pt->aut+1;    //1(01)为输,2(10)为赢  \n        }  \n        int i,va;  \n        if(pt->aut){  \n            va = 3;  \n            for(i=0;i<26;i++){  \n                if(pt->next[i]!=NULL){  \n                    va &= solo(pt->next[i]);  \n                }  \n            }  \n        }else{  \n            va = 0;  \n            for(i=0;i<26;i++){  \n                if(pt->next[i]!=NULL){  \n                    va |= solo(pt->next[i]);  \n                }  \n            }  \n        }  \n        return va;  \n    }  \n\n\n获得最后返回的va  然后根据va的值 转换成二进制 进行判断。\n\n    int x = solo(pt);  \n        //cout<<\"val = \"<<x<<endl;  \n        if(x == 1){  \n            cout<<\"Second\"<<endl;  \n        }else if(x == 3){  \n            cout<<\"First\"<<endl;  \n        }else if(x == 0){  \n            cout<<\"Second\"<<endl;  \n        }else if(k%2){  \n            cout<<\"First\"<<endl;  \n        }else{  \n            cout<<\"Second\"<<endl;  \n        }  \n\n最后贴完整代码，提示：内存可以优化，时间可以降低。因为这个递归进行了许多不必要的操作。\n因为不会用二维数组形式的字典树，只能用数据结构来写了\n\n    ///Time     Memory  \n    ///46 ms    12220 KB  \n    ///codeforces content#260 D A Lot of Games  \n      \n    #include <iostream>  \n    #include <string>  \n    using namespace std;  \n    const int M = 26;  \n    struct Trie;  \n    typedef struct Trie *PTrie;  \n    struct Trie{  \n        int info;   //字典值(0~25)  \n        int num;    //下节点数量  \n        PTrie next[M];  //下节点数;  \n        int aut;    //裁决人-下次选择的人  \n        int val;    //返回值 (00 均不可控一般不存在、01 输可控 10 赢可控 11 输赢均可控)  \n        Trie(int x, int y){  \n            info = x;  \n            num = 0;  \n            aut = y;  \n            for(int i=0;i<26;i++){  \n                next[i] = NULL;  \n            }  \n        }  \n    };  \n    int toi(char c){  \n            return c-'a';  \n    }  \n    PTrie new_t(int num,int aut){  \n        PTrie pt = new Trie(num,aut);  \n    }  \n    void insert(string s,PTrie pt){  \n        int n = s.length();  \n        int i,c;  \n        for(i=0;i<n;i++){  \n            c = toi(s[i]);  \n            if(pt->next[c]!=NULL){  \n                pt = pt->next[c];  \n                continue;  \n            }else{  \n                pt->next[c] = new Trie(c,(i+1)%2);  \n                pt->num++;  \n                pt = pt->next[c];  \n            }  \n        }  \n    }  \n    void output(PTrie pt){  \n        if(pt == NULL)return;  \n        cout<<\"==========\"<<endl;  \n        cout<<\"info= \"<<pt->info<<endl;  \n        cout<<\"num = \"<<pt->num<<endl;  \n        cout<<\"auto= \"<<pt->aut<<endl;  \n        if(pt->num == 0)return;  \n        int i;  \n        for(i=0;i<26;i++){  \n            if(pt->next[i]!=NULL)output(pt->next[i]);  \n        }  \n    }  \n    int solo(PTrie pt){  \n        if(pt->num == 0){  \n            return pt->aut+1;    //1(01)为输,2(10)为赢  \n        }  \n        int i,va;  \n        if(pt->aut){  \n            va = 3;  \n            for(i=0;i<26;i++){  \n                if(pt->next[i]!=NULL){  \n                    va &= solo(pt->next[i]);  \n                }  \n            }  \n        }else{  \n            va = 0;  \n            for(i=0;i<26;i++){  \n                if(pt->next[i]!=NULL){  \n                    va |= solo(pt->next[i]);  \n                }  \n            }  \n        }  \n        return va;  \n    }  \n    void test(){  \n        int y = 3&2;  \n        cout<<\"11&10 = \"<<y<<endl;  \n        y = 2|1;  \n        cout<<\"10|01 = \"<<y<<endl;  \n    }  \n    int main(){  \n        int n;  \n        long k;  \n        cin>>n>>k;  \n        string s;  \n        PTrie pt = new Trie(-1,0);  \n        for (int i = 0; i < n; ++i)  \n        {  \n            cin>>s;  \n            insert(s,pt);  \n        }  \n        //output(pt);  \n        int x = solo(pt);  \n        //cout<<\"val = \"<<x<<endl;  \n        if(x == 1){  \n            cout<<\"Second\"<<endl;  \n        }else if(x == 3){  \n            cout<<\"First\"<<endl;  \n        }else if(x == 0){  \n            cout<<\"Second\"<<endl;  \n        }else if(k%2){  \n            cout<<\"First\"<<endl;  \n        }else{  \n            cout<<\"Second\"<<endl;  \n        }  \n        return 0;  \n    }  \n\n","slug":"11","published":1,"updated":"2015-08-25T00:30:57.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cids4qf6k0032oj5u08gm5yy9"},{"title":"Trie树 hihoCoder","date":"2015-08-25T00:28:52.000Z","_content":"时间限制:10000ms\n单点时限:1000ms\n内存限制:256MB\n描述\n小Hi和小Ho是一对好朋友，出生在信息化社会的他们对编程产生了莫大的兴趣，他们约定好互相帮助，在编程的学习道路上一同前进。\n\n这一天，他们遇到了一本词典，于是小Hi就向小Ho提出了那个经典的问题：“小Ho，你能不能对于每一个我给出的字符串，都在这个词典里面找到以这个字符串开头的所有单词呢？”\n\n身经百战的小Ho答道：“怎么会不能呢！你每给我一个字符串，我就依次遍历词典里的所有单词，检查你给我的字符串是不是这个单词的前缀不就是了？”\n\n小Hi笑道：“你啊，还是太年轻了！~假设这本词典里有10万个单词，我询问你一万次，你得要算到哪年哪月去？”\n\n小Ho低头算了一算，看着那一堆堆的0，顿时感觉自己这辈子都要花在上面了...\n\n小Hi看着小Ho的囧样，也是继续笑道：“让我来提高一下你的知识水平吧~你知道树这样一种数据结构么？”\n\n小Ho想了想，说道：“知道~它是一种基础的数据结构，就像这里说的一样！”\n\n小Hi满意的点了点头，说道：“那你知道我怎么样用一棵树来表示整个词典么？”\n\n小Ho摇摇头表示自己不清楚。\n\n“你看，我们现在得到了这样一棵树，那么你看，如果我给你一个字符串ap，你要怎么找到所有以ap开头的单词呢？”小Hi又开始考校小Ho。\n\n“唔...一个个遍历所有的单词？”小Ho还是不忘自己最开始提出来的算法。\n\n“笨！这棵树难道就白构建了！”小Hi教训完小Ho，继续道：“看好了！”\n\n“那么现在！赶紧去用代码实现吧！”小Hi如是说道\n\n\n<!--more-->\n\n\n输入\n输入的第一行为一个正整数n，表示词典的大小，其后n行，每一行一个单词（不保证是英文单词，也有可能是火星文单词哦），单词由不超过10个的小写英文字母组成，可能存在相同的单词，此时应将其视作不同的单词。接下来的一行为一个正整数m，表示小Hi询问的次数，其后m行，每一行一个字符串，该字符串由不超过10个的小写英文字母组成，表示小Hi的一个询问。\n\n在20%的数据中n, m<=10，词典的字母表大小<=2.\n\n在60%的数据中n, m<=1000，词典的字母表大小<=5.\n\n在100%的数据中n, m<=100000，词典的字母表大小<=26.\n\n输出\n对于小Hi的每一个询问，输出一个整数Ans,表示词典中以小Hi给出的字符串为前缀的单词的个数。\n\n样例输入\n```\n5\nbabaab\nbabbbaaaa\nabba\naaaaabaa\nbabaababb\n5\nbabb\nbaabaaa\nbab\nbb\nbbabbaab\n```\n样例输出\n```\n1\n0\n3\n0\n0\n```\n\n\n----------\n建立一个自定义结构体\n```cpp\nstruct Tree;  \ntypedef struct Tree *PTree;   \nstruct Tree{  \n        char let;   //该结构体代表低字母  \n        int count;//经过该结点的单词数  \n        PTree next[MAX];//指向子结构  \n};  \n```\nlet貌似没有用上 不过没有关系 \n执行find函数后 查找到最后一个字母然后返回该结点低count即为结果\n```cpp\n#include <iostream>  \n#include <string>  \nusing namespace std;  \nconst int MAX=26;  \nstruct Tree;  \ntypedef struct Tree *PTree;   \nstruct Tree{  \n        char let;  \n        int count;  \n        PTree next[MAX];  \n};  \nPTree root[MAX];  \nvoid init(){  \n    for(int i=0;i<MAX;i++){  \n            root[i] = new Tree();  \n            root[i]->let = i+'a';  \n            root[i]->count = 0;  \n            for(int j=0;j<MAX;j++){  \n                    root[i]->next[j] = NULL;  \n            }  \n    }  \n      \n    }  \nvoid linkTree(PTree par,char let ){  \n        PTree t = new Tree();  \n        int n = let-'a';  \n        t->let = let;  \n        t->count = 0;  \n        for(int i=0;i<MAX;i++){  \n                t->next[i] = NULL;  \n        }  \n        par->next[n] = t;  \n}  \nvoid buildTree(string str){  \n        int n = str.length();  \n        int st = str[0]-'a';  \n        PTree p = root[st];  \n        p->count++;  \n        for(int i=1;i<n;i++){  \n                int num = str[i] - 'a';  \n                if(p->next[num] == NULL){  \n                        linkTree(p,str[i]);  \n                }  \n                p = p->next[num];  \n                p->count++;  \n        }  \n}  \nint find(string str){  \n        int n = str.length();  \n        int st = str[0]-'a';  \n        if(root[st] == NULL)return 0;  \n        PTree p = root[st];  \n        for(int i=1;i<n;i++){  \n                int x = str[i]-'a';  \n                if(p->next[x]!=NULL){  \n                        p = p->next[x];  \n                }else{  \n                        return 0;  \n                }  \n              \n        }  \n        return p->count;  \n}  \nint main(){  \n        int i,n;  \n        string s;  \n        init();  \n        cin>>n;  \n        for(i=0;i<n;i++){  \n            cin>>s;  \n            buildTree(s);  \n        }  \n        cin>>n;  \n        for(i=0;i<n;i++){  \n            cin>>s;  \n            cout<<find(s)<<endl;  \n        }  \n        return 0;  \n}  \n```","source":"_posts/10.md","raw":"title: Trie树 hihoCoder\ncategories: 编程与算法\ndate: 2015-08-25 08:28:52\ntags: [trie,acm,hihocoder]\n---\n时间限制:10000ms\n单点时限:1000ms\n内存限制:256MB\n描述\n小Hi和小Ho是一对好朋友，出生在信息化社会的他们对编程产生了莫大的兴趣，他们约定好互相帮助，在编程的学习道路上一同前进。\n\n这一天，他们遇到了一本词典，于是小Hi就向小Ho提出了那个经典的问题：“小Ho，你能不能对于每一个我给出的字符串，都在这个词典里面找到以这个字符串开头的所有单词呢？”\n\n身经百战的小Ho答道：“怎么会不能呢！你每给我一个字符串，我就依次遍历词典里的所有单词，检查你给我的字符串是不是这个单词的前缀不就是了？”\n\n小Hi笑道：“你啊，还是太年轻了！~假设这本词典里有10万个单词，我询问你一万次，你得要算到哪年哪月去？”\n\n小Ho低头算了一算，看着那一堆堆的0，顿时感觉自己这辈子都要花在上面了...\n\n小Hi看着小Ho的囧样，也是继续笑道：“让我来提高一下你的知识水平吧~你知道树这样一种数据结构么？”\n\n小Ho想了想，说道：“知道~它是一种基础的数据结构，就像这里说的一样！”\n\n小Hi满意的点了点头，说道：“那你知道我怎么样用一棵树来表示整个词典么？”\n\n小Ho摇摇头表示自己不清楚。\n\n“你看，我们现在得到了这样一棵树，那么你看，如果我给你一个字符串ap，你要怎么找到所有以ap开头的单词呢？”小Hi又开始考校小Ho。\n\n“唔...一个个遍历所有的单词？”小Ho还是不忘自己最开始提出来的算法。\n\n“笨！这棵树难道就白构建了！”小Hi教训完小Ho，继续道：“看好了！”\n\n“那么现在！赶紧去用代码实现吧！”小Hi如是说道\n\n\n<!--more-->\n\n\n输入\n输入的第一行为一个正整数n，表示词典的大小，其后n行，每一行一个单词（不保证是英文单词，也有可能是火星文单词哦），单词由不超过10个的小写英文字母组成，可能存在相同的单词，此时应将其视作不同的单词。接下来的一行为一个正整数m，表示小Hi询问的次数，其后m行，每一行一个字符串，该字符串由不超过10个的小写英文字母组成，表示小Hi的一个询问。\n\n在20%的数据中n, m<=10，词典的字母表大小<=2.\n\n在60%的数据中n, m<=1000，词典的字母表大小<=5.\n\n在100%的数据中n, m<=100000，词典的字母表大小<=26.\n\n输出\n对于小Hi的每一个询问，输出一个整数Ans,表示词典中以小Hi给出的字符串为前缀的单词的个数。\n\n样例输入\n```\n5\nbabaab\nbabbbaaaa\nabba\naaaaabaa\nbabaababb\n5\nbabb\nbaabaaa\nbab\nbb\nbbabbaab\n```\n样例输出\n```\n1\n0\n3\n0\n0\n```\n\n\n----------\n建立一个自定义结构体\n```cpp\nstruct Tree;  \ntypedef struct Tree *PTree;   \nstruct Tree{  \n        char let;   //该结构体代表低字母  \n        int count;//经过该结点的单词数  \n        PTree next[MAX];//指向子结构  \n};  \n```\nlet貌似没有用上 不过没有关系 \n执行find函数后 查找到最后一个字母然后返回该结点低count即为结果\n```cpp\n#include <iostream>  \n#include <string>  \nusing namespace std;  \nconst int MAX=26;  \nstruct Tree;  \ntypedef struct Tree *PTree;   \nstruct Tree{  \n        char let;  \n        int count;  \n        PTree next[MAX];  \n};  \nPTree root[MAX];  \nvoid init(){  \n    for(int i=0;i<MAX;i++){  \n            root[i] = new Tree();  \n            root[i]->let = i+'a';  \n            root[i]->count = 0;  \n            for(int j=0;j<MAX;j++){  \n                    root[i]->next[j] = NULL;  \n            }  \n    }  \n      \n    }  \nvoid linkTree(PTree par,char let ){  \n        PTree t = new Tree();  \n        int n = let-'a';  \n        t->let = let;  \n        t->count = 0;  \n        for(int i=0;i<MAX;i++){  \n                t->next[i] = NULL;  \n        }  \n        par->next[n] = t;  \n}  \nvoid buildTree(string str){  \n        int n = str.length();  \n        int st = str[0]-'a';  \n        PTree p = root[st];  \n        p->count++;  \n        for(int i=1;i<n;i++){  \n                int num = str[i] - 'a';  \n                if(p->next[num] == NULL){  \n                        linkTree(p,str[i]);  \n                }  \n                p = p->next[num];  \n                p->count++;  \n        }  \n}  \nint find(string str){  \n        int n = str.length();  \n        int st = str[0]-'a';  \n        if(root[st] == NULL)return 0;  \n        PTree p = root[st];  \n        for(int i=1;i<n;i++){  \n                int x = str[i]-'a';  \n                if(p->next[x]!=NULL){  \n                        p = p->next[x];  \n                }else{  \n                        return 0;  \n                }  \n              \n        }  \n        return p->count;  \n}  \nint main(){  \n        int i,n;  \n        string s;  \n        init();  \n        cin>>n;  \n        for(i=0;i<n;i++){  \n            cin>>s;  \n            buildTree(s);  \n        }  \n        cin>>n;  \n        for(i=0;i<n;i++){  \n            cin>>s;  \n            cout<<find(s)<<endl;  \n        }  \n        return 0;  \n}  \n```","slug":"10","published":1,"updated":"2015-08-25T00:29:21.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cids4qf6n003aoj5upglucylm"}],"PostAsset":[],"PostCategory":[{"post_id":"cids4qf2p0000oj5uh8l0btmg","category_id":"cids4qf2t0001oj5uirou0yn9","_id":"cids4qf2v0004oj5uq31j1qpw"},{"post_id":"cids4qf3r0007oj5us3dyj23g","category_id":"cids4qf2t0001oj5uirou0yn9","_id":"cids4qf3s0008oj5ubqr2c7ob"},{"post_id":"cids4qf3u000doj5u787jvddr","category_id":"cids4qf3v000eoj5ul5muqjtu","_id":"cids4qf3v000hoj5ulehvblit"},{"post_id":"cids4qf3w000koj5uv7ajnnmx","category_id":"cids4qf2t0001oj5uirou0yn9","_id":"cids4qf3x000loj5unvxyx4m5"},{"post_id":"cids4qf40000poj5uppsz5wz4","category_id":"cids4qf3v000eoj5ul5muqjtu","_id":"cids4qf40000qoj5ut2rjdexy"},{"post_id":"cids4qf42000uoj5uvntzdgdl","category_id":"cids4qf3v000eoj5ul5muqjtu","_id":"cids4qf43000voj5u6k913ib7"},{"post_id":"cids4qf470011oj5u55fee596","category_id":"cids4qf3v000eoj5ul5muqjtu","_id":"cids4qf480012oj5u5llkdbrs"},{"post_id":"cids4qf4a0016oj5uxang2yl6","category_id":"cids4qf2t0001oj5uirou0yn9","_id":"cids4qf4b0017oj5uk6scscl2"},{"post_id":"cids4qf4c001coj5usjwuz3jc","category_id":"cids4qf3v000eoj5ul5muqjtu","_id":"cids4qf4d001doj5ud37kxhtk"},{"post_id":"cids4qf4h001koj5u0peg7smc","category_id":"cids4qf2t0001oj5uirou0yn9","_id":"cids4qf4j001loj5uikntvga5"},{"post_id":"cids4qf4l001ooj5urbfohrlc","category_id":"cids4qf2t0001oj5uirou0yn9","_id":"cids4qf5h001poj5upfxafmin"},{"post_id":"cids4qf5k001soj5um2ot6sn4","category_id":"cids4qf2t0001oj5uirou0yn9","_id":"cids4qf5m001toj5ud0g9ax0m"},{"post_id":"cids4qf5n001voj5uytt73wrd","category_id":"cids4qf2t0001oj5uirou0yn9","_id":"cids4qf5p001woj5uolh9xro1"},{"post_id":"cids4qf5q001yoj5u1yx9tcox","category_id":"cids4qf2t0001oj5uirou0yn9","_id":"cids4qf5r001zoj5ul9am0wyt"},{"post_id":"cids4qf5s0021oj5ucmbst30q","category_id":"cids4qf2t0001oj5uirou0yn9","_id":"cids4qf5t0022oj5uz9ifi3kc"},{"post_id":"cids4qf5w0024oj5umck4d53v","category_id":"cids4qf2t0001oj5uirou0yn9","_id":"cids4qf5x0025oj5ut32hoi5s"},{"post_id":"cids4qf5z002aoj5uaeq03bbo","category_id":"cids4qf2t0001oj5uirou0yn9","_id":"cids4qf61002boj5uj05b36hz"},{"post_id":"cids4qf64002doj5ul0qtu0nz","category_id":"cids4qf2t0001oj5uirou0yn9","_id":"cids4qf65002eoj5uj6x7xjjp"},{"post_id":"cids4qf66002goj5u32lnenmg","category_id":"cids4qf2t0001oj5uirou0yn9","_id":"cids4qf67002hoj5usl9k12k6"},{"post_id":"cids4qf68002joj5uh4la8wbg","category_id":"cids4qf2t0001oj5uirou0yn9","_id":"cids4qf69002koj5uemcjs9zr"},{"post_id":"cids4qf6a002moj5uiwivdxs7","category_id":"cids4qf2t0001oj5uirou0yn9","_id":"cids4qf6b002noj5uno6etoyt"},{"post_id":"cids4qf6c002poj5utcclaanm","category_id":"cids4qf2t0001oj5uirou0yn9","_id":"cids4qf6e002qoj5uscxu6y10"},{"post_id":"cids4qf6f002soj5uff53n8m5","category_id":"cids4qf2t0001oj5uirou0yn9","_id":"cids4qf6f002toj5updivgk3q"},{"post_id":"cids4qf6h002yoj5uara8ffe9","category_id":"cids4qf2t0001oj5uirou0yn9","_id":"cids4qf6j002zoj5urj4g95gn"},{"post_id":"cids4qf6k0032oj5u08gm5yy9","category_id":"cids4qf2t0001oj5uirou0yn9","_id":"cids4qf6l0033oj5ubum2diem"},{"post_id":"cids4qf6n003aoj5upglucylm","category_id":"cids4qf2t0001oj5uirou0yn9","_id":"cids4qf6o003boj5ulzuf20is"}],"PostTag":[{"post_id":"cids4qf2p0000oj5uh8l0btmg","tag_id":"cids4qf2t0002oj5uany6mui2","_id":"cids4qf2v0005oj5u7o4iy9z5"},{"post_id":"cids4qf2p0000oj5uh8l0btmg","tag_id":"cids4qf2v0003oj5uno4s22bu","_id":"cids4qf2v0006oj5ucysjtdnm"},{"post_id":"cids4qf3r0007oj5us3dyj23g","tag_id":"cids4qf3s0009oj5u3ffd6sk1","_id":"cids4qf3t000boj5urja32p2b"},{"post_id":"cids4qf3r0007oj5us3dyj23g","tag_id":"cids4qf3s000aoj5u9jthghwu","_id":"cids4qf3t000coj5ukctqjq14"},{"post_id":"cids4qf3u000doj5u787jvddr","tag_id":"cids4qf3v000foj5ucyp72zy0","_id":"cids4qf3v000ioj5u8hooypau"},{"post_id":"cids4qf3u000doj5u787jvddr","tag_id":"cids4qf3v000goj5u827uoyu0","_id":"cids4qf3v000joj5u6cd10eq9"},{"post_id":"cids4qf3w000koj5uv7ajnnmx","tag_id":"cids4qf3y000moj5u6pgdfvq0","_id":"cids4qf3y000noj5u40lao9ep"},{"post_id":"cids4qf3w000koj5uv7ajnnmx","tag_id":"cids4qf3s0009oj5u3ffd6sk1","_id":"cids4qf3z000ooj5ud9cm1r37"},{"post_id":"cids4qf40000poj5uppsz5wz4","tag_id":"cids4qf3v000foj5ucyp72zy0","_id":"cids4qf41000soj5us5fm6onp"},{"post_id":"cids4qf40000poj5uppsz5wz4","tag_id":"cids4qf41000roj5ui6nsxeww","_id":"cids4qf41000toj5u3yttnbr9"},{"post_id":"cids4qf42000uoj5uvntzdgdl","tag_id":"cids4qf3v000foj5ucyp72zy0","_id":"cids4qf44000yoj5uu61d68nh"},{"post_id":"cids4qf42000uoj5uvntzdgdl","tag_id":"cids4qf44000woj5uyv5x0nc1","_id":"cids4qf44000zoj5ue6dhc37s"},{"post_id":"cids4qf42000uoj5uvntzdgdl","tag_id":"cids4qf44000xoj5uik0rm7s1","_id":"cids4qf460010oj5ul5tz60ri"},{"post_id":"cids4qf470011oj5u55fee596","tag_id":"cids4qf490013oj5uc78cp03g","_id":"cids4qf490014oj5uby3mdwzk"},{"post_id":"cids4qf470011oj5u55fee596","tag_id":"cids4qf3v000foj5ucyp72zy0","_id":"cids4qf490015oj5uac82e4kw"},{"post_id":"cids4qf4a0016oj5uxang2yl6","tag_id":"cids4qf4b0018oj5ubjap83hw","_id":"cids4qf4b001aoj5uuxpninuf"},{"post_id":"cids4qf4a0016oj5uxang2yl6","tag_id":"cids4qf4b0019oj5u46y9u52o","_id":"cids4qf4b001boj5u807ntf58"},{"post_id":"cids4qf4c001coj5usjwuz3jc","tag_id":"cids4qf4d001eoj5urwoe8yu4","_id":"cids4qf4f001hoj5ulhdnoxl9"},{"post_id":"cids4qf4c001coj5usjwuz3jc","tag_id":"cids4qf4e001foj5ubgrp7zh3","_id":"cids4qf4f001ioj5uuqe2vcql"},{"post_id":"cids4qf4c001coj5usjwuz3jc","tag_id":"cids4qf4e001goj5ul1cxtgle","_id":"cids4qf4f001joj5u0e69wkp9"},{"post_id":"cids4qf4h001koj5u0peg7smc","tag_id":"cids4qf4b0018oj5ubjap83hw","_id":"cids4qf4j001moj5ugbu821ix"},{"post_id":"cids4qf4h001koj5u0peg7smc","tag_id":"cids4qf44000xoj5uik0rm7s1","_id":"cids4qf4j001noj5ul1fnlx07"},{"post_id":"cids4qf4l001ooj5urbfohrlc","tag_id":"cids4qf4b0018oj5ubjap83hw","_id":"cids4qf5i001qoj5uo8liq1oz"},{"post_id":"cids4qf4l001ooj5urbfohrlc","tag_id":"cids4qf44000xoj5uik0rm7s1","_id":"cids4qf5i001roj5u6us1anpp"},{"post_id":"cids4qf5k001soj5um2ot6sn4","tag_id":"cids4qf4b0018oj5ubjap83hw","_id":"cids4qf5m001uoj5umzdmj1kj"},{"post_id":"cids4qf5n001voj5uytt73wrd","tag_id":"cids4qf4b0018oj5ubjap83hw","_id":"cids4qf5p001xoj5ut8wtkxh5"},{"post_id":"cids4qf5q001yoj5u1yx9tcox","tag_id":"cids4qf4b0018oj5ubjap83hw","_id":"cids4qf5r0020oj5ujndo76zh"},{"post_id":"cids4qf5s0021oj5ucmbst30q","tag_id":"cids4qf4b0018oj5ubjap83hw","_id":"cids4qf5t0023oj5ublc3p8b9"},{"post_id":"cids4qf5w0024oj5umck4d53v","tag_id":"cids4qf5y0026oj5u0f7wbr60","_id":"cids4qf5y0028oj5umckjs1ah"},{"post_id":"cids4qf5w0024oj5umck4d53v","tag_id":"cids4qf5y0027oj5uvx4f3j4e","_id":"cids4qf5y0029oj5us34c68b4"},{"post_id":"cids4qf5z002aoj5uaeq03bbo","tag_id":"cids4qf4b0018oj5ubjap83hw","_id":"cids4qf62002coj5umpypqyjw"},{"post_id":"cids4qf64002doj5ul0qtu0nz","tag_id":"cids4qf4b0018oj5ubjap83hw","_id":"cids4qf65002foj5uit7fytpe"},{"post_id":"cids4qf66002goj5u32lnenmg","tag_id":"cids4qf4b0018oj5ubjap83hw","_id":"cids4qf68002ioj5ufuahx846"},{"post_id":"cids4qf68002joj5uh4la8wbg","tag_id":"cids4qf4b0018oj5ubjap83hw","_id":"cids4qf69002loj5um14r93b4"},{"post_id":"cids4qf6a002moj5uiwivdxs7","tag_id":"cids4qf4b0018oj5ubjap83hw","_id":"cids4qf6b002ooj5uwp1712zq"},{"post_id":"cids4qf6c002poj5utcclaanm","tag_id":"cids4qf4b0018oj5ubjap83hw","_id":"cids4qf6e002roj5uhejid0q2"},{"post_id":"cids4qf6f002soj5uff53n8m5","tag_id":"cids4qf6f002uoj5umllm8d8z","_id":"cids4qf6g002woj5u05b5xlxg"},{"post_id":"cids4qf6f002soj5uff53n8m5","tag_id":"cids4qf6g002voj5usv3czyi3","_id":"cids4qf6g002xoj5uo4racp5z"},{"post_id":"cids4qf6h002yoj5uara8ffe9","tag_id":"cids4qf6j0030oj5ur0hptyso","_id":"cids4qf6j0031oj5uvrb8my95"},{"post_id":"cids4qf6k0032oj5u08gm5yy9","tag_id":"cids4qf6l0034oj5u0ydi04h2","_id":"cids4qf6m0037oj5u9ccbvm05"},{"post_id":"cids4qf6k0032oj5u08gm5yy9","tag_id":"cids4qf6l0035oj5uo8bx2m1q","_id":"cids4qf6m0038oj5ujkwo2m0r"},{"post_id":"cids4qf6k0032oj5u08gm5yy9","tag_id":"cids4qf6m0036oj5uxbbpm1rn","_id":"cids4qf6m0039oj5uze80088u"},{"post_id":"cids4qf6n003aoj5upglucylm","tag_id":"cids4qf6m0036oj5uxbbpm1rn","_id":"cids4qf6o003doj5unhfcl4nu"},{"post_id":"cids4qf6n003aoj5upglucylm","tag_id":"cids4qf3y000moj5u6pgdfvq0","_id":"cids4qf6o003eoj5unygiq9hl"},{"post_id":"cids4qf6n003aoj5upglucylm","tag_id":"cids4qf6o003coj5uh7johaog","_id":"cids4qf6p003foj5uk1rqdoct"}],"Tag":[{"name":"asm","_id":"cids4qf2t0002oj5uany6mui2"},{"name":"课后练习","_id":"cids4qf2v0003oj5uno4s22bu"},{"name":"poj","_id":"cids4qf3s0009oj5u3ffd6sk1"},{"name":"uniun","_id":"cids4qf3s000aoj5u9jthghwu"},{"name":"ubuntu","_id":"cids4qf3v000foj5ucyp72zy0"},{"name":"vpn","_id":"cids4qf3v000goj5u827uoyu0"},{"name":"acm","_id":"cids4qf3y000moj5u6pgdfvq0"},{"name":"software","_id":"cids4qf41000roj5ui6nsxeww"},{"name":"shadowsocks","_id":"cids4qf44000woj5uyv5x0nc1"},{"name":"ss","_id":"cids4qf44000xoj5uik0rm7s1"},{"name":"Android","_id":"cids4qf490013oj5uc78cp03g"},{"name":"python","_id":"cids4qf4b0018oj5ubjap83hw"},{"name":"编程","_id":"cids4qf4b0019oj5u46y9u52o"},{"name":"hexo","_id":"cids4qf4d001eoj5urwoe8yu4"},{"name":"github","_id":"cids4qf4e001foj5ubgrp7zh3"},{"name":"blog","_id":"cids4qf4e001goj5ul1cxtgle"},{"name":"ACM","_id":"cids4qf5y0026oj5u0f7wbr60"},{"name":"区域赛","_id":"cids4qf5y0027oj5uvx4f3j4e"},{"name":"QT","_id":"cids4qf6f002uoj5umllm8d8z"},{"name":"VS","_id":"cids4qf6g002voj5usv3czyi3"},{"name":"osgi","_id":"cids4qf6j0030oj5ur0hptyso"},{"name":"codeforces","_id":"cids4qf6l0034oj5u0ydi04h2"},{"name":"cf","_id":"cids4qf6l0035oj5uo8bx2m1q"},{"name":"trie","_id":"cids4qf6m0036oj5uxbbpm1rn"},{"name":"hihocoder","_id":"cids4qf6o003coj5uh7johaog"}]}}