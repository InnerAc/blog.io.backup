{"meta":{"version":1,"warehouse":"1.0.2"},"models":{"Asset":[{"_id":"themes/yilia/source/js/pc.js","path":"js/pc.js","modified":1},{"_id":"themes/yilia/source/js/mobile.js","path":"js/mobile.js","modified":1},{"_id":"themes/yilia/source/js/main.js","path":"js/main.js","modified":1},{"_id":"themes/yilia/source/js/jquery.lazyload.js","path":"js/jquery.lazyload.js","modified":1},{"_id":"themes/yilia/source/js/instagram.js","path":"js/instagram.js","modified":1},{"_id":"themes/yilia/source/img/zhihu.png","path":"img/zhihu.png","modified":1},{"_id":"themes/yilia/source/img/weibo.png","path":"img/weibo.png","modified":1},{"_id":"themes/yilia/source/img/twitter.png","path":"img/twitter.png","modified":1},{"_id":"themes/yilia/source/img/stackoverflow.png","path":"img/stackoverflow.png","modified":1},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","path":"img/scrollbar_arrow.png","modified":1},{"_id":"themes/yilia/source/img/rss.png","path":"img/rss.png","modified":1},{"_id":"themes/yilia/source/img/pinterest.png","path":"img/pinterest.png","modified":1},{"_id":"themes/yilia/source/img/pinboard.png","path":"img/pinboard.png","modified":1},{"_id":"themes/yilia/source/img/mail.png","path":"img/mail.png","modified":1},{"_id":"themes/yilia/source/img/linkedin.png","path":"img/linkedin.png","modified":1},{"_id":"themes/yilia/source/img/img-loading.png","path":"img/img-loading.png","modified":1},{"_id":"themes/yilia/source/img/img-err.png","path":"img/img-err.png","modified":1},{"_id":"themes/yilia/source/img/google.png","path":"img/google.png","modified":1},{"_id":"themes/yilia/source/img/github.png","path":"img/github.png","modified":1},{"_id":"themes/yilia/source/img/facebook.png","path":"img/facebook.png","modified":1},{"_id":"themes/yilia/source/img/douban.png","path":"img/douban.png","modified":1},{"_id":"themes/yilia/source/img/delicious.png","path":"img/delicious.png","modified":1},{"_id":"themes/yilia/source/img/coderwall.png","path":"img/coderwall.png","modified":1},{"_id":"themes/yilia/source/favicon.png","path":"favicon.png","modified":1},{"_id":"themes/yilia/source/favicon.ico","path":"favicon.ico","modified":1},{"_id":"themes/yilia/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":1},{"_id":"themes/yilia/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":1},{"_id":"themes/yilia/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":1},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":1},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":1},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":1},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":1},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":1},{"_id":"themes/yilia/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":1},{"_id":"themes/yilia/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":1},{"_id":"themes/yilia/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":1},{"_id":"themes/yilia/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":1},{"_id":"themes/yilia/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":1},{"_id":"themes/yilia/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":1},{"_id":"themes/yilia/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":1},{"_id":"themes/yilia/source/css/style.styl","path":"css/style.styl","modified":1},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":1},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":1},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.svgz","path":"css/fonts/fontawesome-webfont.svgz","modified":1},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":1},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":1},{"_id":"themes/yilia/source/ava.png","path":"ava.png","modified":1},{"_id":"source/favicon.png","path":"favicon.png","modified":1},{"_id":"source/favicon.ico","path":"favicon.ico","modified":1}],"Cache":[{"_id":"source/_posts/1.md","shasum":"6ef6f8b57eff176229e73cda0690557205cbf1d8","modified":1443751054000},{"_id":"source/_posts/11.md","shasum":"09164aec3e2ba3d15b994c148615fb426736c186","modified":1443751054000},{"_id":"source/_posts/13.md","shasum":"575f440384e6928feabe0ac266295e8774dfc6a2","modified":1443751054000},{"_id":"source/_posts/14.md","shasum":"c9d5279de75e70c44ed563d44151ec664a521147","modified":1443751054000},{"_id":"source/_posts/10.md","shasum":"759dd2a661d30c72258280b705bb39de12205100","modified":1443753665000},{"_id":"source/_posts/12.md","shasum":"7f1adfd4cc4e3d7d15644972a913248f0b4251ef","modified":1443751054000},{"_id":"source/_posts/15.md","shasum":"d2f4697465c6bd2c3be27482d91a893411900cae","modified":1443751054000},{"_id":"source/_posts/16.md","shasum":"aa2db55368bcb6dda180492da70f268d7cd3f4bf","modified":1443751054000},{"_id":"source/_posts/17.md","shasum":"b0fe6f90baba8029eed4b414fc9e72cafee8e135","modified":1443751054000},{"_id":"source/_posts/18.md","shasum":"491778c3384bf17f3e642d989a5a85c646b273ce","modified":1443751054000},{"_id":"source/_posts/19.md","shasum":"19981951815594f3c334869c46c56a54eb5d3871","modified":1443751054000},{"_id":"source/_posts/2.md","shasum":"39b3c570095fa3599c166554b12a161488f78c1d","modified":1443751054000},{"_id":"source/_posts/20.md","shasum":"93eb9ab3b31009554164e67aa80512ef19cf8007","modified":1443751054000},{"_id":"source/_posts/21.md","shasum":"f2f50cc041bb45555764b6fefbe1ca31123b8aa2","modified":1443751054000},{"_id":"source/_posts/22.md","shasum":"0a35abaf12d3c1a7a4c2cb5efe12815b1b85d213","modified":1443751054000},{"_id":"source/_posts/23.md","shasum":"c6a80fd696ad51a04f40ba6fdaee02aaec7e51af","modified":1443751054000},{"_id":"source/_posts/24.md","shasum":"c474cf4b5cf3bd99b6349921e9e0c201e98e8836","modified":1443751054000},{"_id":"source/_posts/25.md","shasum":"baf6b370464322b78f149fb9b6b287451c397a76","modified":1443751054000},{"_id":"source/_posts/26.md","shasum":"3d9889bc4076c7c1446475770bc72da2b058aac2","modified":1443751054000},{"_id":"source/_posts/27.md","shasum":"9b0b2e0d41005de81a10aadf50ed81758236e0dd","modified":1443751054000},{"_id":"source/_posts/27.md~","shasum":"9b0b2e0d41005de81a10aadf50ed81758236e0dd","modified":1443751054000},{"_id":"source/_posts/28.md","shasum":"5aa2d305d0611cf5b02fa0f91c4daa5970eab87e","modified":1443751054000},{"_id":"source/_posts/3.md","shasum":"9585aa543c4d777ea6dcc4209e3f15e2480c864d","modified":1443751054000},{"_id":"source/_posts/29.md","shasum":"bbf298c1283cf6cf79818b15a5858e5f1f7e87e6","modified":1443776037000},{"_id":"source/_posts/31.md","shasum":"2ec243eac3d18a363ec89debec625739d8b1ee66","modified":1443777360000},{"_id":"source/_posts/33.md","shasum":"aecf26c389a95bc38301c0644dfedc1132bbad60","modified":1443949225000},{"_id":"source/_posts/4.md","shasum":"e1ce386353a887e65ac605d24d1cffa418a9450b","modified":1443751054000},{"_id":"source/_posts/5.md","shasum":"aadf7fd96a6e9c7c38a121c9d0301922e6b0ebd0","modified":1443751054000},{"_id":"source/_posts/6.md","shasum":"5a0d70324858592a132b427201cbcb4b0c01f882","modified":1443751054000},{"_id":"source/_posts/7.md","shasum":"617d2a168db056edfd03031e20eae2a4209d561a","modified":1443751054000},{"_id":"source/_posts/30.md","shasum":"c8474feb59a5a507c0e8417bff47d937fb2e7870","modified":1443780447000},{"_id":"source/_posts/8.md","shasum":"e2e391c5d385df3d58c36ccb02c0851613f45540","modified":1443751054000},{"_id":"source/_posts/9.md","shasum":"31b07a0843dab3866fce194d20724e6b742490cb","modified":1443751054000},{"_id":"source/_posts/34.md","shasum":"b45fddcdf630805b54c65ac2d74b44a8b8f6ac09","modified":1444097163000},{"_id":"source/_posts/32.md","shasum":"bb5df7f87bc1d54f18fc11024a2b0a83fc529419","modified":1443946062000},{"_id":"source/favicon.png","shasum":"9f2b514e6f43dbe8a5d698a4c07fe0e2740a9296","modified":1443751054000},{"_id":"source/favicon.ico","shasum":"7255c8f02a52fd8aa8d54f36fcb8e97314dc9e8b","modified":1443751054000},{"_id":"themes/yilia/README.md","shasum":"8648a81b3ae08a4accd6b0541533e662511e6400","modified":1443751054000},{"_id":"themes/yilia/layout/_partial/after-footer.ejs","shasum":"082504c9fd8600306d4ca55f03e3cbb0ddd99dd7","modified":1443751054000},{"_id":"themes/yilia/layout/_partial/archive-post.ejs","shasum":"8dfb6d68aa8a0661d26c32ce1ce1f45815364c3a","modified":1443751054000},{"_id":"themes/yilia/layout/_partial/archive.ejs","shasum":"a6e94061ac55b9eb55275f87b608d62f6ea35659","modified":1443751054000},{"_id":"themes/yilia/layout/_partial/article.ejs","shasum":"ef8dd558f908f293c34123c0b7ff879d2fd0c09f","modified":1443751054000},{"_id":"themes/yilia/_config.yml","shasum":"b93b1a6f3151043edb4b3c02a10a2cdd006385f8","modified":1444363692000},{"_id":"themes/yilia/layout/_partial/footer.ejs","shasum":"f2994e0acd1d606ebf4680afc4fa652e148ccf4e","modified":1443751054000},{"_id":"themes/yilia/layout/_partial/google-analytics.ejs","shasum":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1443751054000},{"_id":"themes/yilia/layout/_partial/head.ejs","shasum":"963c106412a3ab142871976978ecc9884aeca17a","modified":1443751054000},{"_id":"themes/yilia/layout/_partial/header.ejs","shasum":"6387a93dad7c3d778eb91e3821852fbf6813880c","modified":1443751054000},{"_id":"themes/yilia/layout/_partial/mathjax.ejs","shasum":"54fab4d3d64cb937d6baec7324ffabf9f202b883","modified":1443751054000},{"_id":"themes/yilia/layout/_partial/mobile-nav.ejs","shasum":"cd0af87ee781ac9c2b0e6a2a05b063d4bd497d9c","modified":1443751054000},{"_id":"themes/yilia/layout/_partial/post/category.ejs","shasum":"d4f0e36f9a2167e91082dbd7d52425a06d2bebbf","modified":1443751054000},{"_id":"themes/yilia/layout/_partial/post/date.ejs","shasum":"c0c988334e857a77ba455a056dfa21809e7e76a5","modified":1443751054000},{"_id":"themes/yilia/_config.yml~","shasum":"b93b1a6f3151043edb4b3c02a10a2cdd006385f8","modified":1444363692000},{"_id":"themes/yilia/layout/_partial/left-col.ejs","shasum":"e4f1a2011139257968e98b1fbc5d9d4a6b2cbc8e","modified":1444364527000},{"_id":"themes/yilia/layout/_partial/post/duoshuo.ejs","shasum":"e8399025ed3b980aedb821c92855889f5f12fd5b","modified":1443751054000},{"_id":"themes/yilia/layout/_partial/post/nav.ejs","shasum":"d19dee2082528e1844bed3aa4e4bd59f15fd7a7a","modified":1443751054000},{"_id":"themes/yilia/layout/_partial/post/share.ejs","shasum":"da39b4ba0c0ce4e1932fd45c5aee10e8aca41f28","modified":1443751054000},{"_id":"themes/yilia/layout/_partial/post/tag.ejs","shasum":"78612cfc091d7d861a70455a0dc8c3036e460879","modified":1443751054000},{"_id":"themes/yilia/layout/_partial/post/title.ejs","shasum":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1443751054000},{"_id":"themes/yilia/layout/archive.ejs","shasum":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1443751054000},{"_id":"themes/yilia/layout/category.ejs","shasum":"765426a9c8236828dc34759e604cc2c52292835a","modified":1443751054000},{"_id":"themes/yilia/layout/index.ejs","shasum":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1443751054000},{"_id":"themes/yilia/layout/layout.ejs","shasum":"4a5566f704f3246f5ef77badddf18d2e16750328","modified":1443751054000},{"_id":"themes/yilia/layout/post.ejs","shasum":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1443751054000},{"_id":"themes/yilia/layout/page.ejs","shasum":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1443751054000},{"_id":"themes/yilia/layout/tag.ejs","shasum":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1443751054000},{"_id":"themes/yilia/package.json","shasum":"00357ef6f24eb049074da81809e98f973f528cca","modified":1443751054000},{"_id":"themes/yilia/source/ava.png","shasum":"de9bf8f3bb0690a8c13426c8cdf71b5182b729cd","modified":1443751054000},{"_id":"themes/yilia/source/css/_extend.styl","shasum":"8ab1ad313bd6707d248c5ca1ee9a5eab8d815e42","modified":1443751054000},{"_id":"themes/yilia/source/css/_partial/archive.styl","shasum":"8b349f1605024dcdae054e04f02d71a2e84957c2","modified":1443751054000},{"_id":"themes/yilia/source/css/_partial/article.styl","shasum":"872fc4e63509fef885c939e5fd70e6ed439beced","modified":1443751054000},{"_id":"themes/yilia/source/css/_partial/footer.styl","shasum":"7ca837a4cc34db1c35f01baec85eb10ccc64ea86","modified":1443751054000},{"_id":"themes/yilia/source/css/_partial/header.styl","shasum":"67e59feb18eee6026717cb440d86ab9551782628","modified":1443751054000},{"_id":"themes/yilia/source/css/_partial/highlight.styl","shasum":"8cadf8437ce6f372802d3d28617a1ab97e7c818e","modified":1443751054000},{"_id":"themes/yilia/source/css/_partial/instagram.styl","shasum":"8a7b07bf5ea2d3588c0019f722c245bb1a8696af","modified":1443751054000},{"_id":"themes/yilia/source/css/_partial/main.styl","shasum":"4268f759920106a576c6037264076b36018ff73b","modified":1443751054000},{"_id":"themes/yilia/source/css/_partial/page.styl","shasum":"720b5b169bc28ccba3794efce9b7cd39f243dec7","modified":1443751054000},{"_id":"themes/yilia/source/css/_partial/mobile-slider.styl","shasum":"e19c7fae6968ad3ea6cfc110900a991f9b5fce31","modified":1443751054000},{"_id":"themes/yilia/source/css/_partial/mobile.styl","shasum":"3a03b04ef8ac305aa5dbf7b9db99cd9377d07383","modified":1443751054000},{"_id":"themes/yilia/source/css/_partial/scroll.styl","shasum":"5539a38f9acd603d453a0ea0d8ce10893cf83d22","modified":1443751054000},{"_id":"themes/yilia/source/css/_partial/share.styl","shasum":"22697b9a9877ab9f018364feb57aeea4a8313c9a","modified":1443751054000},{"_id":"themes/yilia/source/css/_partial/tagcloud.styl","shasum":"af0115de5c6455f899a2e09225b50224982c039d","modified":1443751054000},{"_id":"themes/yilia/source/css/_util/grid.styl","shasum":"1aa883ab432d9e4139c89dcbd40ae2bd1528d029","modified":1443751054000},{"_id":"themes/yilia/source/css/_partial/wheelmenu.styl","shasum":"74630c56944e27bef53ef0c0e391611a2eec2ed0","modified":1443751054000},{"_id":"themes/yilia/source/css/_util/mixin.styl","shasum":"429bad87fc156eacf226c5e35b0eafc277f2504b","modified":1443751054000},{"_id":"themes/yilia/source/css/_variables.styl","shasum":"8b63ea3c7199524b9a1541075c6f8fb2c0d0ea3d","modified":1443751054000},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.eot","shasum":"3ce87b82c7a4ffdf65e96765c2ffda10b1a283c6","modified":1443751054000},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.svgz","shasum":"4bfdd33ed702e32ae01399fcc2652377f78e7626","modified":1443751054000},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.ttf","shasum":"1480b8101b02da9bc4c60341b5e185e63e585064","modified":1443751054000},{"_id":"themes/yilia/source/css/style.styl","shasum":"456e8cfe3b0b0371e81848ea9b0bc7ffd5360921","modified":1443751054000},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.woff","shasum":"cafc4ac5761a0a252d33dce4ea3952cf9a38d832","modified":1443751054000},{"_id":"themes/yilia/source/fancybox/blank.gif","shasum":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1443751054000},{"_id":"themes/yilia/source/fancybox/fancybox_loading.gif","shasum":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1443751054000},{"_id":"themes/yilia/source/fancybox/fancybox_loading@2x.gif","shasum":"273b123496a42ba45c3416adb027cd99745058b0","modified":1443751054000},{"_id":"themes/yilia/source/fancybox/fancybox_overlay.png","shasum":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1443751054000},{"_id":"themes/yilia/source/fancybox/fancybox_sprite.png","shasum":"17df19f97628e77be09c352bf27425faea248251","modified":1443751054000},{"_id":"themes/yilia/source/fancybox/helpers/fancybox_buttons.png","shasum":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1443751054000},{"_id":"themes/yilia/source/fancybox/fancybox_sprite@2x.png","shasum":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1443751054000},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-buttons.css","shasum":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1443751054000},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-buttons.js","shasum":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1443751054000},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-media.js","shasum":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1443751054000},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-thumbs.css","shasum":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1443751054000},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-thumbs.js","shasum":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1443751054000},{"_id":"themes/yilia/source/fancybox/jquery.fancybox.css","shasum":"b6aa6692c2e5f8bd74d96827b78570f0c5683c20","modified":1443751054000},{"_id":"themes/yilia/source/fancybox/jquery.fancybox.pack.js","shasum":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1443751054000},{"_id":"themes/yilia/source/fancybox/jquery.fancybox.js","shasum":"a82597493d75ea989ca586e09173cff332efe41e","modified":1443751054000},{"_id":"themes/yilia/source/favicon.ico","shasum":"7255c8f02a52fd8aa8d54f36fcb8e97314dc9e8b","modified":1443751054000},{"_id":"themes/yilia/source/favicon.png","shasum":"9f2b514e6f43dbe8a5d698a4c07fe0e2740a9296","modified":1443751054000},{"_id":"themes/yilia/source/img/coderwall.png","shasum":"fa84676c4d654e040e51fd34bfcd9f9348cd5331","modified":1443751054000},{"_id":"themes/yilia/source/img/delicious.png","shasum":"9553a5f5189e4a953e04a58a49dbfa74b86b73dd","modified":1443751054000},{"_id":"themes/yilia/source/img/douban.png","shasum":"e2ade003ffadd5826ee66ec23901c2d6e8607e4e","modified":1443751054000},{"_id":"themes/yilia/source/img/facebook.png","shasum":"d19ad7a0903daf26817afd8753cd97e0cc714f54","modified":1443751054000},{"_id":"themes/yilia/source/img/github.png","shasum":"b84d03b32fa388dcbf149296ebd16dce6223d48d","modified":1443751054000},{"_id":"themes/yilia/source/img/google.png","shasum":"61a21fec7346fa3400b747ac9a201cf3d5bc013d","modified":1443751054000},{"_id":"themes/yilia/source/img/img-err.png","shasum":"23a63ea26eb3c1d5e677d9883cf36cc1a1a1228b","modified":1443751054000},{"_id":"themes/yilia/source/img/img-loading.png","shasum":"a9cd5cd11866824f31e3d1c5e23badfeb3f73031","modified":1443751054000},{"_id":"themes/yilia/source/img/linkedin.png","shasum":"e203138fb53c257cb214e97f4e30091b9c568d2c","modified":1443751054000},{"_id":"themes/yilia/source/img/mail.png","shasum":"fca8199cc77fdbd700a45bf56d091c82f4a67fe7","modified":1443751054000},{"_id":"themes/yilia/source/img/pinboard.png","shasum":"0891fbb6d092fa012bf936019923383d84c6aeb0","modified":1443751054000},{"_id":"themes/yilia/source/img/pinterest.png","shasum":"9c72917f8779c083157c6ce7a5d62ed4874f0630","modified":1443751054000},{"_id":"themes/yilia/source/img/rss.png","shasum":"430fd47340e75214c081abd05cd7410cf7c71b86","modified":1443751054000},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","shasum":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1443751054000},{"_id":"themes/yilia/source/img/stackoverflow.png","shasum":"da5dfe9043055c95e479d49c78cd3b020de608f2","modified":1443751054000},{"_id":"themes/yilia/source/img/twitter.png","shasum":"14dbb8e62d056525253bc0de13acd1723da7a934","modified":1443751054000},{"_id":"themes/yilia/source/img/weibo.png","shasum":"280dae3fd38086158b4a1b57edb94c06b1a5014b","modified":1443751054000},{"_id":"themes/yilia/source/img/zhihu.png","shasum":"a6d6ef65e9ac82e613a311810391ebb90d9b1c1d","modified":1443751054000},{"_id":"themes/yilia/source/js/instagram.js","shasum":"81e13cacf4947118ed1920e59b04ccf6beef6b86","modified":1443751054000},{"_id":"themes/yilia/source/js/jquery.lazyload.js","shasum":"c11a2e7b330d16d06feabd0a8477099adf9d6799","modified":1443751054000},{"_id":"themes/yilia/source/js/main.js","shasum":"e2633f282e377a4169649c9f17dc96036ad4fc64","modified":1443751054000},{"_id":"themes/yilia/source/js/mobile.js","shasum":"b68cc01d24e80973c48205f551da87f3f3427644","modified":1443751054000},{"_id":"themes/yilia/source/js/pc.js","shasum":"a5397d34a04084ee089b4b1e26457ab46ecea63e","modified":1443751054000},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.svg","shasum":"ba13657479b46daecb6336bfe376f84cef3ae58b","modified":1443751054000}],"Category":[{"name":"编程与算法","_id":"cifj5gkf50001s8vnek3awl0b"},{"name":"日常维护","_id":"cifj5gkfc000es8vn5zr2mzfw"},{"name":"点点滴滴","_id":"cifj5gkgk002ss8vncvoa0xb2"}],"Data":[],"Page":[],"Post":[{"title":"汇编输出十进制数","date":"2015-08-24T09:34:25.000Z","_content":"最近，老师让写一个汇编程序，结果除了helloworld 其他都不会输出，输出个数字 还变成乱码，查阅资料后，发现输出到是ASCII码对应到字符，无奈只能一个一个输出。\n贴代码之前先补充一下：\n\nBIOS 中断 INT 10H 显示字符 AH = 0EH 显示 AL 里面的数据简单来说就是\nMOV AH,0EH\nINT 10H\n屏幕就会输出 AL 里面ASCII 码 对应到字符 \n\n\n<!--more-->\n\n\n其他的注释都有了，也没什么好说到了，感谢 baidu \n```asm\nCOUTD:              ;将双字AX化为10 进制并显示  \n    PUSH BX         ;BX,CX,DX 入栈，保存现场  \n    PUSH CX  \n    PUSH DX  \n    MOV BX,10       ;转换成10进制，所以BX <= 10  \n    XOR CX,CX       ;清空 CX  \nC0: XOR DX,DX       ;清空 DX  \n    DIV BX          ;AX 除以 BX,DX <= 余数, AX <= 商  \n    OR DX,0E30H     ;DX|0E30H 结果 DH = 0EH DL =30H+余数    \n    PUSH DX         ;商的ASCII码入栈   \n    INC CX          ;CX 自加 用于 出栈时计数  \n    CMP AX,0        ;比较AX 与 0   \n    JNZ C0          ;若AX(商) 不为 0 则 高位还有数 跳转到C0 继续进行计算   \nC1: POP AX          ;出栈到AX 此时 AH = 0EH AL = 十进制数到ASCII码  \n    INT 10H         ;AH = 0EH 将AL 输出到屏幕  \n    LOOP C1         ;CX 不为0 则跳转到C1继续出栈 输出  \n    POP DX          ;BX,CX,DX 出栈，恢复现场  \n    POP CX  \n    POP BX  \n    RET  \n```\n","source":"_posts/1.md","raw":"title: 汇编输出十进制数\ndate: 2015-08-24 17:34:25\ncategories: 编程与算法\ntags: [asm,课后练习]\n---\n最近，老师让写一个汇编程序，结果除了helloworld 其他都不会输出，输出个数字 还变成乱码，查阅资料后，发现输出到是ASCII码对应到字符，无奈只能一个一个输出。\n贴代码之前先补充一下：\n\nBIOS 中断 INT 10H 显示字符 AH = 0EH 显示 AL 里面的数据简单来说就是\nMOV AH,0EH\nINT 10H\n屏幕就会输出 AL 里面ASCII 码 对应到字符 \n\n\n<!--more-->\n\n\n其他的注释都有了，也没什么好说到了，感谢 baidu \n```asm\nCOUTD:              ;将双字AX化为10 进制并显示  \n    PUSH BX         ;BX,CX,DX 入栈，保存现场  \n    PUSH CX  \n    PUSH DX  \n    MOV BX,10       ;转换成10进制，所以BX <= 10  \n    XOR CX,CX       ;清空 CX  \nC0: XOR DX,DX       ;清空 DX  \n    DIV BX          ;AX 除以 BX,DX <= 余数, AX <= 商  \n    OR DX,0E30H     ;DX|0E30H 结果 DH = 0EH DL =30H+余数    \n    PUSH DX         ;商的ASCII码入栈   \n    INC CX          ;CX 自加 用于 出栈时计数  \n    CMP AX,0        ;比较AX 与 0   \n    JNZ C0          ;若AX(商) 不为 0 则 高位还有数 跳转到C0 继续进行计算   \nC1: POP AX          ;出栈到AX 此时 AH = 0EH AL = 十进制数到ASCII码  \n    INT 10H         ;AH = 0EH 将AL 输出到屏幕  \n    LOOP C1         ;CX 不为0 则跳转到C1继续出栈 输出  \n    POP DX          ;BX,CX,DX 出栈，恢复现场  \n    POP CX  \n    POP BX  \n    RET  \n```\n","slug":"1","published":1,"updated":"2015-10-02T01:57:34.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cifj5gkf10000s8vnfcza5p92"},{"title":"并查集 poj食物链","date":"2015-08-25T00:28:04.000Z","_content":"一般父类便为更节点更新节点时 kin = 0 \n\n\n<!--more-->\n\n\n```cpp\n#include <iostream>  \n#include <stdio.h>  \nusing namespace std;  \nint par[50000],kin[50000];  \nvoid init(int n){  \n        int i;  \n        for(i=0;i<n;i++){  \n                par[i] = i;  \n                kin[i] = 0;  \n        }  \n}  \nvoid uniun(int xroot,int yroot,int x,int y,int o){  \n        par[yroot] = xroot;  \n        kin[yroot] = (kin[x]-kin[y]-o+3)%3;  \n}  \nint find(int x){  \n    if(par[x] == x)return x;  \n    int xroot;  \n    xroot = find(par[x]);  \n    kin[x] = (kin[par[x]]+kin[x]+3)%3;  \n    par[x] = xroot;  \n    return xroot;  \n}  \nint main(){  \n        int n,k;  \n        int x,y,o;  \n        int count = 0;  \n        scanf(\"%d%d\",&n,&k);  \n        init(n);  \n        while(k--){  \n            scanf(\"%d%d%d\",&o,&x,&y);  \n            x--;  \n            y--;  \n            if(x>=n||y>=n){  \n                count++;  \n                continue;  \n            }  \n            int xroot = find(x);  \n            int yroot = find(y);  \n            if(xroot == yroot){  \n                    int u = (kin[x] - kin[y]+3)%3;  \n                    if(u==0 && o == 1){  \n                        continue;  \n                    }  \n                    if(u == 1 && o == 2){  \n                            continue;  \n                    }  \n                    count++;  \n            }else{  \n                    uniun(xroot,yroot,x,y,o-1);  \n            }  \n        }  \n        printf(\"%d\\n\",count);  \n        return 0;  \n}  \n```","source":"_posts/9.md","raw":"title: 并查集 poj食物链\ncategories: 编程与算法\ndate: 2015-08-25 08:28:04\ntags: [poj,uniun]\n---\n一般父类便为更节点更新节点时 kin = 0 \n\n\n<!--more-->\n\n\n```cpp\n#include <iostream>  \n#include <stdio.h>  \nusing namespace std;  \nint par[50000],kin[50000];  \nvoid init(int n){  \n        int i;  \n        for(i=0;i<n;i++){  \n                par[i] = i;  \n                kin[i] = 0;  \n        }  \n}  \nvoid uniun(int xroot,int yroot,int x,int y,int o){  \n        par[yroot] = xroot;  \n        kin[yroot] = (kin[x]-kin[y]-o+3)%3;  \n}  \nint find(int x){  \n    if(par[x] == x)return x;  \n    int xroot;  \n    xroot = find(par[x]);  \n    kin[x] = (kin[par[x]]+kin[x]+3)%3;  \n    par[x] = xroot;  \n    return xroot;  \n}  \nint main(){  \n        int n,k;  \n        int x,y,o;  \n        int count = 0;  \n        scanf(\"%d%d\",&n,&k);  \n        init(n);  \n        while(k--){  \n            scanf(\"%d%d%d\",&o,&x,&y);  \n            x--;  \n            y--;  \n            if(x>=n||y>=n){  \n                count++;  \n                continue;  \n            }  \n            int xroot = find(x);  \n            int yroot = find(y);  \n            if(xroot == yroot){  \n                    int u = (kin[x] - kin[y]+3)%3;  \n                    if(u==0 && o == 1){  \n                        continue;  \n                    }  \n                    if(u == 1 && o == 2){  \n                            continue;  \n                    }  \n                    count++;  \n            }else{  \n                    uniun(xroot,yroot,x,y,o-1);  \n            }  \n        }  \n        printf(\"%d\\n\",count);  \n        return 0;  \n}  \n```","slug":"9","published":1,"updated":"2015-10-02T01:57:34.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cifj5gkf90007s8vnvb6y75yd"},{"title":"在ubuntu下配置VPN","date":"2015-08-25T00:26:53.000Z","_content":"好久不写博客了，大部分东西都写进了为知笔记，本来想更换typecho，最后还是用的wp。\n为什么要在ubuntu下用vpn，因为很多时候就在ubuntu下作业啊。\n\n\n<!--more-->\n\n\n废话不多说：首先来最简单的就是\nPPTP 点对点隧道协议：\n这个是ubuntu自带的vpn啦，单击新建一个vpn然后填入网关，用户名和密码。其实网关那里就是填的学长给的地址，本来以为这样就完成了，可是死活连不上。后来打开右下角有个高级设置：\n![vpn.png][1]\n\n然后勾掉PAP、CHAP、EAP 就可以成功连接了。\n再一个就是安装L2TP这个要自己通过包管理来安装了：\n```sh\nsudo apt-add-repository ppa:seriy-pr/network-manager-l2tp\nsudo apt-get install network-manager-l2tp-gnome\nsudo service xl2tpd start\n```\n然后就可以在vpn列表中找到了。\n\n  [1]: http://www.eternalac.com/usr/uploads/2015/07/1129759032.png","source":"_posts/8.md","raw":"title: 在ubuntu下配置VPN\ncategories: 日常维护\ndate: 2015-08-25 08:26:53\ntags: [ubuntu,vpn]\n---\n好久不写博客了，大部分东西都写进了为知笔记，本来想更换typecho，最后还是用的wp。\n为什么要在ubuntu下用vpn，因为很多时候就在ubuntu下作业啊。\n\n\n<!--more-->\n\n\n废话不多说：首先来最简单的就是\nPPTP 点对点隧道协议：\n这个是ubuntu自带的vpn啦，单击新建一个vpn然后填入网关，用户名和密码。其实网关那里就是填的学长给的地址，本来以为这样就完成了，可是死活连不上。后来打开右下角有个高级设置：\n![vpn.png][1]\n\n然后勾掉PAP、CHAP、EAP 就可以成功连接了。\n再一个就是安装L2TP这个要自己通过包管理来安装了：\n```sh\nsudo apt-add-repository ppa:seriy-pr/network-manager-l2tp\nsudo apt-get install network-manager-l2tp-gnome\nsudo service xl2tpd start\n```\n然后就可以在vpn列表中找到了。\n\n  [1]: http://www.eternalac.com/usr/uploads/2015/07/1129759032.png","slug":"8","published":1,"updated":"2015-10-02T01:57:34.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cifj5gkfc000ds8vnq3eltf3g"},{"title":"Cash Machine poj1276","date":"2015-08-25T00:18:00.000Z","_content":"这是以前在csdn写的博客，因为图太多就仅贴代码吧。如果想看图请移步：http://blog.csdn.net/anjicun/article/details/37772091\n\n\n----------\n动态规划的题 第一次超时 修改后A过\n//做好了图片 可以进行解释此题代码了\n状态方程应该都没问题 fin[i] = max{fin[i],fin[i-w]+w}(w 为价值，fin[i] 表示 当价值为i 时 所能承载的最大价值 )\n//下面这段代码是重点\n```cpp\nwhile (k <= num){  \n        for (int i = cash; i>= k*wei; i--){  \n            fin[i] = max(fin[i],fin[i - k*wei] + k*wei);  \n        }  \n        num -= k;  \n        k <<= 1;  \n    }  \n    for (int i = cash; i>=num * wei; i--){  \n        fin[i] = max(fin[i],fin[i-num * wei] + num * wei);  \n    }  \n```\n\n\n<!--more-->\n\n\n\n下面 用 num = 6 cash = 10w 的例子来解释一下 请看动态图：\n![20140715102713728.gif][1]\n\n第一次循环(灰色) k = 1 < num = 6        fin[10w]~fin[1w] = w\n第二次循环(桔色) k = 2 < num = 5        fin[10w]~fin[3w] = 3w     fin[3w]~fin[2w] = 2w\n第三次无法循环 k = 4 > num = 3 所以到下一段代码进行补充\n\n    for (int i = cash; i>=num * wei; i--)\n\n状态方程 `fin[i] = max{fin[i], fin[i-num*w]+num*w]} (num = 3,3w <= i <= 10w)`\n(黄色)`fin[10w]~fin[6w] = 6w     fin[6w]~fin[5w] = 5w ......`\n其实将 k <<= 1 换成 k++ 同样可以AC 道理是一样的 也同样可以证明\n\n\n```cpp\n#include <iostream>  \n#include <string.h>  \n#include <stdio.h>  \nusing namespace std;  \nint cash;  \nint Num;  \nint fin[100001];  \nint n[1001],w[1001];  \nint max(int x,int y){  \n        if(x>y)return x;  \n        else return y;  \n}  \nvoid inpack(int num,int wei){  \n        if(num*wei >= cash){  \n                for(int i=wei;i<=cash;i++){  \n                        //fin[i] = max(fin[i],fin[i-wei]+wei);  \n                        fin[i] = (fin[i]>(fin[i-wei]+wei))?fin[i]:(fin[i-wei]+wei);  \n                }  \n                return;  \n        }  \n    int k = 1;  \n    while (k <= num){  \n        for (int i = cash; i>= k*wei; i--){  \n            fin[i] = max(fin[i],fin[i - k*wei] + k*wei);  \n        }  \n        num -= k;  \n        k <<= 1;  \n    }  \n    for (int i = cash; i>=num * wei; i--){  \n        fin[i] = max(fin[i],fin[i-num * wei] + num * wei);  \n    }  \n}  \nint main(){  \n    int M,i;  \n    while(scanf(\"%d%d\",&cash,&M)!=EOF){  \n        memset(fin,0,sizeof(fin));  \n        for(i=1;i<=M;i++){  \n            scanf(\"%d%d\",&n[i],&w[i]);  \n        }  \n        for(i=1;i<=M;i++){  \n            inpack(n[i],w[i]);  \n        }  \n        printf(\"%d\\n\",fin[cash]);  \n    }  \n    return 0;     \n}  \n```\n  [1]: http://www.eternalac.com/usr/uploads/2015/07/3191629053.gif","source":"_posts/7.md","raw":"title: Cash Machine poj1276\ncategories: 编程与算法\ndate: 2015-08-25 08:18:00\ntags: [acm,poj]\n---\n这是以前在csdn写的博客，因为图太多就仅贴代码吧。如果想看图请移步：http://blog.csdn.net/anjicun/article/details/37772091\n\n\n----------\n动态规划的题 第一次超时 修改后A过\n//做好了图片 可以进行解释此题代码了\n状态方程应该都没问题 fin[i] = max{fin[i],fin[i-w]+w}(w 为价值，fin[i] 表示 当价值为i 时 所能承载的最大价值 )\n//下面这段代码是重点\n```cpp\nwhile (k <= num){  \n        for (int i = cash; i>= k*wei; i--){  \n            fin[i] = max(fin[i],fin[i - k*wei] + k*wei);  \n        }  \n        num -= k;  \n        k <<= 1;  \n    }  \n    for (int i = cash; i>=num * wei; i--){  \n        fin[i] = max(fin[i],fin[i-num * wei] + num * wei);  \n    }  \n```\n\n\n<!--more-->\n\n\n\n下面 用 num = 6 cash = 10w 的例子来解释一下 请看动态图：\n![20140715102713728.gif][1]\n\n第一次循环(灰色) k = 1 < num = 6        fin[10w]~fin[1w] = w\n第二次循环(桔色) k = 2 < num = 5        fin[10w]~fin[3w] = 3w     fin[3w]~fin[2w] = 2w\n第三次无法循环 k = 4 > num = 3 所以到下一段代码进行补充\n\n    for (int i = cash; i>=num * wei; i--)\n\n状态方程 `fin[i] = max{fin[i], fin[i-num*w]+num*w]} (num = 3,3w <= i <= 10w)`\n(黄色)`fin[10w]~fin[6w] = 6w     fin[6w]~fin[5w] = 5w ......`\n其实将 k <<= 1 换成 k++ 同样可以AC 道理是一样的 也同样可以证明\n\n\n```cpp\n#include <iostream>  \n#include <string.h>  \n#include <stdio.h>  \nusing namespace std;  \nint cash;  \nint Num;  \nint fin[100001];  \nint n[1001],w[1001];  \nint max(int x,int y){  \n        if(x>y)return x;  \n        else return y;  \n}  \nvoid inpack(int num,int wei){  \n        if(num*wei >= cash){  \n                for(int i=wei;i<=cash;i++){  \n                        //fin[i] = max(fin[i],fin[i-wei]+wei);  \n                        fin[i] = (fin[i]>(fin[i-wei]+wei))?fin[i]:(fin[i-wei]+wei);  \n                }  \n                return;  \n        }  \n    int k = 1;  \n    while (k <= num){  \n        for (int i = cash; i>= k*wei; i--){  \n            fin[i] = max(fin[i],fin[i - k*wei] + k*wei);  \n        }  \n        num -= k;  \n        k <<= 1;  \n    }  \n    for (int i = cash; i>=num * wei; i--){  \n        fin[i] = max(fin[i],fin[i-num * wei] + num * wei);  \n    }  \n}  \nint main(){  \n    int M,i;  \n    while(scanf(\"%d%d\",&cash,&M)!=EOF){  \n        memset(fin,0,sizeof(fin));  \n        for(i=1;i<=M;i++){  \n            scanf(\"%d%d\",&n[i],&w[i]);  \n        }  \n        for(i=1;i<=M;i++){  \n            inpack(n[i],w[i]);  \n        }  \n        printf(\"%d\\n\",fin[cash]);  \n    }  \n    return 0;     \n}  \n```\n  [1]: http://www.eternalac.com/usr/uploads/2015/07/3191629053.gif","slug":"7","published":1,"updated":"2015-10-02T01:57:34.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cifj5gkfe000ks8vn69glqvxn"},{"title":"Ubuntu 重裝後必做操作(二)安裝必備軟件","date":"2015-08-25T00:13:54.000Z","_content":"<!--more-->\n\n\n安裝爲知筆記\n```sh\nsudo add-apt-repository ppa:wiznote-team\nsudo apt-get update\nsudo apt-get install wiznote\n```\n安裝java\n```sh\nsudo add-apt-repository ppa:webupd8team/java\nsudo apt-get update\nsudo apt-get install oracle-java8-installer\n```\n安装zsh\n```sh\nsudo apt-get install zsh\ngit clone https://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh\ncp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc\nchsh -s /bin/zsh\n```\n爲Firefox安裝flash\n在Adobe官网下载flash\n\n    sudo cp libflashplayer.so /usr/lib/mozilla/plugins/","source":"_posts/6.md","raw":"title: Ubuntu 重裝後必做操作(二)安裝必備軟件\ndate: 2015-08-25 08:13:54\ncategories: 日常维护\ntags: [ubuntu,software]\n---\n<!--more-->\n\n\n安裝爲知筆記\n```sh\nsudo add-apt-repository ppa:wiznote-team\nsudo apt-get update\nsudo apt-get install wiznote\n```\n安裝java\n```sh\nsudo add-apt-repository ppa:webupd8team/java\nsudo apt-get update\nsudo apt-get install oracle-java8-installer\n```\n安装zsh\n```sh\nsudo apt-get install zsh\ngit clone https://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh\ncp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc\nchsh -s /bin/zsh\n```\n爲Firefox安裝flash\n在Adobe官网下载flash\n\n    sudo cp libflashplayer.so /usr/lib/mozilla/plugins/","slug":"6","published":1,"updated":"2015-10-02T01:57:34.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cifj5gkfh000ps8vn63h0gkk1"},{"title":"Ubuntu 重裝後必做操作(一)科學上網","date":"2015-08-25T00:11:58.000Z","_content":"由於今天爲了體驗ubuntu15.04 的Nvidia驅動導致在登錄界面無線循環，無奈重裝了系統，現在重新將步驟記錄一下，以待不時之需：\n\n\n<!--more-->\n\n\n1、首先是科學上網安裝shadowsocks\n\n    sudo apt-get install python-gevent python-pip\n    sudo pip install shadowsocks\n創建json配置文件shadow.json\n\n    {\n        \"server\":\"xxx.xxx.xxx.xxx\",\n        \"server_port\":8080,\n        \"local_port\":1080,\n        \"password\":\"xxxxxx\",\n        \"timeout\":600,\n        \"method\":\"aes-256-cfb\"\n    }\n編寫腳本運行shadows.sh\n\n    #!/bin/sh \n    sslocal -c shadow.json\n讓其後臺運行\n\n    nohup ./shadows.sh > log &","source":"_posts/5.md","raw":"title: Ubuntu 重裝後必做操作(一)科學上網\ndate: 2015-08-25 08:11:58\ncategories: 日常维护\ntags: [ubuntu,shadowsocks,ss]\n---\n由於今天爲了體驗ubuntu15.04 的Nvidia驅動導致在登錄界面無線循環，無奈重裝了系統，現在重新將步驟記錄一下，以待不時之需：\n\n\n<!--more-->\n\n\n1、首先是科學上網安裝shadowsocks\n\n    sudo apt-get install python-gevent python-pip\n    sudo pip install shadowsocks\n創建json配置文件shadow.json\n\n    {\n        \"server\":\"xxx.xxx.xxx.xxx\",\n        \"server_port\":8080,\n        \"local_port\":1080,\n        \"password\":\"xxxxxx\",\n        \"timeout\":600,\n        \"method\":\"aes-256-cfb\"\n    }\n編寫腳本運行shadows.sh\n\n    #!/bin/sh \n    sslocal -c shadow.json\n讓其後臺運行\n\n    nohup ./shadows.sh > log &","slug":"5","published":1,"updated":"2015-10-02T01:57:34.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cifj5gkfk000us8vn1hvan6ua"},{"title":"Androidx86 ubuntu 引导","date":"2015-08-25T00:10:48.000Z","_content":"閒極無聊，把自己很老的一個上網本裝了個ubuntu與Android X86的雙系統，由於Android的引導式grub1,所以沒辦法引導ubuntu，所以使用Ubuntu的引導來啓動Android。\n\n\n<!--more-->\n\n\n首先修改啓動文件\n\n    sudo gedit /etc/grub.d/40_custom\n在文件下添加下面內容，注意sda3，與hd0,3這些要根據你自己的實際情況來修改\n\n    menuentry “Android-x86 4.4.2 r2″ {\n    set root=(hd0,3)\n    linux /android-4.4-r2/kernel quiet root=/dev/sda3 androidboot.hardware=android_x86 video=-16 SRC=/android-4.4-r2\n    initrd /android-4.4-r2/initrd.img\n    }\n然後更新引導\n\n    sudo grub-mkconfig\n    sudo update-grub\n\n添加完成後，總是無法進入到選擇頁面，後來發現，講快速啓動設爲0就可以了\n\n    sudo gedit /etc/grub.d/00_header\n\n    quick_boot=”0”\n    if [ “$quick_boot” = 1 ];\n    then\n    ([ “$quick_boot” = 1 ] || [ “x${1}” != “x0″ ]) ;\n    then\n\n修改後完美啓動","source":"_posts/4.md","raw":"title: Androidx86 ubuntu 引导\ndate: 2015-08-25 08:10:48\ncategories: 日常维护\ntags: [Android,ubuntu]\n---\n閒極無聊，把自己很老的一個上網本裝了個ubuntu與Android X86的雙系統，由於Android的引導式grub1,所以沒辦法引導ubuntu，所以使用Ubuntu的引導來啓動Android。\n\n\n<!--more-->\n\n\n首先修改啓動文件\n\n    sudo gedit /etc/grub.d/40_custom\n在文件下添加下面內容，注意sda3，與hd0,3這些要根據你自己的實際情況來修改\n\n    menuentry “Android-x86 4.4.2 r2″ {\n    set root=(hd0,3)\n    linux /android-4.4-r2/kernel quiet root=/dev/sda3 androidboot.hardware=android_x86 video=-16 SRC=/android-4.4-r2\n    initrd /android-4.4-r2/initrd.img\n    }\n然後更新引導\n\n    sudo grub-mkconfig\n    sudo update-grub\n\n添加完成後，總是無法進入到選擇頁面，後來發現，講快速啓動設爲0就可以了\n\n    sudo gedit /etc/grub.d/00_header\n\n    quick_boot=”0”\n    if [ “$quick_boot” = 1 ];\n    then\n    ([ “$quick_boot” = 1 ] || [ “x${1}” != “x0″ ]) ;\n    then\n\n修改後完美啓動","slug":"4","published":1,"updated":"2015-10-02T01:57:34.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cifj5gkfo0011s8vn2vnm4v0b"},{"title":"ubuntu安装Virtualbox","date":"2015-10-06T01:40:45.000Z","_content":"因为需要搭建一个集群，所以需要安装多台虚拟机进行。Vmware太大而且是收费的，所以最后决定用virtualbox.\n\n在过程中遇到了如下问题:\n>Kernel driver not installed (rc=-1908)  \n>\n>The VirtualBox Linux kernel driver (vboxdrv) is either not loaded or there is a permission problem with /dev/vboxdrv. Please reinstall the kernel module by executing  \n>\n>'/etc/init.d/vboxdrv setup'  \n>\n>as root. If it is available in your distribution, you should install the DKMS package first. This package keeps track of Linux kernel changes and recompiles the vboxdrv kernel module if necessary.\n\n下面就说一下安装的流程。\n\n<!--more-->\n\n其实最简单的方式是去官网下载`deb`包，然后直接`dpkg`安装即可。没有任何问题。\n\n但是如果使用了包管理的方式去安装，它安装的是`OSE`版的，会提示缺少内核模块，这就需要进行一些操作如下：\n```cpp\nsudo apt-get install build-essential module-assistant \nsudo m-a prepare\nsudo /etc/init.d/vboxdrv setup\n```\n即可。","source":"_posts/34.md","raw":"title: ubuntu安装Virtualbox\ndate: 2015-10-06 09:40:45\ncategories: 日常维护\ntags: [ubuntu,virtualbox,error]\n---\n因为需要搭建一个集群，所以需要安装多台虚拟机进行。Vmware太大而且是收费的，所以最后决定用virtualbox.\n\n在过程中遇到了如下问题:\n>Kernel driver not installed (rc=-1908)  \n>\n>The VirtualBox Linux kernel driver (vboxdrv) is either not loaded or there is a permission problem with /dev/vboxdrv. Please reinstall the kernel module by executing  \n>\n>'/etc/init.d/vboxdrv setup'  \n>\n>as root. If it is available in your distribution, you should install the DKMS package first. This package keeps track of Linux kernel changes and recompiles the vboxdrv kernel module if necessary.\n\n下面就说一下安装的流程。\n\n<!--more-->\n\n其实最简单的方式是去官网下载`deb`包，然后直接`dpkg`安装即可。没有任何问题。\n\n但是如果使用了包管理的方式去安装，它安装的是`OSE`版的，会提示缺少内核模块，这就需要进行一些操作如下：\n```cpp\nsudo apt-get install build-essential module-assistant \nsudo m-a prepare\nsudo /etc/init.d/vboxdrv setup\n```\n即可。","slug":"34","published":1,"updated":"2015-10-06T02:06:03.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cifj5gkfr0016s8vnz0usdwrs"},{"title":"spfa算法","date":"2015-10-04T08:44:04.000Z","_content":"\n`spfa`算是是使用队列去优化`bellman`的一种算法吧。\n\n>求单源最短路的SPFA算法的全称是：Shortest Path Faster Algorithm，是西南交通大学段凡丁于1994年发表的。从名字我们就可以看出，这种算法在效率上一定有过人之处。很多时候，给定的图存在负权边，这时类似Dijkstra等算法便没有了用武之地，而Bellman-Ford算法的复杂度又过高，SPFA算法便派上用场了。简洁起见，我们约定加权有向图G不存在负权回路，即最短路径一定存在。如果某个点进入队列的次数超过N次则存在负环（SPFA无法处理带负环的图）。当然，我们可以在执行该算法前做一次拓扑排序，以判断是否存在负权回路，但这不是我们讨论的重点。我们用数组d记录每个结点的最短路径估计值，而且用邻接表来存储图G。我们采取的方法是动态逼近法：设立一个先进先出的队列用来保存待优化的结点，优化时每次取出队首结点u，并且用u点当前的最短路径估计值对离开u点所指向的结点v进行松弛操作，如果v点的最短路径估计值有所调整，且v点不在当前的队列中，就将v点放入队尾。这样不断从队列中取出结点来进行松弛操作，直至队列空为止。定理: 只要最短路径存在，上述SPFA算法必定能求出最小值。\n\n<!--more-->\n\n## 算法简介\n- 建立一个带权值的邻接矩阵，然后定义`dis[N]`表示源点到其他点的距离，然后将源点入队。\n- 当队列不空时：取出队列中第一个元素，遍历它的出度`edge`，如果以该有向边`edge`为中间边到达某个节点的距离小于原本的距离(`dis[x] + edge < dis[y]`)，则将这个点`y`入队，同时进行松弛操作。\n- 当一个点入队超过`n`次时，表明他经过了`n`次松弛操作。说明存在负环。\n\n## 代码示例\n```cpp\nstruct Edge{\n\tint wi;\t\t//权值\n\tint to;\t\t//边终点\n};\nint V_NUM;\t\t\t\t//节点数\nint E_NUM;\t\t\t\t//边数\nvector <Edge> v[M];\t\t//邻接表式\nint dis[M];\t\t\t\t//到i点的距离\nint times[M];\t\t\t//i点入队的次数\nint is_push[M];\t\t\t//i点是否入队\n\nbool spfa(int st){\n\tint i;\n\tqueue <int> qu;\n\tfor (int i = 0; i < V_NUM; ++i){\n\t\tif(i==st)dis[i] = 0;\n\t\telse dis[i] = VMAX;\n\t\ttimes[i] = 0;\n\t\tis_push[i] = 0;\n\t}\n\tqu.push(st);\n\ttimes[st] = 1;\n\tis_push[st] = 1;\n\twhile(!qu.empty()){\n\t\tint temp_v = qu.front();\n\t\tint n_vi = (int)v[temp_v].size();\t\t//该点的出度\n\t\tfor(i=0;i<n_vi;i++){\n\t\t\tEdge *e = &v[temp_v][i];\t\t\t//取出一条边\n\t\t\tif(dis[e->to]>(dis[temp_v]+e->wi)){\t//满足松弛条件\n\t\t\t\tdis[e->to] = dis[temp_v]+e->wi;\n\t\t\t\tqu.push(e->to);\n\t\t\t\ttimes[e->to]++;\n\t\t\t\tis_push[e->to] = 1;\n\t\t\t\tif(times[e->to]>V_NUM){\t\t\t//入队次数爆表，存在负环\n\t\t\t\t\twhile(!qu.empty())qu.pop();\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tqu.pop();\n\t\tis_push[temp_v] = 0;\n\t}\n\treturn 1;\n}\n```\n\n## 再次补充\n虽然介绍越来越短了，但是相信大家，看到代码后还是可以自己看懂的哈。","source":"_posts/33.md","raw":"title: spfa算法\ndate: 2015-10-04 16:44:04\ncategories: 编程与算法\ntags: [最短路,ACM,图论,spfa]\n---\n\n`spfa`算是是使用队列去优化`bellman`的一种算法吧。\n\n>求单源最短路的SPFA算法的全称是：Shortest Path Faster Algorithm，是西南交通大学段凡丁于1994年发表的。从名字我们就可以看出，这种算法在效率上一定有过人之处。很多时候，给定的图存在负权边，这时类似Dijkstra等算法便没有了用武之地，而Bellman-Ford算法的复杂度又过高，SPFA算法便派上用场了。简洁起见，我们约定加权有向图G不存在负权回路，即最短路径一定存在。如果某个点进入队列的次数超过N次则存在负环（SPFA无法处理带负环的图）。当然，我们可以在执行该算法前做一次拓扑排序，以判断是否存在负权回路，但这不是我们讨论的重点。我们用数组d记录每个结点的最短路径估计值，而且用邻接表来存储图G。我们采取的方法是动态逼近法：设立一个先进先出的队列用来保存待优化的结点，优化时每次取出队首结点u，并且用u点当前的最短路径估计值对离开u点所指向的结点v进行松弛操作，如果v点的最短路径估计值有所调整，且v点不在当前的队列中，就将v点放入队尾。这样不断从队列中取出结点来进行松弛操作，直至队列空为止。定理: 只要最短路径存在，上述SPFA算法必定能求出最小值。\n\n<!--more-->\n\n## 算法简介\n- 建立一个带权值的邻接矩阵，然后定义`dis[N]`表示源点到其他点的距离，然后将源点入队。\n- 当队列不空时：取出队列中第一个元素，遍历它的出度`edge`，如果以该有向边`edge`为中间边到达某个节点的距离小于原本的距离(`dis[x] + edge < dis[y]`)，则将这个点`y`入队，同时进行松弛操作。\n- 当一个点入队超过`n`次时，表明他经过了`n`次松弛操作。说明存在负环。\n\n## 代码示例\n```cpp\nstruct Edge{\n\tint wi;\t\t//权值\n\tint to;\t\t//边终点\n};\nint V_NUM;\t\t\t\t//节点数\nint E_NUM;\t\t\t\t//边数\nvector <Edge> v[M];\t\t//邻接表式\nint dis[M];\t\t\t\t//到i点的距离\nint times[M];\t\t\t//i点入队的次数\nint is_push[M];\t\t\t//i点是否入队\n\nbool spfa(int st){\n\tint i;\n\tqueue <int> qu;\n\tfor (int i = 0; i < V_NUM; ++i){\n\t\tif(i==st)dis[i] = 0;\n\t\telse dis[i] = VMAX;\n\t\ttimes[i] = 0;\n\t\tis_push[i] = 0;\n\t}\n\tqu.push(st);\n\ttimes[st] = 1;\n\tis_push[st] = 1;\n\twhile(!qu.empty()){\n\t\tint temp_v = qu.front();\n\t\tint n_vi = (int)v[temp_v].size();\t\t//该点的出度\n\t\tfor(i=0;i<n_vi;i++){\n\t\t\tEdge *e = &v[temp_v][i];\t\t\t//取出一条边\n\t\t\tif(dis[e->to]>(dis[temp_v]+e->wi)){\t//满足松弛条件\n\t\t\t\tdis[e->to] = dis[temp_v]+e->wi;\n\t\t\t\tqu.push(e->to);\n\t\t\t\ttimes[e->to]++;\n\t\t\t\tis_push[e->to] = 1;\n\t\t\t\tif(times[e->to]>V_NUM){\t\t\t//入队次数爆表，存在负环\n\t\t\t\t\twhile(!qu.empty())qu.pop();\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tqu.pop();\n\t\tis_push[temp_v] = 0;\n\t}\n\treturn 1;\n}\n```\n\n## 再次补充\n虽然介绍越来越短了，但是相信大家，看到代码后还是可以自己看懂的哈。","slug":"33","published":1,"updated":"2015-10-04T09:00:25.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cifj5gkft001ds8vn0sa617rm"},{"title":"bellman-ford算法","date":"2015-10-04T06:27:06.000Z","_content":"\n以前说的都是不存在负环的最短路径算法，但是如果一旦边的权值出现负数，则循环将无限进行。所以我们需要一种算法来判断是否出现负环。\n\n下面就简单介绍一下Bellman-ford 算法。\n\n<!--more-->\n\n## 主要思想\n求某点到其他点的最短路径，如果经过一条边`n-1`次后，再次进过还可以减小路径的权值，则说明存在负环。\n\n原文是这样的。\n>Bellman-ford算法是求含负权图的单源最短路径算法，效率很低，但代码很容易写。即进行持续地松弛，每次松弛把每条边都更新一下，若n-1次松弛后还能更新，则说明图中有负环，无法得出结果，否则就成功完成。\n\n## 算法简介\n- 首先确定一个源点（起始点），然后定义`dis[N]`表示源点到其他点的距离。还有定义一个边集。\n- 使用两个循环来对边集中各个边进行一次松弛操作。\n- 循环结束后查看是否还可以进行松弛，如果仍然可以，则存在负环。\n\n## 算法实现\n```cpp\nstruct Edge{\n\tint v,u;\n\tint w;\n}edge[M+1];\nbool bellman_ford(int st){  \n    for(int i = 1; i <= N; ++i)\n        dis[i] = INF;\n\tdis[st] = 0;\n    for(int i = 1; i <= N - 1; ++i)  \n        for(int j = 1; j <= M; ++j)  \n            if(dis[edge[j].v] > dis[edge[j].u] + edge[j].w){  \n                dis[edge[j].v] = dis[edge[j].u] + edge[j].w;\n            }  \n    bool flag = 1;\n    for(int i = 1; i <= edgenum; ++i)  \n    \tif(dis[edge[i].v] > dis[edge[i].u] + edge[i].w)  {\n\t\t\tflag = 0;  \n\t\t\tbreak;\n\t\t}  \n\treturn flag;  \n}  \n```\n\n## 补充一下\n对于这个算法，说的有点简略，不过仔细琢磨一下代码，也就懂了。啊哈哈哈哈。","source":"_posts/32.md","raw":"title: bellman-ford算法\ndate: 2015-10-04 14:27:06\ncategories: 编程与算法\ntags: [最短路,ACM,图论,bellman-ford]\n---\n\n以前说的都是不存在负环的最短路径算法，但是如果一旦边的权值出现负数，则循环将无限进行。所以我们需要一种算法来判断是否出现负环。\n\n下面就简单介绍一下Bellman-ford 算法。\n\n<!--more-->\n\n## 主要思想\n求某点到其他点的最短路径，如果经过一条边`n-1`次后，再次进过还可以减小路径的权值，则说明存在负环。\n\n原文是这样的。\n>Bellman-ford算法是求含负权图的单源最短路径算法，效率很低，但代码很容易写。即进行持续地松弛，每次松弛把每条边都更新一下，若n-1次松弛后还能更新，则说明图中有负环，无法得出结果，否则就成功完成。\n\n## 算法简介\n- 首先确定一个源点（起始点），然后定义`dis[N]`表示源点到其他点的距离。还有定义一个边集。\n- 使用两个循环来对边集中各个边进行一次松弛操作。\n- 循环结束后查看是否还可以进行松弛，如果仍然可以，则存在负环。\n\n## 算法实现\n```cpp\nstruct Edge{\n\tint v,u;\n\tint w;\n}edge[M+1];\nbool bellman_ford(int st){  \n    for(int i = 1; i <= N; ++i)\n        dis[i] = INF;\n\tdis[st] = 0;\n    for(int i = 1; i <= N - 1; ++i)  \n        for(int j = 1; j <= M; ++j)  \n            if(dis[edge[j].v] > dis[edge[j].u] + edge[j].w){  \n                dis[edge[j].v] = dis[edge[j].u] + edge[j].w;\n            }  \n    bool flag = 1;\n    for(int i = 1; i <= edgenum; ++i)  \n    \tif(dis[edge[i].v] > dis[edge[i].u] + edge[i].w)  {\n\t\t\tflag = 0;  \n\t\t\tbreak;\n\t\t}  \n\treturn flag;  \n}  \n```\n\n## 补充一下\n对于这个算法，说的有点简略，不过仔细琢磨一下代码，也就懂了。啊哈哈哈哈。","slug":"32","published":1,"updated":"2015-10-04T08:07:42.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cifj5gkfy001ns8vngpyco0wk"},{"title":"Dijkstra算法","date":"2015-10-02T08:57:18.000Z","_content":"\n迪杰斯特拉算法是由荷兰计算机科学家狄克斯特拉于1959 年提出的，因此又叫狄克斯特拉算法。是从一个顶点到其余各顶点的最短路径算法，解决的是有向图中最短路径问题。迪杰斯特拉算法主要特点是以起始点为中心向外层层扩展，直到扩展到终点为止。\n\n说的好厉害的样子，其实就是求有向图中单源最短路径的问题。\n\n其实理解`floyd`或者贪心最小生成树后，应该很容易理解这个算法的。\n<!--more-->\n\n## 核心思路\n核心思想是引入两个向量(数组)去记录源到各点的最短距离，和该点是否被访问过。\n\n## 算法简介\n首先定义一个数组`dis[N]`表示源点到各点的距离。\n再定义一个数组`visit[N]`表示该点是否被访问。\n\n首先将源点`st`标记为访问`visit[st] := true`,然后将权值矩阵的一行`map[st]`赋值给`dis`.\n\n- 寻找`dis`中最小且未被访问过的点`k`,即`dis[k] == min{dis} && visit[k] == false`.\n- 以`k`点为中间点，根据松弛方程` dis[i]:= min{ map[st,k] + map[k,i], map[st,i] }`更新向量`dis`.\n- 将`k`点标记为访问`visit[k] := true`\n\n重复上述过程直到所有的点被标记完，或者有的点不可到达跳出循环。\n\n## 算法实现\n还是写C++吧：\n```cpp\nconst int N = 105;\nconst int INF = 0x1f1f1f1f;\n\nint map[N][N];\nint dis[N];\nbool visit[N];\n\nvoid dijkstra(int st,int n){\n\tmemset(dis,INF,sizeof(dis));\n\tmemset(visit,0,sizeof(visit));\n\tfor(int i=1;i<=n;i++){\n\t\tdis[i] = map[st][i];\n\t}\n\tdis[st] = 0;\n\tvisit[st] = 1;\n\tint minx = INF;\n\tint index = st;\n\tfor(int i=1;i<=n;i++){\n\t\tminx = INF;\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tif(!visit[j] && dis[j] < minx){\n\t\t\t\tminx = dis[j];\n\t\t\t\tindex = j;\n\t\t\t}\n\t\t}\n\t\tif(minx == INF)\n\t\t\tbreak;\n\t\tvisit[index] = 1;\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tif(dis[j] > map[index][j] + minx){\n\t\t\t\tdis[j] = map[index][j] + minx;\n\t\t\t}\n\t\t}\n\t}\n}\n```","source":"_posts/31.md","raw":"title: Dijkstra算法\ndate: 2015-10-02 16:57:18\ncategories: 编程与算法\ntags: [最短路,ACM,图论,dijkstra]\n---\n\n迪杰斯特拉算法是由荷兰计算机科学家狄克斯特拉于1959 年提出的，因此又叫狄克斯特拉算法。是从一个顶点到其余各顶点的最短路径算法，解决的是有向图中最短路径问题。迪杰斯特拉算法主要特点是以起始点为中心向外层层扩展，直到扩展到终点为止。\n\n说的好厉害的样子，其实就是求有向图中单源最短路径的问题。\n\n其实理解`floyd`或者贪心最小生成树后，应该很容易理解这个算法的。\n<!--more-->\n\n## 核心思路\n核心思想是引入两个向量(数组)去记录源到各点的最短距离，和该点是否被访问过。\n\n## 算法简介\n首先定义一个数组`dis[N]`表示源点到各点的距离。\n再定义一个数组`visit[N]`表示该点是否被访问。\n\n首先将源点`st`标记为访问`visit[st] := true`,然后将权值矩阵的一行`map[st]`赋值给`dis`.\n\n- 寻找`dis`中最小且未被访问过的点`k`,即`dis[k] == min{dis} && visit[k] == false`.\n- 以`k`点为中间点，根据松弛方程` dis[i]:= min{ map[st,k] + map[k,i], map[st,i] }`更新向量`dis`.\n- 将`k`点标记为访问`visit[k] := true`\n\n重复上述过程直到所有的点被标记完，或者有的点不可到达跳出循环。\n\n## 算法实现\n还是写C++吧：\n```cpp\nconst int N = 105;\nconst int INF = 0x1f1f1f1f;\n\nint map[N][N];\nint dis[N];\nbool visit[N];\n\nvoid dijkstra(int st,int n){\n\tmemset(dis,INF,sizeof(dis));\n\tmemset(visit,0,sizeof(visit));\n\tfor(int i=1;i<=n;i++){\n\t\tdis[i] = map[st][i];\n\t}\n\tdis[st] = 0;\n\tvisit[st] = 1;\n\tint minx = INF;\n\tint index = st;\n\tfor(int i=1;i<=n;i++){\n\t\tminx = INF;\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tif(!visit[j] && dis[j] < minx){\n\t\t\t\tminx = dis[j];\n\t\t\t\tindex = j;\n\t\t\t}\n\t\t}\n\t\tif(minx == INF)\n\t\t\tbreak;\n\t\tvisit[index] = 1;\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tif(dis[j] > map[index][j] + minx){\n\t\t\t\tdis[j] = map[index][j] + minx;\n\t\t\t}\n\t\t}\n\t}\n}\n```","slug":"31","published":1,"updated":"2015-10-02T09:16:00.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cifj5gkg1001us8vnuoqdatfb"},{"title":"Floyd算法","date":"2015-10-02T07:00:54.000Z","_content":"\n`Floyd`算法又称为插点法，是一种用于寻找给定的加权图中多源点之间最短路径的算法。\n\n此算法由Robert W. Floyd（罗伯特·弗洛伊德）于1962年发表在“Communications of the ACM”上。同年Stephen Warshall（史蒂芬·沃舍尔）也独立发表了这个算法。Robert W．Floyd这个牛人是朵奇葩，他原本在芝加哥大学读的文学，但是因为当时美国经济不太景气，找工作比较困难，无奈之下到西屋电气公司当了一名计算机操作员，在IBM650机房值夜班，并由此开始了他的计算机生涯。\n\n<!--more-->\n\n## 核心思路\n\n`Floyd`是通过权值矩阵得到各个节点之间最短路径的方法。他的核心思路就是一个松弛方程：\n```\n map[i,j]:= min{ map[i,k] + map[k,j], map[i,j] }\n```\n`map[i,j]`表示`i`与`j`之间的路径权值。\n\n枚举所有的节点`k 1->n`，将该节点(`k`)当成任意两点(`i 1->n , j 1->n`)的中间节点，判断是否会降低路径的权值(`map[i,j],map[i,k]+map[k,j]`)。\n\n通过这种方法枚举一遍，遍可以得到权值最小的权值矩阵了。\n\n## 算法举例\n\n有向图：\n![graph][1]\n\n然后建立一个权值矩阵：\n```\n\tA\tB\tC\tD\nA\t0\t2\t6\t4\t\nB\tx\t0\t3\tx\nC\t7\tx\t0\t1\nD\t5\tx\t12\t0\n```\n首先枚举`A`为中间点，开始进行第一轮松弛，\n之后得到新的矩阵：\n```\n0\t2\t6\t4\nx\t0\t3\tx\n7\t9\t0\t1\n5\t7\t11\t0\n```\n此时更新了`C->B`,`D->B`,`D->C`的权值。\n\n然后以`B`为中间点，继续进行松弛：\n```\n0\t2\t5\t4\nx\t0\t3\tx\n7\t9\t0\t1\n5\t7\t10\t0\n```\n以`C`为中间点，继续松弛:\n```\n0\t2\t5\t4\n10\t0\t3\t4\n7 \t9\t0\t1\n5\t7\t10\t0\n```\n最后以`D`为中间的：\n```\n0\t2\t5\t4\n9\t0\t3\t4\n6\t8\t0\t1\n5\t7\t10\t0\n```\n最后得到的新的权值矩阵就是各个节点之间的最短路径。\n\n## 算法实现\n这里就写C&&C++的吧，只有三个循环，其实很简单的：\n```cpp\nvoid floyd(int n){\n\tfor(int t=1; t<=n; t++)  \n\t\tfor(int i=1; i<=n; i++)  \n\t\t\tfor(int j=1; j<=n; j++)  \n\t\t\t\tdis[i][j]=min(dis[i][j],dis[i][t]+dis[t][j]);  \n}\n```\n[1]: http://i13.tietuku.com/12b939b983e4b7e4.png","source":"_posts/30.md","raw":"title: Floyd算法\ndate: 2015-10-02 15:00:54\ncategories: 编程与算法\ntags: [最短路,ACM,图论,floyd]\n---\n\n`Floyd`算法又称为插点法，是一种用于寻找给定的加权图中多源点之间最短路径的算法。\n\n此算法由Robert W. Floyd（罗伯特·弗洛伊德）于1962年发表在“Communications of the ACM”上。同年Stephen Warshall（史蒂芬·沃舍尔）也独立发表了这个算法。Robert W．Floyd这个牛人是朵奇葩，他原本在芝加哥大学读的文学，但是因为当时美国经济不太景气，找工作比较困难，无奈之下到西屋电气公司当了一名计算机操作员，在IBM650机房值夜班，并由此开始了他的计算机生涯。\n\n<!--more-->\n\n## 核心思路\n\n`Floyd`是通过权值矩阵得到各个节点之间最短路径的方法。他的核心思路就是一个松弛方程：\n```\n map[i,j]:= min{ map[i,k] + map[k,j], map[i,j] }\n```\n`map[i,j]`表示`i`与`j`之间的路径权值。\n\n枚举所有的节点`k 1->n`，将该节点(`k`)当成任意两点(`i 1->n , j 1->n`)的中间节点，判断是否会降低路径的权值(`map[i,j],map[i,k]+map[k,j]`)。\n\n通过这种方法枚举一遍，遍可以得到权值最小的权值矩阵了。\n\n## 算法举例\n\n有向图：\n![graph][1]\n\n然后建立一个权值矩阵：\n```\n\tA\tB\tC\tD\nA\t0\t2\t6\t4\t\nB\tx\t0\t3\tx\nC\t7\tx\t0\t1\nD\t5\tx\t12\t0\n```\n首先枚举`A`为中间点，开始进行第一轮松弛，\n之后得到新的矩阵：\n```\n0\t2\t6\t4\nx\t0\t3\tx\n7\t9\t0\t1\n5\t7\t11\t0\n```\n此时更新了`C->B`,`D->B`,`D->C`的权值。\n\n然后以`B`为中间点，继续进行松弛：\n```\n0\t2\t5\t4\nx\t0\t3\tx\n7\t9\t0\t1\n5\t7\t10\t0\n```\n以`C`为中间点，继续松弛:\n```\n0\t2\t5\t4\n10\t0\t3\t4\n7 \t9\t0\t1\n5\t7\t10\t0\n```\n最后以`D`为中间的：\n```\n0\t2\t5\t4\n9\t0\t3\t4\n6\t8\t0\t1\n5\t7\t10\t0\n```\n最后得到的新的权值矩阵就是各个节点之间的最短路径。\n\n## 算法实现\n这里就写C&&C++的吧，只有三个循环，其实很简单的：\n```cpp\nvoid floyd(int n){\n\tfor(int t=1; t<=n; t++)  \n\t\tfor(int i=1; i<=n; i++)  \n\t\t\tfor(int j=1; j<=n; j++)  \n\t\t\t\tdis[i][j]=min(dis[i][j],dis[i][t]+dis[t][j]);  \n}\n```\n[1]: http://i13.tietuku.com/12b939b983e4b7e4.png","slug":"30","published":1,"updated":"2015-10-02T10:07:27.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cifj5gkg60021s8vn3556ipze"},{"title":"初学python（一）语法","date":"2015-08-24T13:14:00.000Z","_content":"本来是想学ruby的，后来感觉到python的社区更完善一些，等对于这些脚本语言有了基础，再去学习其他。\n这次学的是python的语法。\n\n\n<!--more-->\n\n\n1、标识符：这个不用多说，和其他的语言差不多，以字母(包括下划线)开头。\n2、保留字，一般也不会触碰到的吧：\n\n    'False', 'None', 'True', 'and', 'as', 'assert', 'break', 'class', 'continue', 'def', 'del',             'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield'\n\n3、注释，单行用`#`，这个不用多说，多行用`'''`或`\"\"\"`，有点意思，不过还是可以理解的。\n4、缩进，用缩进表示代码块，还好有代码格式强迫症，要不一不留神是不是就不在同一个块中了。缩进的空格数一样的话，表示语句处于同一个代码块中。\n5、数据类型，整数、长整数、浮点数、复数。\n6、字符串，单引号和多引号完全相同、三个引号可以指定一个多行字符串、'\\'是转义字符、R或r是自然字符串、字符串是不可变的！看到这个简直毁三观，赶紧写个代码调试一下。\n\n    print (\"Hello World!\")\n    #我是单行注释\n    '''\n    我是多行注释\n    我是多行注释\n    我是多行注释\n    我是多行注释\n    '''\n    string1 = '我是单行字符串'\n    string2 = ''' 我是多行字符串\n    我是多行字符串\n    \t\t\t多行'''\n    string3 = '我是要转义的字符串\\n'\n    string4 = r'我是不想转义的字符串\\n'\n    print (string1)\n    print (string2)\n    print (string3)\n    print (string4)\n    string1 = '听说字符串是不可变的'\n    print (string1)\n输出结果：\n\n    Hello World!\n    我是单行字符串\n     我是多行字符串\n    我是多行字符串\n    \t\t\t多行\n    我是要转义的字符串\n    \n    我是不想转义的字符串\\n\n    听说字符串是不可变的\n这个不可变并不是指的不可修改，应该是修改之后生成了新的字符串。\n","source":"_posts/3.md","raw":"title: 初学python（一）语法\ndate: 2015-08-24 21:14:00\ncategories: 编程与算法\ntags: [python,编程]\n---\n本来是想学ruby的，后来感觉到python的社区更完善一些，等对于这些脚本语言有了基础，再去学习其他。\n这次学的是python的语法。\n\n\n<!--more-->\n\n\n1、标识符：这个不用多说，和其他的语言差不多，以字母(包括下划线)开头。\n2、保留字，一般也不会触碰到的吧：\n\n    'False', 'None', 'True', 'and', 'as', 'assert', 'break', 'class', 'continue', 'def', 'del',             'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield'\n\n3、注释，单行用`#`，这个不用多说，多行用`'''`或`\"\"\"`，有点意思，不过还是可以理解的。\n4、缩进，用缩进表示代码块，还好有代码格式强迫症，要不一不留神是不是就不在同一个块中了。缩进的空格数一样的话，表示语句处于同一个代码块中。\n5、数据类型，整数、长整数、浮点数、复数。\n6、字符串，单引号和多引号完全相同、三个引号可以指定一个多行字符串、'\\'是转义字符、R或r是自然字符串、字符串是不可变的！看到这个简直毁三观，赶紧写个代码调试一下。\n\n    print (\"Hello World!\")\n    #我是单行注释\n    '''\n    我是多行注释\n    我是多行注释\n    我是多行注释\n    我是多行注释\n    '''\n    string1 = '我是单行字符串'\n    string2 = ''' 我是多行字符串\n    我是多行字符串\n    \t\t\t多行'''\n    string3 = '我是要转义的字符串\\n'\n    string4 = r'我是不想转义的字符串\\n'\n    print (string1)\n    print (string2)\n    print (string3)\n    print (string4)\n    string1 = '听说字符串是不可变的'\n    print (string1)\n输出结果：\n\n    Hello World!\n    我是单行字符串\n     我是多行字符串\n    我是多行字符串\n    \t\t\t多行\n    我是要转义的字符串\n    \n    我是不想转义的字符串\\n\n    听说字符串是不可变的\n这个不可变并不是指的不可修改，应该是修改之后生成了新的字符串。\n","slug":"3","published":1,"updated":"2015-10-02T01:57:34.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cifj5gkg90028s8vnmw0es1a7"},{"title":"河海大学ACM专题第六周-最短路题解","date":"2015-10-02T02:22:23.000Z","_content":"本周题目主要是联系最短路径的几个算法。主要是`floyd`,`dijkstra`和`Bellman-Ford`,最后一题也可以用`spfa`.\n\n这些算法会重新利用其他文章去解释。\n\n简单说一下这些算法的用法。\n\n`floyd`是用来计算图中任意一点到其他点的最短路径。写起来也比较简单，时间复杂度为`O(n^3)`.\n\n`dijkstra`是计算单源最短路径的算法，也就是相当于固定了起点。所以时间复杂度降为`O(n^2)`.\n\n以上两个算法面临权值为负时便无法正常的运行下去，所以为了处理出现负环等情况。使用下面的算法。\n`Bellman-Ford`简单暴力的处理相关问题，没有做任何优化。写起来很简单，用起来也不错。时间复杂度大概为`O(ne)`.\n`spfa`一般是在上面的基础上加上了队列，有的好像加的是优先队列。反正就是效率大大提高就对了。时间复杂度为`O(ek)`.据说`k`很小。其实我并不知道有多小。\n\n<!--more-->\n\n下面来解释一下题目。\n\n## problem A poj1125\n本题是标准的弗洛伊德。题意是，在一个有向图中，找出从一个点发送消息到其他所有点耗时最小的点和时间。\n\n输入样例第一个`n`表示图中点的个数。\n然后下面有`n`行数，第`i`行第一个数`m`表示：第`i`个点的出度为`m`。然后`m`后面有`m`对数，每对数有两个值`(x,v)`，表示`i -> x`的耗时为`v`。\n\n输入完成后就可以建立一个有向图。然后对这个图使用`Floyd`,就可以得到每个点到其他点的最短路径。\n\n然后使用双重循环去找到耗时最小的点和时间即可。\n\n核心就是一个`Floyd`：\n```cpp\nconst int N = 105;\nint dis[N][N];\nvoid floyd(int n){\n\tfor(int t=1; t<=n; t++)  \n\t\tfor(int i=1; i<=n; i++)  \n\t\t\tfor(int j=1; j<=n; j++)  \n\t\t\t\tdis[i][j]=min(dis[i][j],dis[i][t]+dis[t][j]);  \n}\n```\n\n## problem B poj3615\n本题同样是floyd，不过需改修改松弛方程。\n\n`dis[i][j]=min(dis[i][j],max(dis[i][t],dis[t][j]));`\n\n大概题意如下：\n\n给你n个站，有m条边，每条边有一个耗费值。\n问你如果A站到B站可通，选一条路，求路径上的相邻两站的耗费值的最大值，让这个值最小，输出。\n否则输出-1.\n\n其实也就是先用`floyd`预处理，然后直接去查询。一般遇到多组查询都可以考虑先预处理然后离线查询。\n\n## problem C poj1847\n该题就变成了单源的最短路径了，所以可以使用`dijkstra`去求解。\n\n首先解释一下题意。就是火车从一点开到另外一点。在中途会经过火车站，每个站点有多个出口，\n其中有一个默认的方向，如果走默认方向则不需要消耗，如果走其他方向便需要进行一次切换。\n问最少切换几次可以到达终点。到不了输出`-1`.\n\n这道题可以进行一些理解，就是，默认方向权值为0，而其他方向权值为1.构造一个有向图。\n\n输入`n a b`,`n`表示车站数，`a`表示出发站点，`b`表示终点。\n下面有`n`行，每行第一个数为`m`,后面紧跟`m`个数，其中第一个是默认方向，其他为需要切换的方向。\n\n根据输入建立了有向图。然后对图使用`dijkstra`，最后得到最短路径。\n\n代码也不难，注意初始化就好。\n```cpp\nconst int N = 105;\nconst int INF = 0x1f1f1f1f;\n\nint map[N][N];\nint dis[N];\nbool visit[N];\n\nvoid dijkstra(int st,int n){\n\tmemset(dis,INF,sizeof(dis));\n\tmemset(visit,0,sizeof(visit));\n\tfor(int i=1;i<=n;i++){\n\t\tdis[i] = map[st][i];\n\t}\n\tdis[st] = 0;\n\tvisit[st] = 1;\n\tint minx = INF;\n\tint index = st;\n\tfor(int i=1;i<=n;i++){\n\t\tminx = INF;\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tif(!visit[j] && dis[j] < minx){\n\t\t\t\tminx = dis[j];\n\t\t\t\tindex = j;\n\t\t\t}\n\t\t}\n\t\tif(minx == INF)\n\t\t\tbreak;\n\t\tvisit[index] = 1;\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tif(dis[j] > map[index][j] + minx){\n\t\t\t\tdis[j] = map[index][j] + minx;\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n##　problem D poj1502\n这道题也是一个普通的`dijkstra`,具体题意同`problem A`,只不过变成单源的了。但是因为数据并不强所以用`floyd`同样可以过。\n\n输入的不是常规输入，而是直接按照邻接三角矩阵给出(`x`表示正无穷)。例如：\n```cpp\n0   50 30 100 10\n50  0  5  20  x\n30  5  0  50  x\n100 20 50 0   10\n10  x  x  10  0\n```\n输入中把`0`忽略。\n\n还有就是在杭电平台是可以使用`atoi()`函数的，所以不要定义和他名字相同的函数，否则会`RE`。\n\n## problem E poj1860\n本题就是会出现负环(正环)的题目，好像用`dijkstra`加上优化也可以过，不过更通用的还是用`Bellman-Ford`或`spfa`。\n\n本体大意为：有`n`种货币(点)和2*`m`个货币兑换点(边)，边`(a -> b)`的权值为`(V-Cab) × Rab`.我们需要找到是否存在一种兑换使我们的本金不断增加。\n\n其实就是找到一个不断增加的回路，也就是说找到权值最大路径。如果经过`n-1`次循环后，仍然满足松弛条件，则该图存在负环(正环)。也就是满足我们需要的条件，输出`YES`.\n\n大概就是这个样子的。具体算法详见其他文章。","source":"_posts/29.md","raw":"title: 河海大学ACM专题第六周-最短路题解\ndate: 2015-10-02 10:22:23\ncategories: 编程与算法\ntags: [最短路,ACM,图论]\n---\n本周题目主要是联系最短路径的几个算法。主要是`floyd`,`dijkstra`和`Bellman-Ford`,最后一题也可以用`spfa`.\n\n这些算法会重新利用其他文章去解释。\n\n简单说一下这些算法的用法。\n\n`floyd`是用来计算图中任意一点到其他点的最短路径。写起来也比较简单，时间复杂度为`O(n^3)`.\n\n`dijkstra`是计算单源最短路径的算法，也就是相当于固定了起点。所以时间复杂度降为`O(n^2)`.\n\n以上两个算法面临权值为负时便无法正常的运行下去，所以为了处理出现负环等情况。使用下面的算法。\n`Bellman-Ford`简单暴力的处理相关问题，没有做任何优化。写起来很简单，用起来也不错。时间复杂度大概为`O(ne)`.\n`spfa`一般是在上面的基础上加上了队列，有的好像加的是优先队列。反正就是效率大大提高就对了。时间复杂度为`O(ek)`.据说`k`很小。其实我并不知道有多小。\n\n<!--more-->\n\n下面来解释一下题目。\n\n## problem A poj1125\n本题是标准的弗洛伊德。题意是，在一个有向图中，找出从一个点发送消息到其他所有点耗时最小的点和时间。\n\n输入样例第一个`n`表示图中点的个数。\n然后下面有`n`行数，第`i`行第一个数`m`表示：第`i`个点的出度为`m`。然后`m`后面有`m`对数，每对数有两个值`(x,v)`，表示`i -> x`的耗时为`v`。\n\n输入完成后就可以建立一个有向图。然后对这个图使用`Floyd`,就可以得到每个点到其他点的最短路径。\n\n然后使用双重循环去找到耗时最小的点和时间即可。\n\n核心就是一个`Floyd`：\n```cpp\nconst int N = 105;\nint dis[N][N];\nvoid floyd(int n){\n\tfor(int t=1; t<=n; t++)  \n\t\tfor(int i=1; i<=n; i++)  \n\t\t\tfor(int j=1; j<=n; j++)  \n\t\t\t\tdis[i][j]=min(dis[i][j],dis[i][t]+dis[t][j]);  \n}\n```\n\n## problem B poj3615\n本题同样是floyd，不过需改修改松弛方程。\n\n`dis[i][j]=min(dis[i][j],max(dis[i][t],dis[t][j]));`\n\n大概题意如下：\n\n给你n个站，有m条边，每条边有一个耗费值。\n问你如果A站到B站可通，选一条路，求路径上的相邻两站的耗费值的最大值，让这个值最小，输出。\n否则输出-1.\n\n其实也就是先用`floyd`预处理，然后直接去查询。一般遇到多组查询都可以考虑先预处理然后离线查询。\n\n## problem C poj1847\n该题就变成了单源的最短路径了，所以可以使用`dijkstra`去求解。\n\n首先解释一下题意。就是火车从一点开到另外一点。在中途会经过火车站，每个站点有多个出口，\n其中有一个默认的方向，如果走默认方向则不需要消耗，如果走其他方向便需要进行一次切换。\n问最少切换几次可以到达终点。到不了输出`-1`.\n\n这道题可以进行一些理解，就是，默认方向权值为0，而其他方向权值为1.构造一个有向图。\n\n输入`n a b`,`n`表示车站数，`a`表示出发站点，`b`表示终点。\n下面有`n`行，每行第一个数为`m`,后面紧跟`m`个数，其中第一个是默认方向，其他为需要切换的方向。\n\n根据输入建立了有向图。然后对图使用`dijkstra`，最后得到最短路径。\n\n代码也不难，注意初始化就好。\n```cpp\nconst int N = 105;\nconst int INF = 0x1f1f1f1f;\n\nint map[N][N];\nint dis[N];\nbool visit[N];\n\nvoid dijkstra(int st,int n){\n\tmemset(dis,INF,sizeof(dis));\n\tmemset(visit,0,sizeof(visit));\n\tfor(int i=1;i<=n;i++){\n\t\tdis[i] = map[st][i];\n\t}\n\tdis[st] = 0;\n\tvisit[st] = 1;\n\tint minx = INF;\n\tint index = st;\n\tfor(int i=1;i<=n;i++){\n\t\tminx = INF;\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tif(!visit[j] && dis[j] < minx){\n\t\t\t\tminx = dis[j];\n\t\t\t\tindex = j;\n\t\t\t}\n\t\t}\n\t\tif(minx == INF)\n\t\t\tbreak;\n\t\tvisit[index] = 1;\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tif(dis[j] > map[index][j] + minx){\n\t\t\t\tdis[j] = map[index][j] + minx;\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n##　problem D poj1502\n这道题也是一个普通的`dijkstra`,具体题意同`problem A`,只不过变成单源的了。但是因为数据并不强所以用`floyd`同样可以过。\n\n输入的不是常规输入，而是直接按照邻接三角矩阵给出(`x`表示正无穷)。例如：\n```cpp\n0   50 30 100 10\n50  0  5  20  x\n30  5  0  50  x\n100 20 50 0   10\n10  x  x  10  0\n```\n输入中把`0`忽略。\n\n还有就是在杭电平台是可以使用`atoi()`函数的，所以不要定义和他名字相同的函数，否则会`RE`。\n\n## problem E poj1860\n本题就是会出现负环(正环)的题目，好像用`dijkstra`加上优化也可以过，不过更通用的还是用`Bellman-Ford`或`spfa`。\n\n本体大意为：有`n`种货币(点)和2*`m`个货币兑换点(边)，边`(a -> b)`的权值为`(V-Cab) × Rab`.我们需要找到是否存在一种兑换使我们的本金不断增加。\n\n其实就是找到一个不断增加的回路，也就是说找到权值最大路径。如果经过`n-1`次循环后，仍然满足松弛条件，则该图存在负环(正环)。也就是满足我们需要的条件，输出`YES`.\n\n大概就是这个样子的。具体算法详见其他文章。","slug":"29","published":1,"updated":"2015-10-02T08:53:57.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cifj5gkgc002es8vnyz6nm0b7"},{"title":"nginx+uwsgi+django部署","date":"2015-09-15T23:35:29.000Z","_content":"关于如何在生产服务器上部署nginx+uwsgi+django，最近遇到了不少坑啊，不过总算解决了，不用通过开发服务器进行访问了。\n下面就把最近遇到的坑说一说，同时捋一遍流程。\n\n<!--more-->\n\n声明，所有操作实在ubuntu服务器上进行的。\n\n## django\n### 安装django\n```\nsudo pip install django\nsudo easy_install django\n```\n以上两种方法都可以，建议不要用`apt-get`那个版本太低了，会出现不可预计的错误。\n\n### 创建django项目\n在目录`/root/dev/`下面执行命令\n```\ndjango-admin startproject myproject\n```\n那个`myproject`换成自己的项目名.\n然后进入`／root/dev/myproject`下，创建一个应用\n```\npython manage.py startapp myapp\n```\n然后就是编写`djiango`的代码了。这里就不多说了。网上很多教程的。\n\n### 使用开发服务器运行\n\n关于如何调试django项目，只要在`／root/dev/myproject`下执行\n```\npython manage.py runserver 0.0.0.0:8000\n```\n\n## uwsgi\n### 安装uwsgi\n```\nsudo apt-get install python-dev\nsudo pip install uwsgi \n```\n建议也不要使用`apt-get`那个版本也是过低，出现了不可预知的错误。\n\n### 运行uwsgi\n然后在`app`目录下创建一个文件`wsgi.py`，即`／root/dev/myproject/myapp/wsgi.py`\n在文件中写入：\n```\nimport os\n\nfrom django.core.wsgi import get_wsgi_application\nos.environ.setdefault(\"DJANGO_SETTINGS_MODULE\", \"myproject.settings\")\napplication = get_wsgi_application()\n```\n注意要修改你的项目名。\n完成后，便可以通过`uwsgi`去跑`django`\n```\nuwsgi --http :8000 --chdir /root/dev/myproject  --module myapp.wsgi\n```\n当我们访问网站的时候发现我们的静态资源全部找不到了，这里我们就要用到`nginx`了。\n当然我们之后要使用`unix socket`去代替它的端口，因为它要和`nginx`进行通信。\n\n## nginx\n### 安装nginx\n```\nsudo apt-get install nginx\n```\n安装完成后可以访问`127.0.0.1`来查看是否启动。\n\n### 配置文件\n然后在项目的根目录`/root/dev/myproject/`下建立一个`nginx`的配置文件`myproject.conf`,在配置文件中写入:\n```\n# myproject.conf\n# @InnerAc\n\n# the upstream component nginx needs to connect to\nupstream myproject {\n    server unix:///root/dev/myproject/myapp.sock; # for a file socket\n    # server 127.0.0.1:8001; # for a web port socket (we'll use this first)\n}\n\n# configuration of the server\nserver {\n    # the port your site will be served on\n    listen      8000;\n    # the domain name it will serve for\n    server_name 127.0.0.1; # substitute your machine's IP address or FQDN\n    charset     utf-8;\n\n    # max upload size\n    client_max_body_size 75M;   # adjust to taste\n\n    # Django media\n    location /media  {\n        alias /root/dev/myproject/media;  # your Django project's media files - amend as required\n    }\n\n    location /static {\n        alias /root/dev/myproject/static; # your Django project's static files - amend as required\n    }\n\n    # Finally, send all non-media requests to the Django server.\n    location / {\n        uwsgi_pass  myproject;\n        include uwsgi_params; # the uwsgi_params file you installed\n    }\n\n}\n```\n需要修改哪里，大家应该也能看的出来，然后将这个配置文件复制或者软链接到`/etc/nginx/sites-enabled`下。我是复制的，因为我软链接过去好像有时有用，有时没用。\n```\nsudo ln -s /root/dev/myproject/myproject.conf /etc/nginx/sites-enabled\n或者\nsudo cp /root/dev/myproject/myproject.conf /etc/nginx/sites-enabled\n```\n然后重启`nginx`\n```\nsudo /etc/init.d/nginx restart\n```\n## Start\n\n配置好`nginx`后，通过上面那个`socket`去启动`uwsgi`\n```\nuwsgi --socket myapp.sock  --module myapp.wsgi --chmod-socket=666\n```\n一定要给`666`权限，否则会报错的。报错信息在`/var/log/nginx/error.log`查看。\n至此我们的生产服务器就部署完成了。\n当然，也可以写一个`xml`文件来方便启动。\n\n### xml启动uwsgi\n创建一个`django.xml`在项目根目录下：\n```\n<uwsgi>\n    <socket>/root/dev/myproject/myapp.sock</socket>\n    <chdir>/root/dev/myproject</chdir>\n    <module>myapp.wsgi</module>\n    <chmod>666</chmod>\n</uwsgi>\n```\n然后通过:\n```\nuwsgi -x django.xml\n```\n启动。\n\n### PS\n有人说，一定要用sock么？，我的回答是，可以不用，如果不用的话，仍然可以访问网站，但是你可以看一下你的静态资源的地址是不是就变了。","source":"_posts/28.md","raw":"title: nginx+uwsgi+django部署\ndate: 2015-09-16 07:35:29\ncategories: 日常维护\ntags: [django,uwsgi,nginx]\n---\n关于如何在生产服务器上部署nginx+uwsgi+django，最近遇到了不少坑啊，不过总算解决了，不用通过开发服务器进行访问了。\n下面就把最近遇到的坑说一说，同时捋一遍流程。\n\n<!--more-->\n\n声明，所有操作实在ubuntu服务器上进行的。\n\n## django\n### 安装django\n```\nsudo pip install django\nsudo easy_install django\n```\n以上两种方法都可以，建议不要用`apt-get`那个版本太低了，会出现不可预计的错误。\n\n### 创建django项目\n在目录`/root/dev/`下面执行命令\n```\ndjango-admin startproject myproject\n```\n那个`myproject`换成自己的项目名.\n然后进入`／root/dev/myproject`下，创建一个应用\n```\npython manage.py startapp myapp\n```\n然后就是编写`djiango`的代码了。这里就不多说了。网上很多教程的。\n\n### 使用开发服务器运行\n\n关于如何调试django项目，只要在`／root/dev/myproject`下执行\n```\npython manage.py runserver 0.0.0.0:8000\n```\n\n## uwsgi\n### 安装uwsgi\n```\nsudo apt-get install python-dev\nsudo pip install uwsgi \n```\n建议也不要使用`apt-get`那个版本也是过低，出现了不可预知的错误。\n\n### 运行uwsgi\n然后在`app`目录下创建一个文件`wsgi.py`，即`／root/dev/myproject/myapp/wsgi.py`\n在文件中写入：\n```\nimport os\n\nfrom django.core.wsgi import get_wsgi_application\nos.environ.setdefault(\"DJANGO_SETTINGS_MODULE\", \"myproject.settings\")\napplication = get_wsgi_application()\n```\n注意要修改你的项目名。\n完成后，便可以通过`uwsgi`去跑`django`\n```\nuwsgi --http :8000 --chdir /root/dev/myproject  --module myapp.wsgi\n```\n当我们访问网站的时候发现我们的静态资源全部找不到了，这里我们就要用到`nginx`了。\n当然我们之后要使用`unix socket`去代替它的端口，因为它要和`nginx`进行通信。\n\n## nginx\n### 安装nginx\n```\nsudo apt-get install nginx\n```\n安装完成后可以访问`127.0.0.1`来查看是否启动。\n\n### 配置文件\n然后在项目的根目录`/root/dev/myproject/`下建立一个`nginx`的配置文件`myproject.conf`,在配置文件中写入:\n```\n# myproject.conf\n# @InnerAc\n\n# the upstream component nginx needs to connect to\nupstream myproject {\n    server unix:///root/dev/myproject/myapp.sock; # for a file socket\n    # server 127.0.0.1:8001; # for a web port socket (we'll use this first)\n}\n\n# configuration of the server\nserver {\n    # the port your site will be served on\n    listen      8000;\n    # the domain name it will serve for\n    server_name 127.0.0.1; # substitute your machine's IP address or FQDN\n    charset     utf-8;\n\n    # max upload size\n    client_max_body_size 75M;   # adjust to taste\n\n    # Django media\n    location /media  {\n        alias /root/dev/myproject/media;  # your Django project's media files - amend as required\n    }\n\n    location /static {\n        alias /root/dev/myproject/static; # your Django project's static files - amend as required\n    }\n\n    # Finally, send all non-media requests to the Django server.\n    location / {\n        uwsgi_pass  myproject;\n        include uwsgi_params; # the uwsgi_params file you installed\n    }\n\n}\n```\n需要修改哪里，大家应该也能看的出来，然后将这个配置文件复制或者软链接到`/etc/nginx/sites-enabled`下。我是复制的，因为我软链接过去好像有时有用，有时没用。\n```\nsudo ln -s /root/dev/myproject/myproject.conf /etc/nginx/sites-enabled\n或者\nsudo cp /root/dev/myproject/myproject.conf /etc/nginx/sites-enabled\n```\n然后重启`nginx`\n```\nsudo /etc/init.d/nginx restart\n```\n## Start\n\n配置好`nginx`后，通过上面那个`socket`去启动`uwsgi`\n```\nuwsgi --socket myapp.sock  --module myapp.wsgi --chmod-socket=666\n```\n一定要给`666`权限，否则会报错的。报错信息在`/var/log/nginx/error.log`查看。\n至此我们的生产服务器就部署完成了。\n当然，也可以写一个`xml`文件来方便启动。\n\n### xml启动uwsgi\n创建一个`django.xml`在项目根目录下：\n```\n<uwsgi>\n    <socket>/root/dev/myproject/myapp.sock</socket>\n    <chdir>/root/dev/myproject</chdir>\n    <module>myapp.wsgi</module>\n    <chmod>666</chmod>\n</uwsgi>\n```\n然后通过:\n```\nuwsgi -x django.xml\n```\n启动。\n\n### PS\n有人说，一定要用sock么？，我的回答是，可以不用，如果不用的话，仍然可以访问网站，但是你可以看一下你的静态资源的地址是不是就变了。","slug":"28","published":1,"updated":"2015-10-02T01:57:34.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cifj5gkgh002js8vnbhht3ss2"},{"title":"个人简历","date":"2015-09-15T04:31:50.000Z","_content":"\n### <center>安纪存简历<center>\n\n<!--more-->\n\n### 个人信息\n\n- 安纪存/男/1994\n- 河海大学-计算机科学与技术\n- 个人主页: http://www.eternalac.com\n- 博客主页: http://innerac.github.io\n- Github: http://github.com/innerac\n- 手机：13222765139\n- Email：anjicun@live.com\n\n---\n### 个人自述\n将在2016年毕业于河海大学计算机科学与技术专业，逻辑性强，有一定的算法与数据结构基础,现为河海大学ACM第一梯队,编码能力较强，阅读过多篇英文文献，，喜欢动手实现一些技术，参加过多个团队项目，有很强的团队意识和责任心，为人坦诚、乐观、吃苦耐劳、待人和善，人际关系良好，具有一定创新意识。\n\n---\n### 竞赛经历\n\n#### 中国大学生服务外包创新创业大赛 （ 2015年6月 ~ 2015年8月 ）\n\n##### 获得奖项 \n- 全国三等奖\n\n##### 比赛题目 \n- 虚拟学习社区\n\n##### 个人负责\n- 后台数据库逻辑编写\n- 在线运行java模块编写\n- 图片及视频资源的IO\n\n#### 全国高校云计算应用大赛 （ 2014年11月 ~ 2015年4月 ）\n\n##### 比赛题目\n- 电商图片云\n\n##### 获得奖项 \n- 全国二等奖\n- 投递专利《基于浏览器的高清图片切割和展示》\n- 投递专利《基于Mapfile海量小图片存储》\n##### 个人负责 \n- 图片的编辑处理（基于`GraphicsMagick`）\n- 基于R-Tree的高清图片裁剪与展示\n- 后台重复性代码编写\n\n\n#### 全国大学生计算机设计大赛 （ 2015年4月 ~ 2015年8月 ）\n\n##### 获得奖项 \n- 全国一等奖\n\n##### 个人负责 \n- 图片的编辑处理（基于`GraphicsMagick`）\n- 基于R-Tree的高清图片裁剪与展示\n- 后台重复性代码编写\n\n#### 全国高校云计算应用大赛 （ 2014年11月 ~ 2015年4月 ）\n\n##### 比赛题目\n- 电商图片云\n\n##### 获得奖项 \n- 全国二等奖\n- 投递专利《基于浏览器的高清图片切割和展示》\n- 投递专利《基于Mapfile海量小图片存储》\n##### 个人负责 \n- 图片的编辑处理（基于`GraphicsMagick`）\n- 基于R-Tree的高清图片裁剪与展示\n- 后台重复性代码编写\n\n#### ACM-ICPC亚洲区域赛 （ 2014年10月 ）\n\n##### 获得奖项 \n- 西安站铜牌\n\n#### 中国软件杯 （ 2014年5月 ~ 2014年8月 ）\n\n##### 比赛题目\n- 含百万/千万图元的可缩放矢量图形(SVG)的优化显示和处理\n\n##### 获得奖项 \n- 全国三等奖\n##### 个人负责 \n- 基于R-Tree的图元缩放\n\n---\n\n### 个人技能\n\n#### 开发平台\n\n- `ubuntu(Linux)`\n- `windows`\n\n#### 编程语言\n\n- `C&C++` (主要用来进行写算法或者进行信息学竞赛)\n- `Java` (主要用来进行项目编写)\n\n#### 涉猎技能\n\n- `python`\n- `neo4j`\n- `Android`\n- `ruby`\n\n---\n\n### 成长经历\n\n从大学开始接触计算机编程，第一学期学校教授了C语言。大一寒假自学java，并且使用swing写了一个超级玛丽小游戏。大一暑假自学安卓，尝试写了课程表应用。大二开始接触算法与数据结构，并且从寒假开始在poj和hdoj上进行A题，同时开始接触Linux系统。大二下学期入选学校ACM训练队，在大二暑假开始代表学校出去进行比赛。同时在大二暑假使用QT5和VS编写了图形化抓取学校教务系统成绩信息并且计算绩点的小程序。还跟随社区人员简单学习了Ruby脚本，写出了暴力破解教务系统密码的并发脚本。大三时，开始跟随学长学习关于自适应技术的知识，在期间阅读了多篇英文文献，养成了查阅文献的习惯，而不是依靠搜索引擎。\n\n---\n### 自我评价\n\n对于不了解的知识充满了渴望，希望能通过自己的努力获得这些知识和技术，同时能够通过编码实现。能够熟练的科学上网并且使用搜素引擎来准确获取有用的资料。自认为拥有较强的自学能力，和极限编程精神。\n","source":"_posts/27.md","raw":"title: 个人简历\ndate: 2015-09-15 12:31:50\ncategories: [点点滴滴]\ntags: [innerac,aboutme]\n---\n\n### <center>安纪存简历<center>\n\n<!--more-->\n\n### 个人信息\n\n- 安纪存/男/1994\n- 河海大学-计算机科学与技术\n- 个人主页: http://www.eternalac.com\n- 博客主页: http://innerac.github.io\n- Github: http://github.com/innerac\n- 手机：13222765139\n- Email：anjicun@live.com\n\n---\n### 个人自述\n将在2016年毕业于河海大学计算机科学与技术专业，逻辑性强，有一定的算法与数据结构基础,现为河海大学ACM第一梯队,编码能力较强，阅读过多篇英文文献，，喜欢动手实现一些技术，参加过多个团队项目，有很强的团队意识和责任心，为人坦诚、乐观、吃苦耐劳、待人和善，人际关系良好，具有一定创新意识。\n\n---\n### 竞赛经历\n\n#### 中国大学生服务外包创新创业大赛 （ 2015年6月 ~ 2015年8月 ）\n\n##### 获得奖项 \n- 全国三等奖\n\n##### 比赛题目 \n- 虚拟学习社区\n\n##### 个人负责\n- 后台数据库逻辑编写\n- 在线运行java模块编写\n- 图片及视频资源的IO\n\n#### 全国高校云计算应用大赛 （ 2014年11月 ~ 2015年4月 ）\n\n##### 比赛题目\n- 电商图片云\n\n##### 获得奖项 \n- 全国二等奖\n- 投递专利《基于浏览器的高清图片切割和展示》\n- 投递专利《基于Mapfile海量小图片存储》\n##### 个人负责 \n- 图片的编辑处理（基于`GraphicsMagick`）\n- 基于R-Tree的高清图片裁剪与展示\n- 后台重复性代码编写\n\n\n#### 全国大学生计算机设计大赛 （ 2015年4月 ~ 2015年8月 ）\n\n##### 获得奖项 \n- 全国一等奖\n\n##### 个人负责 \n- 图片的编辑处理（基于`GraphicsMagick`）\n- 基于R-Tree的高清图片裁剪与展示\n- 后台重复性代码编写\n\n#### 全国高校云计算应用大赛 （ 2014年11月 ~ 2015年4月 ）\n\n##### 比赛题目\n- 电商图片云\n\n##### 获得奖项 \n- 全国二等奖\n- 投递专利《基于浏览器的高清图片切割和展示》\n- 投递专利《基于Mapfile海量小图片存储》\n##### 个人负责 \n- 图片的编辑处理（基于`GraphicsMagick`）\n- 基于R-Tree的高清图片裁剪与展示\n- 后台重复性代码编写\n\n#### ACM-ICPC亚洲区域赛 （ 2014年10月 ）\n\n##### 获得奖项 \n- 西安站铜牌\n\n#### 中国软件杯 （ 2014年5月 ~ 2014年8月 ）\n\n##### 比赛题目\n- 含百万/千万图元的可缩放矢量图形(SVG)的优化显示和处理\n\n##### 获得奖项 \n- 全国三等奖\n##### 个人负责 \n- 基于R-Tree的图元缩放\n\n---\n\n### 个人技能\n\n#### 开发平台\n\n- `ubuntu(Linux)`\n- `windows`\n\n#### 编程语言\n\n- `C&C++` (主要用来进行写算法或者进行信息学竞赛)\n- `Java` (主要用来进行项目编写)\n\n#### 涉猎技能\n\n- `python`\n- `neo4j`\n- `Android`\n- `ruby`\n\n---\n\n### 成长经历\n\n从大学开始接触计算机编程，第一学期学校教授了C语言。大一寒假自学java，并且使用swing写了一个超级玛丽小游戏。大一暑假自学安卓，尝试写了课程表应用。大二开始接触算法与数据结构，并且从寒假开始在poj和hdoj上进行A题，同时开始接触Linux系统。大二下学期入选学校ACM训练队，在大二暑假开始代表学校出去进行比赛。同时在大二暑假使用QT5和VS编写了图形化抓取学校教务系统成绩信息并且计算绩点的小程序。还跟随社区人员简单学习了Ruby脚本，写出了暴力破解教务系统密码的并发脚本。大三时，开始跟随学长学习关于自适应技术的知识，在期间阅读了多篇英文文献，养成了查阅文献的习惯，而不是依靠搜索引擎。\n\n---\n### 自我评价\n\n对于不了解的知识充满了渴望，希望能通过自己的努力获得这些知识和技术，同时能够通过编码实现。能够熟练的科学上网并且使用搜素引擎来准确获取有用的资料。自认为拥有较强的自学能力，和极限编程精神。\n","slug":"27","published":1,"updated":"2015-10-02T01:57:34.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cifj5gkgk002rs8vnleo7wc7c"},{"title":"ubuntu+hexo搭建github博客","date":"2015-08-25T23:44:08.000Z","_content":"本来博客是使用阿里云的虚拟主机通过`typecho`搭建的，不过后来担心域名和主机到期的续费问题（还是穷学生），所以决定专向`github`。\n\n经过多方面的比较，最终决定使用hexo来生成静态页面。现在主要介绍一下在ubuntu先如何进行配置和部署。\n\n<!--more-->\n## 安装nodejs\n首先安装`nodejs`。有两个方法可以进行安装。\n### apt-get安装\n一个是通过ubuntu自带的包管理进行安装。不过它自带的版本可能过低，所以需要添加源：\n```shell\nsudo add-apt-repository ppa:chris-lea/node.js\nsudo apt-get update\nsudo apt-get install nodejs\n```\n同时安装所需要的依赖即可。\n\n### nvm安装\n据说这个是官方推荐的安装方法。首先你要有shell下的下载工具`curl`或者`wget`。\n然后安装`nvm`,下面两天命令二选一即可。\n```shell\ncurl https://raw.github.com/creationix/nvm/master/install.sh | sh  \nwget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh\n```\n\n等待`nvm`安装之后，然后安装`nodejs`，可以通过`nvm ls`查看版本。\n```shell\nnvm install 0.10\n```\n\n## 安装hexo\n安装完`nodejs`后就要安装`hexo`了。首先全局安装：\n```shell\nnpm install -g hexo\n```\n安装完后就可以进行部署写作了。\n首先创建一个hexo博客\n```shell\nhexo init blog_name\n```\n如果这里报错`node command not found`，那就创建一个`nodejs`到`node`的软链接：\n```shell\nsudo ln -s /usr/bin/nodejs /usr/bin/node\n```\n貌似现在`hexo-server`与`hexo`分离了，所以还要再装`hexo-server`\n```shell\nsudo npm install hexo-server --save\n```\n\n创建好博客后，就可以生成博客：\n```shell\nhexo g\n```\n然后启动服务(`debug`可以不用加)：\n```shell\nhexo s [--debug]\n```\n然后就可以在`4000`端口看到我们的页面了。\n关于如何创建一个新页面（`post`是页面类型，你自己创建的，可以不填）：\n```shell\nhexo new [post] page_name\n```\n然后你就可以在`source/_posts`目录下看到你的md文件，只要编写好这个md文件再次运行`hexo g`便可生成静态页面。\n\n## 上传到github\n在github首先创建一个仓库，`username.github.io`，请严格使用这样的命名。然后复制仓库地址，打开博客的根目录下的`_config.yml`文件，在`deploy`那里进行填写\n```yml\ndeploy:\n  type: git\n  repo: git@github.com:username/username.github.io.git\n  branch: master\n```\n然后运行：\n```shell\nhexo d\n```\n输入github账号和密码(只有第一次需要)。然后就完成了部署。","source":"_posts/26.md","raw":"title: ubuntu+hexo搭建github博客\ndate: 2015-08-26 07:44:08\ncategories: 日常维护\ntags: [hexo,github,blog]\n---\n本来博客是使用阿里云的虚拟主机通过`typecho`搭建的，不过后来担心域名和主机到期的续费问题（还是穷学生），所以决定专向`github`。\n\n经过多方面的比较，最终决定使用hexo来生成静态页面。现在主要介绍一下在ubuntu先如何进行配置和部署。\n\n<!--more-->\n## 安装nodejs\n首先安装`nodejs`。有两个方法可以进行安装。\n### apt-get安装\n一个是通过ubuntu自带的包管理进行安装。不过它自带的版本可能过低，所以需要添加源：\n```shell\nsudo add-apt-repository ppa:chris-lea/node.js\nsudo apt-get update\nsudo apt-get install nodejs\n```\n同时安装所需要的依赖即可。\n\n### nvm安装\n据说这个是官方推荐的安装方法。首先你要有shell下的下载工具`curl`或者`wget`。\n然后安装`nvm`,下面两天命令二选一即可。\n```shell\ncurl https://raw.github.com/creationix/nvm/master/install.sh | sh  \nwget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh\n```\n\n等待`nvm`安装之后，然后安装`nodejs`，可以通过`nvm ls`查看版本。\n```shell\nnvm install 0.10\n```\n\n## 安装hexo\n安装完`nodejs`后就要安装`hexo`了。首先全局安装：\n```shell\nnpm install -g hexo\n```\n安装完后就可以进行部署写作了。\n首先创建一个hexo博客\n```shell\nhexo init blog_name\n```\n如果这里报错`node command not found`，那就创建一个`nodejs`到`node`的软链接：\n```shell\nsudo ln -s /usr/bin/nodejs /usr/bin/node\n```\n貌似现在`hexo-server`与`hexo`分离了，所以还要再装`hexo-server`\n```shell\nsudo npm install hexo-server --save\n```\n\n创建好博客后，就可以生成博客：\n```shell\nhexo g\n```\n然后启动服务(`debug`可以不用加)：\n```shell\nhexo s [--debug]\n```\n然后就可以在`4000`端口看到我们的页面了。\n关于如何创建一个新页面（`post`是页面类型，你自己创建的，可以不填）：\n```shell\nhexo new [post] page_name\n```\n然后你就可以在`source/_posts`目录下看到你的md文件，只要编写好这个md文件再次运行`hexo g`便可生成静态页面。\n\n## 上传到github\n在github首先创建一个仓库，`username.github.io`，请严格使用这样的命名。然后复制仓库地址，打开博客的根目录下的`_config.yml`文件，在`deploy`那里进行填写\n```yml\ndeploy:\n  type: git\n  repo: git@github.com:username/username.github.io.git\n  branch: master\n```\n然后运行：\n```shell\nhexo d\n```\n输入github账号和密码(只有第一次需要)。然后就完成了部署。","slug":"26","published":1,"updated":"2015-10-02T01:57:34.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cifj5gkgm002ys8vnno3t7g7g"},{"title":"一个用python写的科学上网小脚本（下）","date":"2015-08-25T00:43:53.000Z","_content":"现在来填坑，把整个脚本的流程写出来。在上一部分已经得到了ss的账号密码，服务器地址，端口号和加密方式，接下来就是把这些信息转换成json然后运行即可\n\n\n<!--more-->\n\n## 生成json文件 ##\n这个转换json对于python来说是很方便的，因为，python的字典这个结构就和json是类似的。可以直接通过`json.dumps(dic)`进行转换。\n首先我们要确定json文件中有哪些内容。\n```json\n{\n    \"server\":\"US1.SSSERVER.PW\",\n    \"server_port\":8989,\n    \"local_port\":1080,\n    \"password\":\"01916771\",\n    \"timeout\":600,\n    \"method\":\"aes-256-cfb\"\n}\n```\n这是它所有的信息。我们需要自己固定的是本地端口号和超时。其他的都通过python的字典创建进去。\n还是直接上代码清楚：\n```python\ndic = {}\ndic['server'] = eval(repr(ip)[1:])\ndic['server_port'] = string.atoi(eval(repr(port)[1:]))\ndic['local_port'] = 1080\ndic['password'] = eval(repr(pwd)[1:])\ndic['timeout'] = 600\ndic['method'] = eval(repr(met)[1:])\nshadow = json.dumps(dic)\n```\n然后将得到的json保存：\n```python\nf = open('xxx.json','w')\nf.write(shadow)\nf.close()\n```\n这样我们就得到了json文件。\n## 开启ss连接 ##\n得到json文件后，我们就可以手动在终端进行ss连接了，但是人懒嘛，生成后直接连接多好。\n所以就在python中执行终端命令咯。如下：\n```python\nos.system('sslocal -c xxx.json > log')\n```\n基本上到这里就结束了。算是边学边练吧。","source":"_posts/25.md","raw":"title: 一个用python写的科学上网小脚本（下）\ncategories: 编程与算法\ndate: 2015-08-25 08:43:53\ntags: [python,ss]\n---\n现在来填坑，把整个脚本的流程写出来。在上一部分已经得到了ss的账号密码，服务器地址，端口号和加密方式，接下来就是把这些信息转换成json然后运行即可\n\n\n<!--more-->\n\n## 生成json文件 ##\n这个转换json对于python来说是很方便的，因为，python的字典这个结构就和json是类似的。可以直接通过`json.dumps(dic)`进行转换。\n首先我们要确定json文件中有哪些内容。\n```json\n{\n    \"server\":\"US1.SSSERVER.PW\",\n    \"server_port\":8989,\n    \"local_port\":1080,\n    \"password\":\"01916771\",\n    \"timeout\":600,\n    \"method\":\"aes-256-cfb\"\n}\n```\n这是它所有的信息。我们需要自己固定的是本地端口号和超时。其他的都通过python的字典创建进去。\n还是直接上代码清楚：\n```python\ndic = {}\ndic['server'] = eval(repr(ip)[1:])\ndic['server_port'] = string.atoi(eval(repr(port)[1:]))\ndic['local_port'] = 1080\ndic['password'] = eval(repr(pwd)[1:])\ndic['timeout'] = 600\ndic['method'] = eval(repr(met)[1:])\nshadow = json.dumps(dic)\n```\n然后将得到的json保存：\n```python\nf = open('xxx.json','w')\nf.write(shadow)\nf.close()\n```\n这样我们就得到了json文件。\n## 开启ss连接 ##\n得到json文件后，我们就可以手动在终端进行ss连接了，但是人懒嘛，生成后直接连接多好。\n所以就在python中执行终端命令咯。如下：\n```python\nos.system('sslocal -c xxx.json > log')\n```\n基本上到这里就结束了。算是边学边练吧。","slug":"25","published":1,"updated":"2015-10-02T01:57:34.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cifj5gkgp0036s8vn9kfbxidu"},{"title":"一个用python写的科学上网小脚本（上）","date":"2015-08-25T00:42:47.000Z","_content":"之前写过一篇科学上网的文章。关于什么是科学上网，大家都懂的。详情请见：[点我传送][1]\n但是科学上网要有ss账号啊，咱还是个穷学生，舍不得买vpn。好吧较便宜的ss账号也舍不得买。还要很多网站都提供免费的ss账号。这可是良心啊。当然啦，网站神马的就不推荐了，想用的话百度之。\n\n\n<!--more-->\n\n我们就来说说，如何不用打开网站就可完成一键获取ss账号并且完成ss连接。\n大神勿喷，这都是我自己想的，所以肯定有大神们看不上的地方，欢迎指出不足，谢谢。(毕竟刚刚接触python)\n简单来说一下实现的步骤：\n\n 1. 抓取网页\n 2. 解析网页\n 3. 得到服务器ip、端口、密码、加密方式等。\n 4. 生成json文件\n 5. 执行科学上网命令(见之前的文章 [点我传送][2])\n## 抓取网页 ##\n首先，我们应该抓取网页。这里我使用的是python的urllib2库。据说这个库很强大。\n通过这个库，使用get的方式请求了html。大部分都写了个这个函数\n```python\ndef getHtml(url):\n    page = urllib2.urlopen(url)\n    html = page.read()\n    return html\n```\n然而，当我去请求目标url的时候，并没有得到访问结果。我猜，估计是没有加浏览器头的原因吧。这真是猜的，因为好多网站防爬虫什么的会进行个判断。那我只能改进一下这个函数了，把user-agent加进去。如下：\n```python\ndef getHtml(url):\n    req = urllib2.Request(url)\n    req.add_header('User-Agent','Mozilla/5.0 (Windows NT 6.2; rv:16.0) Gecko/20100101 Firefox/16.0')\n    page = urllib2.urlopen(req)\n    html = page.read()\n    return html\n```\n再次运行脚本，成功得到html。\n这是要用到的部分：\n![aaddress.png][3]\n## 解析网页 ##\n本来想直接用正则去匹配就结束了，可是谁知道为毛成功不了。所以就用了一个看起来很吊的一个库`BeautifulSoup`，使用这个库时要先安装。\nubuntu用户直接执行`sudo apt-get install Python-bs4`即可。其他发行版的话，自行百度吧。\n导入的话就是这个咯`from bs4 import BeautifulSoup`\n然后将得到的html转换为beautifulsoup格式。同时找到相应的div\n```python\nsoup = BeautifulSoup(html)\ndiv = soup.find('div',{'class':\"col-lg-4 text-center\"})\nhfs = div.findAll('h4')\n```\n`find`就是找到第一个，`findAll`就是找到所有的然后返回一个list\n这样我们就得到包含所有想要信息的list啦。\n`hfs[i].string`就可以得到想要的字符串了。\n不过它的字符串还包括前面的说明，所以要通过正则过滤掉。\n正则如下：\n`regexAll = r'\\:(.*)'`就是把`:`后面的字符留下啦。\n比如：\n`port = re.search(regexAll,hfs[1].string).group(1)`\n就可以得到它的端口u'8989'\n因为是一个unicode所以会在前面加`u`，这个转换是我百度的，如下：\n`string.atoi(eval(repr(port)[1:]))`\n前面是用来转换为数字的，括号内是把`u`去掉的。\n现在我们已经得到所有该得到的信息了。\n后面两个先留着吧，困死了，睡午觉去。\n\n  [1]: http://www.eternalac.com/index.php/archives/7/\n  [2]: http://www.eternalac.com/index.php/archives/7/\n  [3]: http://www.eternalac.com/usr/uploads/2015/08/879485559.png","source":"_posts/24.md","raw":"title: 一个用python写的科学上网小脚本（上）\ncategories: 编程与算法\ntags: [python,ss]\ndate: 2015-08-25 08:42:47\n---\n之前写过一篇科学上网的文章。关于什么是科学上网，大家都懂的。详情请见：[点我传送][1]\n但是科学上网要有ss账号啊，咱还是个穷学生，舍不得买vpn。好吧较便宜的ss账号也舍不得买。还要很多网站都提供免费的ss账号。这可是良心啊。当然啦，网站神马的就不推荐了，想用的话百度之。\n\n\n<!--more-->\n\n我们就来说说，如何不用打开网站就可完成一键获取ss账号并且完成ss连接。\n大神勿喷，这都是我自己想的，所以肯定有大神们看不上的地方，欢迎指出不足，谢谢。(毕竟刚刚接触python)\n简单来说一下实现的步骤：\n\n 1. 抓取网页\n 2. 解析网页\n 3. 得到服务器ip、端口、密码、加密方式等。\n 4. 生成json文件\n 5. 执行科学上网命令(见之前的文章 [点我传送][2])\n## 抓取网页 ##\n首先，我们应该抓取网页。这里我使用的是python的urllib2库。据说这个库很强大。\n通过这个库，使用get的方式请求了html。大部分都写了个这个函数\n```python\ndef getHtml(url):\n    page = urllib2.urlopen(url)\n    html = page.read()\n    return html\n```\n然而，当我去请求目标url的时候，并没有得到访问结果。我猜，估计是没有加浏览器头的原因吧。这真是猜的，因为好多网站防爬虫什么的会进行个判断。那我只能改进一下这个函数了，把user-agent加进去。如下：\n```python\ndef getHtml(url):\n    req = urllib2.Request(url)\n    req.add_header('User-Agent','Mozilla/5.0 (Windows NT 6.2; rv:16.0) Gecko/20100101 Firefox/16.0')\n    page = urllib2.urlopen(req)\n    html = page.read()\n    return html\n```\n再次运行脚本，成功得到html。\n这是要用到的部分：\n![aaddress.png][3]\n## 解析网页 ##\n本来想直接用正则去匹配就结束了，可是谁知道为毛成功不了。所以就用了一个看起来很吊的一个库`BeautifulSoup`，使用这个库时要先安装。\nubuntu用户直接执行`sudo apt-get install Python-bs4`即可。其他发行版的话，自行百度吧。\n导入的话就是这个咯`from bs4 import BeautifulSoup`\n然后将得到的html转换为beautifulsoup格式。同时找到相应的div\n```python\nsoup = BeautifulSoup(html)\ndiv = soup.find('div',{'class':\"col-lg-4 text-center\"})\nhfs = div.findAll('h4')\n```\n`find`就是找到第一个，`findAll`就是找到所有的然后返回一个list\n这样我们就得到包含所有想要信息的list啦。\n`hfs[i].string`就可以得到想要的字符串了。\n不过它的字符串还包括前面的说明，所以要通过正则过滤掉。\n正则如下：\n`regexAll = r'\\:(.*)'`就是把`:`后面的字符留下啦。\n比如：\n`port = re.search(regexAll,hfs[1].string).group(1)`\n就可以得到它的端口u'8989'\n因为是一个unicode所以会在前面加`u`，这个转换是我百度的，如下：\n`string.atoi(eval(repr(port)[1:]))`\n前面是用来转换为数字的，括号内是把`u`去掉的。\n现在我们已经得到所有该得到的信息了。\n后面两个先留着吧，困死了，睡午觉去。\n\n  [1]: http://www.eternalac.com/index.php/archives/7/\n  [2]: http://www.eternalac.com/index.php/archives/7/\n  [3]: http://www.eternalac.com/usr/uploads/2015/08/879485559.png","slug":"24","published":1,"updated":"2015-10-02T01:57:34.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cifj5gkgr003as8vn02q1ohwi"},{"title":"初学python（十一）文件的读写","date":"2015-08-25T00:42:29.000Z","_content":"python的入门学习马上就进入尾声了，现在来学习文件的读写。\n\n\n<!--more-->\n\n## open() ##\n`f = open('dir\\fileName','r')`\n该函数是用来打开一个文件，其中 mode 可以是 'r' 如果文件只读, 'w' 只用于写 (如果存在同名文件则将被删除), 和 'a' 用于追加文件内容; 所写的任何数据都会被自动增加到末尾. 'r+' 同时用于读写。 mode 参数是可选的; 'r' 将是默认值。\n## 读 ##\nf.read() 表示从文件中读取n个字符。如果参数为负或者为空，则全部读取。\nf.readline() 表示从文件中读取一行，如果读取到为空的，则返回一个空字符串。\nf.readlines() 表示以list的形式返回该文件中包含的所有行。如果设置可选参数 sizehint, 则读取指定长度的字节, 并且将这些字节按行分割。\n以下是来源于网络的示例：\n```python\n>>> f.read()\n'This is the entire file.\\n'\n>>> f.read()\n''\n>>> f.readline()\n'This is the first line of the file.\\n'\n>>> f.readline()\n'Second line of the file\\n'\n>>> f.readline()\n''\n>>> f.readlines()\n['This is the first line of the file.\\n', 'Second line of the file\\n']\n```\n## 写 ##\n写的话就，简单了。\n```python\n>>> f.write('This is a test\\n')\n15\n```\n## 关 ##\n调用完成后记得关闭文件。\n```python\nf.close()\n```","source":"_posts/23.md","raw":"title: 初学python（十一）文件的读写\ncategories: 编程与算法\ntags:\n  - python\ndate: 2015-08-25 08:42:29\n---\npython的入门学习马上就进入尾声了，现在来学习文件的读写。\n\n\n<!--more-->\n\n## open() ##\n`f = open('dir\\fileName','r')`\n该函数是用来打开一个文件，其中 mode 可以是 'r' 如果文件只读, 'w' 只用于写 (如果存在同名文件则将被删除), 和 'a' 用于追加文件内容; 所写的任何数据都会被自动增加到末尾. 'r+' 同时用于读写。 mode 参数是可选的; 'r' 将是默认值。\n## 读 ##\nf.read() 表示从文件中读取n个字符。如果参数为负或者为空，则全部读取。\nf.readline() 表示从文件中读取一行，如果读取到为空的，则返回一个空字符串。\nf.readlines() 表示以list的形式返回该文件中包含的所有行。如果设置可选参数 sizehint, 则读取指定长度的字节, 并且将这些字节按行分割。\n以下是来源于网络的示例：\n```python\n>>> f.read()\n'This is the entire file.\\n'\n>>> f.read()\n''\n>>> f.readline()\n'This is the first line of the file.\\n'\n>>> f.readline()\n'Second line of the file\\n'\n>>> f.readline()\n''\n>>> f.readlines()\n['This is the first line of the file.\\n', 'Second line of the file\\n']\n```\n## 写 ##\n写的话就，简单了。\n```python\n>>> f.write('This is a test\\n')\n15\n```\n## 关 ##\n调用完成后记得关闭文件。\n```python\nf.close()\n```","slug":"23","published":1,"updated":"2015-10-02T01:57:34.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cifj5gkgt003es8vn1k5bo3fy"},{"title":"初学python（十）格式化输出","date":"2015-08-25T00:42:07.000Z","_content":"之前用python的时候只会用`print()`来输出。现在来学习一些其他的输出方式。\n本次主要学习这几个功能：\n\n - str() 函数返回一个用户易读的表达形式。\n - repr() 产生一个解释器易读的表达形式。\n - ljust()、rjust()、center() 左对齐、右对齐、居中。\n - zfill() 左边填充'0'\n - str.format() 格式化字段\n\n\n<!--more-->\n\n## str() ##\nstr() 是用来返回一个字符串的正常形式，就是显示在命令行或展示窗的字符串。其实就是用来将其他类型转换为字符串用的。例如：\n```python\n>>> s = 'Hello \\n World!'\n>>> s\n'Hello \\n World!'\n>>> str(s)\n'Hello \\n World!'\n>>> print(str(s))\nHello \n World!\n```\n## repr() ##\nrepr()函数是用来将字符串或其他类型转换为解释器可以识别的形式，例如将转义符再次进行转义。例如：\n```python\n>>> s = 'Hello \\n World!'\n>>> repr(s)\n\"'Hello \\\\n World!'\"\n>>> print(repr(s))\n'Hello \\n World!'\n```\n## ljust()、rjust()、center() ##\n```python\n>>> for i in range(1,4):\n...     print('|',repr(i).ljust(3),'|',repr(i*i).center(3),'|',repr(i**i).rjust(3),'|')\n... \n| 1   |  1  |   1 |\n| 2   |  4  |   4 |\n| 3   |  9  |  27 |\n```\n## zfill() ##\n这个函数是在左边填充'0'。\n```python\n>>> 'xx'.zfill(5)\n'000xx'\n```\n## format() ##\n就是用format()里的参数替换字符串中的通配符`{}`.例如：\n```python\n>>> 'this is {} test of {}!'.format('a','str.format()')\n'this is a test of str.format()!'\n```\n还可以在`{}`中写入关键字，这样就可以通过关机字赋值。例如：\n\n    >>> 'this is {a} test of {b}!'.format(b='str.format()',a='a')\n    'this is a test of str.format()!'\n还可以在`{}`加入`:参数`，用来格式化输入。例如：\n\n    >>> '{:.3f} * {:.3f} = {:3d}'.format(10,10,100)\n    '10.000 * 10.000 = 100'","source":"_posts/22.md","raw":"title: 初学python（十）格式化输出\ncategories: 编程与算法\ntags:\n  - python\ndate: 2015-08-25 08:42:07\n---\n之前用python的时候只会用`print()`来输出。现在来学习一些其他的输出方式。\n本次主要学习这几个功能：\n\n - str() 函数返回一个用户易读的表达形式。\n - repr() 产生一个解释器易读的表达形式。\n - ljust()、rjust()、center() 左对齐、右对齐、居中。\n - zfill() 左边填充'0'\n - str.format() 格式化字段\n\n\n<!--more-->\n\n## str() ##\nstr() 是用来返回一个字符串的正常形式，就是显示在命令行或展示窗的字符串。其实就是用来将其他类型转换为字符串用的。例如：\n```python\n>>> s = 'Hello \\n World!'\n>>> s\n'Hello \\n World!'\n>>> str(s)\n'Hello \\n World!'\n>>> print(str(s))\nHello \n World!\n```\n## repr() ##\nrepr()函数是用来将字符串或其他类型转换为解释器可以识别的形式，例如将转义符再次进行转义。例如：\n```python\n>>> s = 'Hello \\n World!'\n>>> repr(s)\n\"'Hello \\\\n World!'\"\n>>> print(repr(s))\n'Hello \\n World!'\n```\n## ljust()、rjust()、center() ##\n```python\n>>> for i in range(1,4):\n...     print('|',repr(i).ljust(3),'|',repr(i*i).center(3),'|',repr(i**i).rjust(3),'|')\n... \n| 1   |  1  |   1 |\n| 2   |  4  |   4 |\n| 3   |  9  |  27 |\n```\n## zfill() ##\n这个函数是在左边填充'0'。\n```python\n>>> 'xx'.zfill(5)\n'000xx'\n```\n## format() ##\n就是用format()里的参数替换字符串中的通配符`{}`.例如：\n```python\n>>> 'this is {} test of {}!'.format('a','str.format()')\n'this is a test of str.format()!'\n```\n还可以在`{}`中写入关键字，这样就可以通过关机字赋值。例如：\n\n    >>> 'this is {a} test of {b}!'.format(b='str.format()',a='a')\n    'this is a test of str.format()!'\n还可以在`{}`加入`:参数`，用来格式化输入。例如：\n\n    >>> '{:.3f} * {:.3f} = {:3d}'.format(10,10,100)\n    '10.000 * 10.000 = 100'","slug":"22","published":1,"updated":"2015-10-02T01:57:34.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cifj5gkgv003hs8vnwnge6foz"},{"title":"初学python（九）模块","date":"2015-08-25T00:41:48.000Z","_content":"python的模块就是在其他的python程序中调用写好的python文件。额，好乱的样子，就是使用已经封装好的python类和函数。我自己是这么理解的。\n这里先说怎样导入其他模块、怎样区别是自己调用还是其他程序调用、和创建一个包。\n关于导入父级包后同时导入其他子包，本人查阅了数多资料还是没找到解决方法。等以后知道了再来补充。\n\n\n<!--more-->\n\n## \\_\\_name__  的使用方法##\n每个*.py都有一个\\_\\_name__变量，如果调用该*.py的程序是它自己，那么\\_\\_name__的值为'\\_\\_main__'。这样就可以写一个函数如下:\n\n    #hello.py\n    #author innerac\n    def helloworld():\n    \tif __name__ == '__main__':\n    \t\tprint('Hello World!')\n    \telse:\n    \t\tprint('Hello the other World!!!')\n\n如果是本程序调用则会输出'`Hello World!`'，如果是其他程序调用的话就会输出'`Hello the other World!!!`'\n## 导入模块 ##\n这里仅仅学习简单的导入模块。首先我们有如下结构的包(包是已经建好的)\n\n    com/\n    \t__init__.py\n    \tinnerac/\n    \t\t__init__.py\n    \t\thello.py\n我们在程序中通过import导入\n```python\nimport com.innerac.hello\n#调用函数的方法\ncom.innerac.hello.helloworld()\n```\n也可以通过`from xxx import xxx`\n```python\nfrom com.innerac import hello\n#调用\nhello.helloworld()\n```\n也可以直接导入函数\n```python\nfrom com.innerac.hello import helloworld\n#调用\nhelloworld()\n```\n以上3个*.py都是和com是同目录的。他们的输出均为'`Hello the other World!!!`'\n## 创建一个包 ##\n如何创建一个包，首先应该在被当做包的目录下新建一个空的'`__init__.py`'文件。该文件声明了这是一个包结构。如上图我们的结构。\n起始只要有了空的文件我们就可以完成了我们所需要的功能。可是咱有强迫症，想导入父目录就同时把子目录也导入了。这个查阅了许多资料均没有找到想要的结果，后来只能自己写了个`import`这个方法仅供参考，欢迎指正。\n我想要的功能就是在与`com`同级的python文件下只写一句\"`import com`\"就可以直接使用\"`hello.py`\"下的函数。为此，我在\"`com/__init__.py`\"下加入语句:\n\n    #com/\n    #author innerac\n    import com.innerac\n    __all__ = []\n在\"`com/innerac/__init__.py`\"下加入语句：\n\n    #com/\n    #author innerac\n    import com.innerac.hello\n    __all__ = [\"hello\"]\n然后就可以直接调用了：\n\n    #start.py\n    #author innerac\n    import com\n    #直接调用\n    com.innerac.hello.helloworld()\n输出结果\"`Hello the other World!!!`\"\n\n还有一种导入方式就是'`*`'，如上图的包结构，只要我在\"`__init__.py`\"中创建一个\"`__all__`\"的list，然后将需要导入的模块都放进去。如\"`com/innerac/__init__.py`\"里的代码。只要在程序中书写：\n\n    #start.py\n    #author innerac\n    from com.innerac import *\n    #全部导入\n    hello.helloworld()\n就可以得到想要的结果了。\n如果\"`__all__`\"不写或者为空的话，将不会导入任何模块。","source":"_posts/21.md","raw":"title: 初学python（九）模块\ncategories: 编程与算法\ntags:\n  - python\ndate: 2015-08-25 08:41:48\n---\npython的模块就是在其他的python程序中调用写好的python文件。额，好乱的样子，就是使用已经封装好的python类和函数。我自己是这么理解的。\n这里先说怎样导入其他模块、怎样区别是自己调用还是其他程序调用、和创建一个包。\n关于导入父级包后同时导入其他子包，本人查阅了数多资料还是没找到解决方法。等以后知道了再来补充。\n\n\n<!--more-->\n\n## \\_\\_name__  的使用方法##\n每个*.py都有一个\\_\\_name__变量，如果调用该*.py的程序是它自己，那么\\_\\_name__的值为'\\_\\_main__'。这样就可以写一个函数如下:\n\n    #hello.py\n    #author innerac\n    def helloworld():\n    \tif __name__ == '__main__':\n    \t\tprint('Hello World!')\n    \telse:\n    \t\tprint('Hello the other World!!!')\n\n如果是本程序调用则会输出'`Hello World!`'，如果是其他程序调用的话就会输出'`Hello the other World!!!`'\n## 导入模块 ##\n这里仅仅学习简单的导入模块。首先我们有如下结构的包(包是已经建好的)\n\n    com/\n    \t__init__.py\n    \tinnerac/\n    \t\t__init__.py\n    \t\thello.py\n我们在程序中通过import导入\n```python\nimport com.innerac.hello\n#调用函数的方法\ncom.innerac.hello.helloworld()\n```\n也可以通过`from xxx import xxx`\n```python\nfrom com.innerac import hello\n#调用\nhello.helloworld()\n```\n也可以直接导入函数\n```python\nfrom com.innerac.hello import helloworld\n#调用\nhelloworld()\n```\n以上3个*.py都是和com是同目录的。他们的输出均为'`Hello the other World!!!`'\n## 创建一个包 ##\n如何创建一个包，首先应该在被当做包的目录下新建一个空的'`__init__.py`'文件。该文件声明了这是一个包结构。如上图我们的结构。\n起始只要有了空的文件我们就可以完成了我们所需要的功能。可是咱有强迫症，想导入父目录就同时把子目录也导入了。这个查阅了许多资料均没有找到想要的结果，后来只能自己写了个`import`这个方法仅供参考，欢迎指正。\n我想要的功能就是在与`com`同级的python文件下只写一句\"`import com`\"就可以直接使用\"`hello.py`\"下的函数。为此，我在\"`com/__init__.py`\"下加入语句:\n\n    #com/\n    #author innerac\n    import com.innerac\n    __all__ = []\n在\"`com/innerac/__init__.py`\"下加入语句：\n\n    #com/\n    #author innerac\n    import com.innerac.hello\n    __all__ = [\"hello\"]\n然后就可以直接调用了：\n\n    #start.py\n    #author innerac\n    import com\n    #直接调用\n    com.innerac.hello.helloworld()\n输出结果\"`Hello the other World!!!`\"\n\n还有一种导入方式就是'`*`'，如上图的包结构，只要我在\"`__init__.py`\"中创建一个\"`__all__`\"的list，然后将需要导入的模块都放进去。如\"`com/innerac/__init__.py`\"里的代码。只要在程序中书写：\n\n    #start.py\n    #author innerac\n    from com.innerac import *\n    #全部导入\n    hello.helloworld()\n就可以得到想要的结果了。\n如果\"`__all__`\"不写或者为空的话，将不会导入任何模块。","slug":"21","published":1,"updated":"2015-10-02T01:57:34.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cifj5gkgy003ks8vncm5o3u8t"},{"title":"初学python（八）函数","date":"2015-08-25T00:41:26.000Z","_content":"python的函数第一眼把我震惊了。没有函数结尾标识，只能通过严格的缩进来保证函数的健壮。还有它的参数是可变的，还可以带参数名传递。\n\n\n<!--more-->\n\n## 普通函数：\n\n    #函数开始\n    def fun():\n        print('Hello World!')\n    #函数结束\n    #函数开始\n    def fun(str):\n        print(str)\n    #函数结束\n    #函数开始\n    def fun(str):\n        str += 'a'\n        return str\n    #函数结束\n## 关键字参数 ##\n\n    def fun(a,b='b',c='c',d='d'):\n        return a+b+c+d\n    fun('a')\n    fun('a',b='b1')\n## 可变参数 ##\n\n    def fun(*args):\n        sum = 0\n        for x in args:\n            sum += x\n        return sum\n要强调的是，写函数时不要忘了加`:`","source":"_posts/20.md","raw":"title: 初学python（八）函数\ncategories: 编程与算法\ntags:\n  - python\ndate: 2015-08-25 08:41:26\n---\npython的函数第一眼把我震惊了。没有函数结尾标识，只能通过严格的缩进来保证函数的健壮。还有它的参数是可变的，还可以带参数名传递。\n\n\n<!--more-->\n\n## 普通函数：\n\n    #函数开始\n    def fun():\n        print('Hello World!')\n    #函数结束\n    #函数开始\n    def fun(str):\n        print(str)\n    #函数结束\n    #函数开始\n    def fun(str):\n        str += 'a'\n        return str\n    #函数结束\n## 关键字参数 ##\n\n    def fun(a,b='b',c='c',d='d'):\n        return a+b+c+d\n    fun('a')\n    fun('a',b='b1')\n## 可变参数 ##\n\n    def fun(*args):\n        sum = 0\n        for x in args:\n            sum += x\n        return sum\n要强调的是，写函数时不要忘了加`:`","slug":"20","published":1,"updated":"2015-10-02T01:57:34.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cifj5gkh0003ns8vn7snwoqxx"},{"title":"鞍山赛区D题","date":"2015-08-24T10:34:59.000Z","_content":"好吧，我承认这道题是水题，由于我的原因导致大家没有在赛场上A出这道题，现在把代码发上来，将n^2的复杂度降到线性的\n\n\n<!--more-->\n\n\n```cpp\n#include <iostream>  \n#include <cstdio>  \n#include <cstring>  \n#include <algorithm>  \n  \nusing namespace std;  \n  \nint d[50001];  \n  \nint main(){  \n    int T,n,k;  \n    double sum;  \n    double sum_xi_2,sum_xi,ave,tmp;  \n    double minx;  \n    cin>>T;  \n    while(T--){  \n        cin>>n>>k;  \n        memset(d,0,sizeof(d));  \n        sum = 0;  \n        sum_xi_2 = 0;  \n        sum_xi = 0;  \n        minx = 0;  \n        for (int i = 0; i < n; ++i){  \n            cin>>d[i];  \n        }  \n        sort(d,d+n);  \n        for(int i=0;i<n-k;i++){  \n            sum += d[i];  \n            sum_xi_2 += d[i]*d[i];            \n        }  \n        sum_xi = sum;  \n        ave = sum/(n-k);  \n        minx = sum_xi_2 + (n-k)*ave*ave - 2*ave*sum_xi;  \n        for(int i=1;i<=k;i++){  \n            sum -= d[i-1];  \n            sum += d[n-k+i-1];  \n            sum_xi_2 -= d[i-1]*d[i-1];  \n            sum_xi_2 += d[n-k+i-1]*d[n-k+i-1];  \n            sum_xi = sum;  \n            ave = sum/(n-k);  \n            tmp = sum_xi_2 + (n-k)*ave*ave - 2*ave*sum_xi;  \n            if(tmp < minx)  \n                minx = tmp;  \n        }  \n        printf(\"%.9f\\n\",minx);  \n    }  \n}  \n```\n","source":"_posts/2.md","raw":"title: 鞍山赛区D题\ndate: 2015-08-24 18:34:59\ncategories: 编程与算法\ntags: [ACM,区域赛]\n---\n好吧，我承认这道题是水题，由于我的原因导致大家没有在赛场上A出这道题，现在把代码发上来，将n^2的复杂度降到线性的\n\n\n<!--more-->\n\n\n```cpp\n#include <iostream>  \n#include <cstdio>  \n#include <cstring>  \n#include <algorithm>  \n  \nusing namespace std;  \n  \nint d[50001];  \n  \nint main(){  \n    int T,n,k;  \n    double sum;  \n    double sum_xi_2,sum_xi,ave,tmp;  \n    double minx;  \n    cin>>T;  \n    while(T--){  \n        cin>>n>>k;  \n        memset(d,0,sizeof(d));  \n        sum = 0;  \n        sum_xi_2 = 0;  \n        sum_xi = 0;  \n        minx = 0;  \n        for (int i = 0; i < n; ++i){  \n            cin>>d[i];  \n        }  \n        sort(d,d+n);  \n        for(int i=0;i<n-k;i++){  \n            sum += d[i];  \n            sum_xi_2 += d[i]*d[i];            \n        }  \n        sum_xi = sum;  \n        ave = sum/(n-k);  \n        minx = sum_xi_2 + (n-k)*ave*ave - 2*ave*sum_xi;  \n        for(int i=1;i<=k;i++){  \n            sum -= d[i-1];  \n            sum += d[n-k+i-1];  \n            sum_xi_2 -= d[i-1]*d[i-1];  \n            sum_xi_2 += d[n-k+i-1]*d[n-k+i-1];  \n            sum_xi = sum;  \n            ave = sum/(n-k);  \n            tmp = sum_xi_2 + (n-k)*ave*ave - 2*ave*sum_xi;  \n            if(tmp < minx)  \n                minx = tmp;  \n        }  \n        printf(\"%.9f\\n\",minx);  \n    }  \n}  \n```\n","slug":"2","published":1,"updated":"2015-10-02T01:57:34.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cifj5gkh2003qs8vnuai3xfzt"},{"title":"初学python（七）循环与条件","date":"2015-08-25T00:41:08.000Z","_content":"在python中，条件后边必须要加上`:`从C那边转过来感觉挺别扭的，不过这样跟能区别赋值与条件吧。\n\n\n<!--more-->\n\n## 条件 ##\n\n    if 条件1:\n        <statements>\n    elif 条件2:\n        <statements>\n    elif 条件3:\n        <statements>\n    else:\n        <statements>\n恩，条件大概就是这样的。\n## for循环 ##\nfor循环在各个语言中应该都有的。额，汇编也是可以通过jump 和 goto 实现的。\n在python中，遍历起来会更方便。很像java的那个for遍历。它的for循环中有一个`else`，开始不太理解，后来想明白就是类似于收尾的一个工作，如果循环中没有通过`break`跳出循环的话，在循环结束后就执行`else`中的代码。如果执行了`break`则不会执行`else`中的内容。\n\n    for <variable> in <sequence>:\n    \t<statements>    #变量在队列中\n    else:\n    \t<statements>    #循环结束且没有通过break跳出循环\n如果`for`循环中有`if`，就一定要注意代码的格式问题了，要不就不知道`else`是`if`的还是`for`的。例如\n\n    for x in [1]:\n        if x == 1:\n            print(\"Hello\")\n    else:\n        print(\"World!\")\n它是执行结果就是：\n\n    Hello\n    World!\n## range() ##\n对于数字的遍历，可以使用range函数，废话不多说，看样例：\n\n    >>> for i in range(3):\\    #遍历[0,n)\n    ...     print(i)\n    ... \n    0\n    1\n    2\n    >>> for i in range(3,5):\\    #遍历[x,y)\n    ...     print(i)\n    ... \n    3\n    4\n    >>> for i in range(0,10,3):\\    #以z为步长遍历[x,y)\n    ...     print(i)\n    ... \n    0\n    3\n    6\n    9\n    >>> for i in range(0,-10,-3):\\    #同上\n    ...     print(i)\n    ... \n    0\n    -3\n    -6\n    -9\n还可以通过range()和len()函数结合来遍历有索引的序列。如：\n\n    >>> list = ['a','b','c','d']\n    >>> for i in range(len(list)):\\\n    ...     print(i,list[i])\n    ... \n    0 a\n    1 b\n    2 c\n    3 d\n还可以通过range()得到一个list\n\n    >>> list(range(5))\n    [0, 1, 2, 3, 4]\n## while ##\n额，忘了这个基本的循环结构了。\n\n    while 判断条件：\n        <statements>\n其实在python中只要注意好缩进就可以了。\n还有个奇葩的函数，类似于system.pause，就是`pass`\n写两行代码：\n\n    while True:\n        pass  # 等待键盘中断 (Ctrl+C)\n就可以无限的敲回车了。2333333","source":"_posts/19.md","raw":"title: 初学python（七）循环与条件\ncategories: 编程与算法\ntags:\n  - python\ndate: 2015-08-25 08:41:08\n---\n在python中，条件后边必须要加上`:`从C那边转过来感觉挺别扭的，不过这样跟能区别赋值与条件吧。\n\n\n<!--more-->\n\n## 条件 ##\n\n    if 条件1:\n        <statements>\n    elif 条件2:\n        <statements>\n    elif 条件3:\n        <statements>\n    else:\n        <statements>\n恩，条件大概就是这样的。\n## for循环 ##\nfor循环在各个语言中应该都有的。额，汇编也是可以通过jump 和 goto 实现的。\n在python中，遍历起来会更方便。很像java的那个for遍历。它的for循环中有一个`else`，开始不太理解，后来想明白就是类似于收尾的一个工作，如果循环中没有通过`break`跳出循环的话，在循环结束后就执行`else`中的代码。如果执行了`break`则不会执行`else`中的内容。\n\n    for <variable> in <sequence>:\n    \t<statements>    #变量在队列中\n    else:\n    \t<statements>    #循环结束且没有通过break跳出循环\n如果`for`循环中有`if`，就一定要注意代码的格式问题了，要不就不知道`else`是`if`的还是`for`的。例如\n\n    for x in [1]:\n        if x == 1:\n            print(\"Hello\")\n    else:\n        print(\"World!\")\n它是执行结果就是：\n\n    Hello\n    World!\n## range() ##\n对于数字的遍历，可以使用range函数，废话不多说，看样例：\n\n    >>> for i in range(3):\\    #遍历[0,n)\n    ...     print(i)\n    ... \n    0\n    1\n    2\n    >>> for i in range(3,5):\\    #遍历[x,y)\n    ...     print(i)\n    ... \n    3\n    4\n    >>> for i in range(0,10,3):\\    #以z为步长遍历[x,y)\n    ...     print(i)\n    ... \n    0\n    3\n    6\n    9\n    >>> for i in range(0,-10,-3):\\    #同上\n    ...     print(i)\n    ... \n    0\n    -3\n    -6\n    -9\n还可以通过range()和len()函数结合来遍历有索引的序列。如：\n\n    >>> list = ['a','b','c','d']\n    >>> for i in range(len(list)):\\\n    ...     print(i,list[i])\n    ... \n    0 a\n    1 b\n    2 c\n    3 d\n还可以通过range()得到一个list\n\n    >>> list(range(5))\n    [0, 1, 2, 3, 4]\n## while ##\n额，忘了这个基本的循环结构了。\n\n    while 判断条件：\n        <statements>\n其实在python中只要注意好缩进就可以了。\n还有个奇葩的函数，类似于system.pause，就是`pass`\n写两行代码：\n\n    while True:\n        pass  # 等待键盘中断 (Ctrl+C)\n就可以无限的敲回车了。2333333","slug":"19","published":1,"updated":"2015-10-02T01:57:34.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cifj5gkh6003vs8vnfwxxcyqt"},{"title":"初学python（六）List常用操作","date":"2015-08-25T00:40:35.000Z","_content":"python的list的用法其实有很多，这里就练习几个常用的吧。\n这里是S的几个函数\n\n<table> <tr> <td>Operation</td> <td>Result</td> <td>Notes</td></tr><tr> <td>s[i] = x</td> <td>item i of s is replaced by x</td> <td> </td></tr><tr> <td>s[i:j] = t</td>  <td>slice of s from i to j is replaced by the contents of the iterable t</td> <td> </td></tr><tr> <td>del s[i:j]</td> <td>same as s[i:j] = []</td> <td> </td></tr><tr> <td>s[i:j:k] = t</td> <td>the elements of s[i:j:k] are replaced by those of t</td>  <td>-1</td></tr><tr> <td>del s[i:j:k]</td> <td>removes the elements of s[i:j:k] from the list</td> <td> </td></tr><tr> <td>s.append(x)</td>  <td>appends x to the end of the sequence (same as s[len(s):len(s)] = [x])</td> <td> </td></tr><tr> <td>s.clear()</td> <td>removes all items from s (same as del s[:])</td> <td>-5</td></tr><tr> <td>s.copy()</td> <td>creates a shallow copy of s (same as s[:])</td> <td>-5</td></tr><tr> <td>s.extend(t)</td> <td>extends s with the contents of t (same as s[len(s):len(s)] = t)</td> <td> </td></tr><tr> <td>s.insert(i, x)</td> <td>inserts x into s at the index given by i (same as s[i:i] = [x])</td> <td> </td></tr><tr>  <td>s.pop([i])</td> <td>retrieves the item at i and also removes it from s</td> <td>-2</td></tr><tr>  <td>s.remove(x)</td> <td>remove the first item from s where s[i] == x</td>  <td>-3</td></tr><tr> <td>s.reverse()</td> <td>reverses the items of s in place</td>  <td>-4</td></tr></table>\n\n\n<!--more-->\n好像找到中文版了，补充一下哈：\n<table class=\"table-bordered table-striped table-condensed\"> <tr> <th>方法</th> <th>描述</th> </tr> <tr> <td>list.append(x) </td> <td>把一个元素添加到列表的结尾，相当于 a[len(a):] = [x]。 </td> </tr> <tr> <td>list.extend(L) </td> <td>通过添加指定列表的所有元素来扩充列表，相当于 a[len(a):] = L。 </td> </tr> <tr> <td>list.insert(i, x) </td> <td>在指定位置插入一个元素。第一个参数是准备插入到其前面的那个元素的索引，例如 a.insert(0, x) 会插入到整个列表之前，而 a.insert(len(a), x) 相当于 a.append(x) 。 </td> </tr> <tr> <td>list.remove(x) </td> <td>删除列表中值为 x 的第一个元素。如果没有这样的元素，就会返回一个错误。 </td> </tr> <tr> <td>list.pop([i]) </td> <td>从列表的指定位置删除元素，并将其返回。如果没有指定索引，a.pop()返回最后一个元素。元素随即从列表中被删除。（方法中 i 两边的方括号表示这个参数是可选的，而不是要求你输入一对方括号，你会经常在 Python 库参考手册中遇到这样的标记。） </td> </tr> <tr> <td>list.clear() </td> <td>移除列表中的所有项，等于del a[:]。 </td> </tr> <tr> <td>list.index(x) </td> <td>返回列表中第一个值为 x 的元素的索引。如果没有匹配的元素就会返回一个错误。 </td> </tr> <tr> <td>list.count(x) </td> <td>返回 x 在列表中出现的次数。 </td> </tr> <tr> <td>list.sort() </td> <td>对列表中的元素进行排序。 </td> </tr> <tr> <td>list.reverse() </td> <td>倒排列表中的元素。 </td> </tr> <tr> <td>list.copy() </td> <td>返回列表的浅复制，等于a[:]。 </td> </tr> </table>\n\n接下来是我的测试：\n## 定义 ##\n    >>> list = ['a','b','c','d']\n    >>> list\n    ['a', 'b', 'c', 'd']\n## 索引 ##\n    >>> list[0]\n    'a'\n    >>> list[-1]\n    'd'\n    >>> list[1:3]    #获取[1,3)区间的元素\n    ['b', 'c']\n## 追加和插入 ##\n    >>> list.append('e')    #尾部追加\n    >>> list\n    ['a', 'b', 'c', 'd', 'e']\n    >>> list.insert(1,'a2')    #下标插入\n    >>> list\n    ['a', 'a2', 'b', 'c', 'd', 'e']\n    >>> list.extend(['f','g','h'])    #尾部追加list\n    >>> list\n    ['a', 'a2', 'b', 'c', 'd', 'e', 'f', 'g', 'h']\n## 检索 ##\n    >>> list.index('a2')\n    1\n    >>> 'b2' in list\n    False\n## 运算符 ##\n    >>> list += ['i','j']\n    >>> list\n    ['a', 'a2', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j']\n    >>> list = ['a','b']*3\n    >>> list\n    ['a', 'b', 'a', 'b', 'a', 'b']\n## join用法 ##\n    >>> params ={'one':'first','two':'twice','three':'third'}\n    >>> ['%s=%s' % (k,v) for k,v in params.items()]\n    ['three=third', 'one=first', 'two=twice']\n    >>> list = '&&'.join(['%s=%s' % (k,v) for k,v in params.items()])\n    >>> list\n    'three=third&&one=first&&two=twice'\n## 分割 ##\n    >>> list.split('&&')\n    ['three=third', 'one=first', 'two=twice']\n    >>> list.split('&&',1)    #第二个参数为分割次数\n    ['three=third', 'one=first&&two=twice']\n## 映射和过滤 ##\n    >>> list = [1,2,3,4]\n    >>> list = [elem*2 for elem in list]\n    >>> list\n    [2, 4, 6, 8]\n    >>> list = [elem for elem in list if elem >2]\n    >>> list\n    [4, 6, 8]\n    >>> list = [1,2,3,4,5,6,1,1,2,3,4]\n    >>> list\n    [1, 2, 3, 4, 5, 6, 1, 1, 2, 3, 4]\n    >>> list = [elem for elem in list if list.count(elem) > 1]\n    >>> list\n    [1, 2, 3, 4, 1, 1, 2, 3, 4]\n\n## 删除操作 ##\n\n    >>> list.remove(1)    #删除首次出现的值\n    >>> list\n    [2, 3, 4, 1, 1, 2, 3, 4]\n    >>> list.pop()    #删除尾部元素，并且返回\n    4\n    >>> list\n    [2, 3, 4, 1, 1, 2, 3]\n\n","source":"_posts/18.md","raw":"title: 初学python（六）List常用操作\ncategories: 编程与算法\ntags:\n  - python\ndate: 2015-08-25 08:40:35\n---\npython的list的用法其实有很多，这里就练习几个常用的吧。\n这里是S的几个函数\n\n<table> <tr> <td>Operation</td> <td>Result</td> <td>Notes</td></tr><tr> <td>s[i] = x</td> <td>item i of s is replaced by x</td> <td> </td></tr><tr> <td>s[i:j] = t</td>  <td>slice of s from i to j is replaced by the contents of the iterable t</td> <td> </td></tr><tr> <td>del s[i:j]</td> <td>same as s[i:j] = []</td> <td> </td></tr><tr> <td>s[i:j:k] = t</td> <td>the elements of s[i:j:k] are replaced by those of t</td>  <td>-1</td></tr><tr> <td>del s[i:j:k]</td> <td>removes the elements of s[i:j:k] from the list</td> <td> </td></tr><tr> <td>s.append(x)</td>  <td>appends x to the end of the sequence (same as s[len(s):len(s)] = [x])</td> <td> </td></tr><tr> <td>s.clear()</td> <td>removes all items from s (same as del s[:])</td> <td>-5</td></tr><tr> <td>s.copy()</td> <td>creates a shallow copy of s (same as s[:])</td> <td>-5</td></tr><tr> <td>s.extend(t)</td> <td>extends s with the contents of t (same as s[len(s):len(s)] = t)</td> <td> </td></tr><tr> <td>s.insert(i, x)</td> <td>inserts x into s at the index given by i (same as s[i:i] = [x])</td> <td> </td></tr><tr>  <td>s.pop([i])</td> <td>retrieves the item at i and also removes it from s</td> <td>-2</td></tr><tr>  <td>s.remove(x)</td> <td>remove the first item from s where s[i] == x</td>  <td>-3</td></tr><tr> <td>s.reverse()</td> <td>reverses the items of s in place</td>  <td>-4</td></tr></table>\n\n\n<!--more-->\n好像找到中文版了，补充一下哈：\n<table class=\"table-bordered table-striped table-condensed\"> <tr> <th>方法</th> <th>描述</th> </tr> <tr> <td>list.append(x) </td> <td>把一个元素添加到列表的结尾，相当于 a[len(a):] = [x]。 </td> </tr> <tr> <td>list.extend(L) </td> <td>通过添加指定列表的所有元素来扩充列表，相当于 a[len(a):] = L。 </td> </tr> <tr> <td>list.insert(i, x) </td> <td>在指定位置插入一个元素。第一个参数是准备插入到其前面的那个元素的索引，例如 a.insert(0, x) 会插入到整个列表之前，而 a.insert(len(a), x) 相当于 a.append(x) 。 </td> </tr> <tr> <td>list.remove(x) </td> <td>删除列表中值为 x 的第一个元素。如果没有这样的元素，就会返回一个错误。 </td> </tr> <tr> <td>list.pop([i]) </td> <td>从列表的指定位置删除元素，并将其返回。如果没有指定索引，a.pop()返回最后一个元素。元素随即从列表中被删除。（方法中 i 两边的方括号表示这个参数是可选的，而不是要求你输入一对方括号，你会经常在 Python 库参考手册中遇到这样的标记。） </td> </tr> <tr> <td>list.clear() </td> <td>移除列表中的所有项，等于del a[:]。 </td> </tr> <tr> <td>list.index(x) </td> <td>返回列表中第一个值为 x 的元素的索引。如果没有匹配的元素就会返回一个错误。 </td> </tr> <tr> <td>list.count(x) </td> <td>返回 x 在列表中出现的次数。 </td> </tr> <tr> <td>list.sort() </td> <td>对列表中的元素进行排序。 </td> </tr> <tr> <td>list.reverse() </td> <td>倒排列表中的元素。 </td> </tr> <tr> <td>list.copy() </td> <td>返回列表的浅复制，等于a[:]。 </td> </tr> </table>\n\n接下来是我的测试：\n## 定义 ##\n    >>> list = ['a','b','c','d']\n    >>> list\n    ['a', 'b', 'c', 'd']\n## 索引 ##\n    >>> list[0]\n    'a'\n    >>> list[-1]\n    'd'\n    >>> list[1:3]    #获取[1,3)区间的元素\n    ['b', 'c']\n## 追加和插入 ##\n    >>> list.append('e')    #尾部追加\n    >>> list\n    ['a', 'b', 'c', 'd', 'e']\n    >>> list.insert(1,'a2')    #下标插入\n    >>> list\n    ['a', 'a2', 'b', 'c', 'd', 'e']\n    >>> list.extend(['f','g','h'])    #尾部追加list\n    >>> list\n    ['a', 'a2', 'b', 'c', 'd', 'e', 'f', 'g', 'h']\n## 检索 ##\n    >>> list.index('a2')\n    1\n    >>> 'b2' in list\n    False\n## 运算符 ##\n    >>> list += ['i','j']\n    >>> list\n    ['a', 'a2', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j']\n    >>> list = ['a','b']*3\n    >>> list\n    ['a', 'b', 'a', 'b', 'a', 'b']\n## join用法 ##\n    >>> params ={'one':'first','two':'twice','three':'third'}\n    >>> ['%s=%s' % (k,v) for k,v in params.items()]\n    ['three=third', 'one=first', 'two=twice']\n    >>> list = '&&'.join(['%s=%s' % (k,v) for k,v in params.items()])\n    >>> list\n    'three=third&&one=first&&two=twice'\n## 分割 ##\n    >>> list.split('&&')\n    ['three=third', 'one=first', 'two=twice']\n    >>> list.split('&&',1)    #第二个参数为分割次数\n    ['three=third', 'one=first&&two=twice']\n## 映射和过滤 ##\n    >>> list = [1,2,3,4]\n    >>> list = [elem*2 for elem in list]\n    >>> list\n    [2, 4, 6, 8]\n    >>> list = [elem for elem in list if elem >2]\n    >>> list\n    [4, 6, 8]\n    >>> list = [1,2,3,4,5,6,1,1,2,3,4]\n    >>> list\n    [1, 2, 3, 4, 5, 6, 1, 1, 2, 3, 4]\n    >>> list = [elem for elem in list if list.count(elem) > 1]\n    >>> list\n    [1, 2, 3, 4, 1, 1, 2, 3, 4]\n\n## 删除操作 ##\n\n    >>> list.remove(1)    #删除首次出现的值\n    >>> list\n    [2, 3, 4, 1, 1, 2, 3, 4]\n    >>> list.pop()    #删除尾部元素，并且返回\n    4\n    >>> list\n    [2, 3, 4, 1, 1, 2, 3]\n\n","slug":"18","published":1,"updated":"2015-10-02T01:57:34.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cifj5gkh8003ys8vno0wa7oea"},{"title":"初学python（五）字符串操作","date":"2015-08-25T00:40:02.000Z","_content":"现在列举一些字符串判断的函数。\n\n```python\nprint(str.isalnum())     # 判断所有字符都是数字或者字母\nprint(str.isalpha())     # 判断所有字符都是字母\nprint(str.isdigit())     # 判断所有字符都是数字\nprint(str.islower())     # 判断所有字符都是小写\nprint(str.isupper())     # 判断所有字符都是大写\nprint(str.istitle())     # 判断所有单词都是首字母大写，像标题\nprint(str.isspace())     # 判断所有字符都是空白字符、\\t、\\n、\\r\nprint(str.upper())       # 把所有字符中的小写字母转换成大写字母\nprint(str.lower())       # 把所有字符中的大写字母转换成小写字母\nprint(str.capitalize())  # 把第一个字母转化为大写字母，其余小写\nprint(str.title())       # 把每个单词的第一个字母转化为大写，其余小写 \n```","source":"_posts/17.md","raw":"title: 初学python（五）字符串操作\ncategories: 编程与算法\ntags:\n  - python\ndate: 2015-08-25 08:40:02\n---\n现在列举一些字符串判断的函数。\n\n```python\nprint(str.isalnum())     # 判断所有字符都是数字或者字母\nprint(str.isalpha())     # 判断所有字符都是字母\nprint(str.isdigit())     # 判断所有字符都是数字\nprint(str.islower())     # 判断所有字符都是小写\nprint(str.isupper())     # 判断所有字符都是大写\nprint(str.istitle())     # 判断所有单词都是首字母大写，像标题\nprint(str.isspace())     # 判断所有字符都是空白字符、\\t、\\n、\\r\nprint(str.upper())       # 把所有字符中的小写字母转换成大写字母\nprint(str.lower())       # 把所有字符中的大写字母转换成小写字母\nprint(str.capitalize())  # 把第一个字母转化为大写字母，其余小写\nprint(str.title())       # 把每个单词的第一个字母转化为大写，其余小写 \n```","slug":"17","published":1,"updated":"2015-10-02T01:57:34.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cifj5gkha0041s8vng7x08k1q"},{"title":"初学python（四）进制与字符转换和文件读写","date":"2015-08-25T00:37:36.000Z","_content":"现在学到了如何将十进制转换为其他进制，和字符与ASCII码之间的转换。\n还有文件的读写。\n\n<!--more-->\n\n    dec = 12\n    print(bin(dec))    #二进制\n    print(oct(dec))    #八进制\n    print(hex(dec))    #十六进制\n    c = 'a'\n    a = '10'\n    print(ord(c))    #字符 -> ASCII码\n    print(chr(a))    #ASCII码 -> 字符\n文件的读写：\n\n    # 写文件\n    with open(\"out\", \"wt\") as out_file:\n        out_file.write(\"该文本会写入到文件中\\n看到我了吧!\")\n    # Read a file\n    with open(\"in\", \"rt\") as in_file:\n        text = in_file.read()\n    print(text)","source":"_posts/16.md","raw":"title: 初学python（四）进制与字符转换和文件读写\ncategories: 编程与算法\ntags:\n  - python\ndate: 2015-08-25 08:37:36\n---\n现在学到了如何将十进制转换为其他进制，和字符与ASCII码之间的转换。\n还有文件的读写。\n\n<!--more-->\n\n    dec = 12\n    print(bin(dec))    #二进制\n    print(oct(dec))    #八进制\n    print(hex(dec))    #十六进制\n    c = 'a'\n    a = '10'\n    print(ord(c))    #字符 -> ASCII码\n    print(chr(a))    #ASCII码 -> 字符\n文件的读写：\n\n    # 写文件\n    with open(\"out\", \"wt\") as out_file:\n        out_file.write(\"该文本会写入到文件中\\n看到我了吧!\")\n    # Read a file\n    with open(\"in\", \"rt\") as in_file:\n        text = in_file.read()\n    print(text)","slug":"16","published":1,"updated":"2015-10-02T01:57:34.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cifj5gkiw0044s8vn0atc7r2d"},{"title":"初学python（三）一些练习","date":"2015-08-25T00:36:49.000Z","_content":"学习了部分的语法，现在来练习一些。\n\n - A+B\n - 交换两个变量\n - 随机数\n - 条件语句\n\n\n<!--more-->\n\n## A+B ##\n这个我以为很简单，不过发现python将所有的输入都当做了字符串，所以需要输入的时候进行转换\n\n    a = int(input())\n    b = int(input())\n    print (a+b)\n## SWAP ##\n交换变量比C要简单，不用异或或者使用临时变量\n\n    x,y = y,x\n## Rand ##\n\n    import random\n    print(random.randint(0,9))\n## if else ##\n条件语句写着挺别扭的，条件和else后面要加`:`\n而且0为false，字符串的'0'却为true\n\n    if 0:    #false\n        print('0 is true!')\n    elif '0':    #true\n        print('\\'0\\' is true!')\n    else:\n        print(0 & \\'0\\' are false!)","source":"_posts/15.md","raw":"title: 初学python（三）一些练习\ncategories: 编程与算法\ndate: 2015-08-25 08:36:49\ntags: [python]\n---\n学习了部分的语法，现在来练习一些。\n\n - A+B\n - 交换两个变量\n - 随机数\n - 条件语句\n\n\n<!--more-->\n\n## A+B ##\n这个我以为很简单，不过发现python将所有的输入都当做了字符串，所以需要输入的时候进行转换\n\n    a = int(input())\n    b = int(input())\n    print (a+b)\n## SWAP ##\n交换变量比C要简单，不用异或或者使用临时变量\n\n    x,y = y,x\n## Rand ##\n\n    import random\n    print(random.randint(0,9))\n## if else ##\n条件语句写着挺别扭的，条件和else后面要加`:`\n而且0为false，字符串的'0'却为true\n\n    if 0:    #false\n        print('0 is true!')\n    elif '0':    #true\n        print('\\'0\\' is true!')\n    else:\n        print(0 & \\'0\\' are false!)","slug":"15","published":1,"updated":"2015-10-02T01:57:34.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cifj5gkiy0047s8vnxygcvq57"},{"title":"初学python（二）数据类型","date":"2015-08-25T00:34:52.000Z","_content":"据说python里有6个标准的数据类型：\n\n - Numbers（数字）\n - String（字符串）\n - List（列表） \n - Tuple（元组） \n - Sets（集合）\n - Dictionaries（字典）\n\n\n<!--more-->\n\n## Numbers（数字） ##\npython3 支持int、float、bool、complex\n还可以通过一个叫`type()`的函数来输出类型，自己测试了一下\n\n    Python 3.4.0 (default, Apr 11 2014, 13:05:18) \n    [GCC 4.8.2] on linux\n    Type \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n    >>> a,b,c,d = 10,2.5,True,4+3j\n    >>> print(type(a),type(b),type(c),type(d))\n    <class 'int'> <class 'float'> <class 'bool'> <class 'complex'>\n    >>> \n还有运算：\n\n    >>> 1 + 1 #加\n    2\n    >>> 1 - 1 #减\n    0\n    >>> 1 × 1 #乘\n      File \"<stdin>\", line 1\n        1 × 1 #乘\n          ^\n    SyntaxError: invalid character in identifier\n    >>> 1 * 1 #乘\n    1\n    >>> 3 / 2 #浮点数除\n    1.5\n    >>> 3 // 2 #整除\n    1\n    >>> 3 % 2 #取模\n    1\n    >>> 2 ** 4 #幂\n    16\n    >>> pow(2,4) #幂\n    16\n## String（字符串） ##\n这个没什么好说的，上一节感觉熟练了一下。\n可以用`*`来重复字符串，用`+`来拼接字符串，用`string[index]`来取字符，或者用`string[-index]`来倒着取字符。和ruby一样一样的。\n还有字符串分割`string[index_x:index_y]`\n但是不能通`过string[index] = x`进行赋值，因为字符串是不可改变的。\n## List（列表） ##\n先说列表的赋值吧，一个列表中可以扔进任何一个类型的数据，不用在意类型。例如\n\n    >>> a = ['him', 25, 100, 'her']\n    >>> print(a)\n    ['him', 25, 100, 'her']\n它还支持拼接、修改、分割操作，\n\n    >>> a = [1, 2, 3, 4, 5]\n    >>> a + [6, 7, 8]\n    [1, 2, 3, 4, 5, 6, 7, 8]\n    >>> a = [1, 2, 3, 4, 5, 6]\n    >>> a[0] = 9\n    >>> a[2:5] = [13, 14, 15]\n    >>> a\n    [9, 2, 13, 14, 15, 6]\n    >>> a[2:5] = []   # 删除\n    >>> a\n    [9, 2, 6]\n## （元组） ##\n元组（tuple）与列表类似，不同之处在于元组的元素不能修改。元组写在小括号里，元素之间用逗号隔开。\n例如：\n\n    >>> a = (1991, 2014, 'physics', 'math')\n    >>> print(a, type(a), len(a))\n    (1991, 2014, 'physics', 'math') <class 'tuple'> 4\n元组与字符串类似，可以被索引且下标索引从0开始，也可以进行截取/切片（看上面，这里不再赘述）。\n其实，可以把字符串看作一种特殊的元组。\n\n    >>> tup = (1, 2, 3, 4, 5, 6)\n    >>> print(tup[0], tup[1:5])\n    1 (2, 3, 4, 5)\n    >>> tup[0] = 11  # 修改元组元素的操作是非法的\n\n虽然tuple的元素不可改变，但它可以包含可变的对象，比如list列表。\n构造包含0个或1个元素的tuple是个特殊的问题，所以有一些额外的语法规则：\n\n    tup1 = () # 空元组\n    tup2 = (20,) # 一个元素，需要在元素后添加逗号\n\n另外，元组也支持用+操作符：\n\n    >>> tup1, tup2 = (1, 2, 3), (4, 5, 6)\n    >>> print(tup1+tup2)\n    (1, 2, 3, 4, 5, 6)\n## Sets（集合） ##\n集合（set）是一个无序不重复元素的集。\n好熟悉的结构，哈哈哈。\n基本功能是进行成员关系测试和消除重复元素。\n可以使用大括号 或者 set()函数创建set集合，注意：创建一个空集合必须用 set() 而不是 { }，因为{ }是用来创建一个空字典。\n下面来个例子吧：\n\n    >>> set_text = {'item0','item1','item2','item3','item4','item5','item6'}\n    >>> print(set_text)\n    {'item1', 'item4', 'item3', 'item2', 'item6', 'item5', 'item0'}\n    >>> #果然是无序的\n    ... \n    >>> 'item3' in set_text #成员测试?\n    True\n    >>> 'item7' in set_text #成员测试?\n    False\n    >>> #据说还可以进行集合运算\n    ... \n    >>> a = set(sadfdsafsdfas)\n    Traceback (most recent call last):\n      File \"<stdin>\", line 1, in <module>\n    NameError: name 'sadfdsafsdfas' is not defined\n    >>> a = set('sadfdsafsdfas')\n    >>> b = set('sdlifjxz')\n    >>> a\n    {'d', 'a', 'f', 's'}\n    >>> b\n    {'z', 'd', 'l', 'f', 'x', 'j', 's', 'i'}\n    >>> b-a    #差\n    {'x', 'l', 'j', 'i', 'z'}\n    >>> a | b    #并\n    {'z', 'd', 'f', 'l', 'x', 'j', 'a', 's', 'i'}\n    >>> a & b    #交\n    {'d', 'f', 's'}\n    >>> a ^ b    #a和b中不同时存在的元素\n    {'z', 'l', 'x', 'j', 'a', 'i'}\n\n## Dictionaries（字典） ##\n这应该就是在C里用的`map`吧，一个映射类型。其中的key必须是不可变类型，`list`和`tuple`就不行了。\n基本操作：添删改查\n\n    >>> dic = {} #空字典\n    >>> dic\n    {}\n    >>> dics = {'tom':1,'jerry':10,'cat':11}\n    >>> dics\n    {'jerry': 10, 'cat': 11, 'tom': 1}\n    >>> dics['tom'] #查\n    1\n    >>> dics['toms'] #查空\n    Traceback (most recent call last):\n      File \"<stdin>\", line 1, in <module>\n    KeyError: 'toms'\n    >>> del dics['tom'] #删\n    >>> dics\n    {'jerry': 10, 'cat': 11}\n    >>> dics['mouse'] = 100 #添\n    >>> dics\n    {'mouse': 100, 'jerry': 10, 'cat': 11}\n    >>> dics['mouse'] = 101 #改\n    >>> dics\n    {'mouse': 101, 'jerry': 10, 'cat': 11}\n进阶操作：\n\n    >>> list (dics.keys()) #返回所有key组成的list\n    ['mouse', 'jerry', 'cat']\n    >>> list (dics.values()) #返回所有value组成的list\n    [101, 10, 11]\n    >>> sorted (dics.keys()) #按key排序\n    ['cat', 'jerry', 'mouse']\n    >>> 'cat' in dics #成员测试?\n    True\n    >>> 'cats' in dics #成员测试?\n    False\n奇葩的构造方式，从sequence中构建\n\n    >>> dict([('sape', 4139), ('guido', 4127), ('jack', 4098)])\n    {'jack': 4098, 'sape': 4139, 'guido': 4127}\n    >>> {x: x**2 for x in (2, 4, 6)}\n    {2: 4, 4: 16, 6: 36}\n    >>> dict(sape=4139, guido=4127, jack=4098)\n    {'jack': 4098, 'sape': 4139, 'guido': 4127}\n\n","source":"_posts/14.md","raw":"title: 初学python（二）数据类型\ncategories: 编程与算法\ndate: 2015-08-25 08:34:52\ntags: [python]\n---\n据说python里有6个标准的数据类型：\n\n - Numbers（数字）\n - String（字符串）\n - List（列表） \n - Tuple（元组） \n - Sets（集合）\n - Dictionaries（字典）\n\n\n<!--more-->\n\n## Numbers（数字） ##\npython3 支持int、float、bool、complex\n还可以通过一个叫`type()`的函数来输出类型，自己测试了一下\n\n    Python 3.4.0 (default, Apr 11 2014, 13:05:18) \n    [GCC 4.8.2] on linux\n    Type \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n    >>> a,b,c,d = 10,2.5,True,4+3j\n    >>> print(type(a),type(b),type(c),type(d))\n    <class 'int'> <class 'float'> <class 'bool'> <class 'complex'>\n    >>> \n还有运算：\n\n    >>> 1 + 1 #加\n    2\n    >>> 1 - 1 #减\n    0\n    >>> 1 × 1 #乘\n      File \"<stdin>\", line 1\n        1 × 1 #乘\n          ^\n    SyntaxError: invalid character in identifier\n    >>> 1 * 1 #乘\n    1\n    >>> 3 / 2 #浮点数除\n    1.5\n    >>> 3 // 2 #整除\n    1\n    >>> 3 % 2 #取模\n    1\n    >>> 2 ** 4 #幂\n    16\n    >>> pow(2,4) #幂\n    16\n## String（字符串） ##\n这个没什么好说的，上一节感觉熟练了一下。\n可以用`*`来重复字符串，用`+`来拼接字符串，用`string[index]`来取字符，或者用`string[-index]`来倒着取字符。和ruby一样一样的。\n还有字符串分割`string[index_x:index_y]`\n但是不能通`过string[index] = x`进行赋值，因为字符串是不可改变的。\n## List（列表） ##\n先说列表的赋值吧，一个列表中可以扔进任何一个类型的数据，不用在意类型。例如\n\n    >>> a = ['him', 25, 100, 'her']\n    >>> print(a)\n    ['him', 25, 100, 'her']\n它还支持拼接、修改、分割操作，\n\n    >>> a = [1, 2, 3, 4, 5]\n    >>> a + [6, 7, 8]\n    [1, 2, 3, 4, 5, 6, 7, 8]\n    >>> a = [1, 2, 3, 4, 5, 6]\n    >>> a[0] = 9\n    >>> a[2:5] = [13, 14, 15]\n    >>> a\n    [9, 2, 13, 14, 15, 6]\n    >>> a[2:5] = []   # 删除\n    >>> a\n    [9, 2, 6]\n## （元组） ##\n元组（tuple）与列表类似，不同之处在于元组的元素不能修改。元组写在小括号里，元素之间用逗号隔开。\n例如：\n\n    >>> a = (1991, 2014, 'physics', 'math')\n    >>> print(a, type(a), len(a))\n    (1991, 2014, 'physics', 'math') <class 'tuple'> 4\n元组与字符串类似，可以被索引且下标索引从0开始，也可以进行截取/切片（看上面，这里不再赘述）。\n其实，可以把字符串看作一种特殊的元组。\n\n    >>> tup = (1, 2, 3, 4, 5, 6)\n    >>> print(tup[0], tup[1:5])\n    1 (2, 3, 4, 5)\n    >>> tup[0] = 11  # 修改元组元素的操作是非法的\n\n虽然tuple的元素不可改变，但它可以包含可变的对象，比如list列表。\n构造包含0个或1个元素的tuple是个特殊的问题，所以有一些额外的语法规则：\n\n    tup1 = () # 空元组\n    tup2 = (20,) # 一个元素，需要在元素后添加逗号\n\n另外，元组也支持用+操作符：\n\n    >>> tup1, tup2 = (1, 2, 3), (4, 5, 6)\n    >>> print(tup1+tup2)\n    (1, 2, 3, 4, 5, 6)\n## Sets（集合） ##\n集合（set）是一个无序不重复元素的集。\n好熟悉的结构，哈哈哈。\n基本功能是进行成员关系测试和消除重复元素。\n可以使用大括号 或者 set()函数创建set集合，注意：创建一个空集合必须用 set() 而不是 { }，因为{ }是用来创建一个空字典。\n下面来个例子吧：\n\n    >>> set_text = {'item0','item1','item2','item3','item4','item5','item6'}\n    >>> print(set_text)\n    {'item1', 'item4', 'item3', 'item2', 'item6', 'item5', 'item0'}\n    >>> #果然是无序的\n    ... \n    >>> 'item3' in set_text #成员测试?\n    True\n    >>> 'item7' in set_text #成员测试?\n    False\n    >>> #据说还可以进行集合运算\n    ... \n    >>> a = set(sadfdsafsdfas)\n    Traceback (most recent call last):\n      File \"<stdin>\", line 1, in <module>\n    NameError: name 'sadfdsafsdfas' is not defined\n    >>> a = set('sadfdsafsdfas')\n    >>> b = set('sdlifjxz')\n    >>> a\n    {'d', 'a', 'f', 's'}\n    >>> b\n    {'z', 'd', 'l', 'f', 'x', 'j', 's', 'i'}\n    >>> b-a    #差\n    {'x', 'l', 'j', 'i', 'z'}\n    >>> a | b    #并\n    {'z', 'd', 'f', 'l', 'x', 'j', 'a', 's', 'i'}\n    >>> a & b    #交\n    {'d', 'f', 's'}\n    >>> a ^ b    #a和b中不同时存在的元素\n    {'z', 'l', 'x', 'j', 'a', 'i'}\n\n## Dictionaries（字典） ##\n这应该就是在C里用的`map`吧，一个映射类型。其中的key必须是不可变类型，`list`和`tuple`就不行了。\n基本操作：添删改查\n\n    >>> dic = {} #空字典\n    >>> dic\n    {}\n    >>> dics = {'tom':1,'jerry':10,'cat':11}\n    >>> dics\n    {'jerry': 10, 'cat': 11, 'tom': 1}\n    >>> dics['tom'] #查\n    1\n    >>> dics['toms'] #查空\n    Traceback (most recent call last):\n      File \"<stdin>\", line 1, in <module>\n    KeyError: 'toms'\n    >>> del dics['tom'] #删\n    >>> dics\n    {'jerry': 10, 'cat': 11}\n    >>> dics['mouse'] = 100 #添\n    >>> dics\n    {'mouse': 100, 'jerry': 10, 'cat': 11}\n    >>> dics['mouse'] = 101 #改\n    >>> dics\n    {'mouse': 101, 'jerry': 10, 'cat': 11}\n进阶操作：\n\n    >>> list (dics.keys()) #返回所有key组成的list\n    ['mouse', 'jerry', 'cat']\n    >>> list (dics.values()) #返回所有value组成的list\n    [101, 10, 11]\n    >>> sorted (dics.keys()) #按key排序\n    ['cat', 'jerry', 'mouse']\n    >>> 'cat' in dics #成员测试?\n    True\n    >>> 'cats' in dics #成员测试?\n    False\n奇葩的构造方式，从sequence中构建\n\n    >>> dict([('sape', 4139), ('guido', 4127), ('jack', 4098)])\n    {'jack': 4098, 'sape': 4139, 'guido': 4127}\n    >>> {x: x**2 for x in (2, 4, 6)}\n    {2: 4, 4: 16, 6: 36}\n    >>> dict(sape=4139, guido=4127, jack=4098)\n    {'jack': 4098, 'sape': 4139, 'guido': 4127}\n\n","slug":"14","published":1,"updated":"2015-10-02T01:57:34.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cifj5gkiz004as8vno4zf9cv1"},{"title":"Qt中实现将float类型转换为QString类型","date":"2015-08-25T00:34:04.000Z","_content":"原帖地址：http://blog.csdn.net/leo115/article/details/7757118\n\n在使用Qt Creator编程时，难免会用到将float类型转换为QString类型的时候下面是我所有的方法：\n1. 将QString类型转化为float类型，很简单\n\n    QString data;            \n    float num = data.toFloat();\n    即可很轻松的实现。\n2. 但是如何将float类型转化为QString类型呢？\n    查看API很难发现封装好的转化函数\n    可以尝试使用下面的代码转化：\n    float num = 1.222;\n    QString data = QString(\"float is %1\").arg(num);\n    输出结果是：float is 1.222\n    如果只要float转化成的数值，则使用如下：\n    QString data = QString(\"%1\").arg(num);\n\n至此完毕。。。。。。。。。。。。。。。。","source":"_posts/13.md","raw":"title: Qt中实现将float类型转换为QString类型\ncategories: 编程与算法\ndate: 2015-08-25 08:34:04\ntags: [QT,VS]\n---\n原帖地址：http://blog.csdn.net/leo115/article/details/7757118\n\n在使用Qt Creator编程时，难免会用到将float类型转换为QString类型的时候下面是我所有的方法：\n1. 将QString类型转化为float类型，很简单\n\n    QString data;            \n    float num = data.toFloat();\n    即可很轻松的实现。\n2. 但是如何将float类型转化为QString类型呢？\n    查看API很难发现封装好的转化函数\n    可以尝试使用下面的代码转化：\n    float num = 1.222;\n    QString data = QString(\"float is %1\").arg(num);\n    输出结果是：float is 1.222\n    如果只要float转化成的数值，则使用如下：\n    QString data = QString(\"%1\").arg(num);\n\n至此完毕。。。。。。。。。。。。。。。。","slug":"13","published":1,"updated":"2015-10-02T01:57:34.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cifj5gkj2004ds8vnazacu7jg"},{"title":"osgi luna 版本依赖问题","date":"2015-08-25T00:33:16.000Z","_content":"最新版的eclipse luna 对于osgi的依赖异常麻烦，为了运行jetty需要添加一下依赖的bundle\n就在这做个总结吧，方便参考，\n\n\n<!--more-->\n\n\n    id  State       Bundle  \n    0   ACTIVE      org.eclipse.osgi_3.10.1.v20140909-1633  \n    1   ACTIVE      org.apache.commons.logging_1.1.1.v201101211721  \n    2   ACTIVE      org.apache.felix.gogo.runtime_0.10.0.v201209301036  \n    3   ACTIVE      org.eclipse.equinox.http.jetty_3.0.200.v20131021-1843  \n    4   ACTIVE      org.eclipse.equinox.console_1.1.0.v20140131-1639  \n    5   ACTIVE      org.apache.felix.gogo.shell_0.10.0.v201212101605  \n    6   ACTIVE      javax.servlet_3.0.0.v201112011016  \n    7   ACTIVE      org.apache.commons.logging_1.0.4.v201101211617  \n    8   ACTIVE      org.eclipse.equinox.http.servlet_1.1.500.v20140318-1755  \n    9   ACTIVE      org.eclipse.osgi.services_3.4.0.v20140312-2051  \n    10  ACTIVE      org.eclipse.jetty.http_8.1.14.v20131031  \n    11  ACTIVE      org.eclipse.jetty.io_8.1.14.v20131031  \n    12  ACTIVE      org.eclipse.jetty.util_8.1.14.v20131031  \n    13  ACTIVE      org.eclipse.jetty.server_8.1.14.v20131031  \n    14  ACTIVE      org.eclipse.jetty.continuation_8.1.14.v20131031  \n    15  ACTIVE      org.eclipse.jetty.servlet_8.1.14.v20131031  \n    16  ACTIVE      org.eclipse.jetty.security_8.1.14.v20131031  \n    17  ACTIVE      org.eclipse.jetty.webapp_8.1.3.v20120522  \n    18  ACTIVE      org.eclipse.jetty.xml_8.1.3.v20120522  \n同时如果是linux下，访问80端口需要权限所以在Run Configurations 中运行配置里面的 Arguments 页签,在 VM arguments 中添加`-Dorg.osgi.service.http.port=8080`\n这样就可以运行了，一般同一版本的osgi不会出现版本问题，就是不用修改版本依赖","source":"_posts/12.md","raw":"title: osgi luna 版本依赖问题\ncategories: 编程与算法\ndate: 2015-08-25 08:33:16\ntags: [osgi]\n---\n最新版的eclipse luna 对于osgi的依赖异常麻烦，为了运行jetty需要添加一下依赖的bundle\n就在这做个总结吧，方便参考，\n\n\n<!--more-->\n\n\n    id  State       Bundle  \n    0   ACTIVE      org.eclipse.osgi_3.10.1.v20140909-1633  \n    1   ACTIVE      org.apache.commons.logging_1.1.1.v201101211721  \n    2   ACTIVE      org.apache.felix.gogo.runtime_0.10.0.v201209301036  \n    3   ACTIVE      org.eclipse.equinox.http.jetty_3.0.200.v20131021-1843  \n    4   ACTIVE      org.eclipse.equinox.console_1.1.0.v20140131-1639  \n    5   ACTIVE      org.apache.felix.gogo.shell_0.10.0.v201212101605  \n    6   ACTIVE      javax.servlet_3.0.0.v201112011016  \n    7   ACTIVE      org.apache.commons.logging_1.0.4.v201101211617  \n    8   ACTIVE      org.eclipse.equinox.http.servlet_1.1.500.v20140318-1755  \n    9   ACTIVE      org.eclipse.osgi.services_3.4.0.v20140312-2051  \n    10  ACTIVE      org.eclipse.jetty.http_8.1.14.v20131031  \n    11  ACTIVE      org.eclipse.jetty.io_8.1.14.v20131031  \n    12  ACTIVE      org.eclipse.jetty.util_8.1.14.v20131031  \n    13  ACTIVE      org.eclipse.jetty.server_8.1.14.v20131031  \n    14  ACTIVE      org.eclipse.jetty.continuation_8.1.14.v20131031  \n    15  ACTIVE      org.eclipse.jetty.servlet_8.1.14.v20131031  \n    16  ACTIVE      org.eclipse.jetty.security_8.1.14.v20131031  \n    17  ACTIVE      org.eclipse.jetty.webapp_8.1.3.v20120522  \n    18  ACTIVE      org.eclipse.jetty.xml_8.1.3.v20120522  \n同时如果是linux下，访问80端口需要权限所以在Run Configurations 中运行配置里面的 Arguments 页签,在 VM arguments 中添加`-Dorg.osgi.service.http.port=8080`\n这样就可以运行了，一般同一版本的osgi不会出现版本问题，就是不用修改版本依赖","slug":"12","published":1,"updated":"2015-10-02T01:57:34.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cifj5gkj5004js8vnizf9t3ad"},{"title":"codeforces content#260 D A Lot of Games","date":"2015-08-25T00:29:53.000Z","_content":"D. A Lot of Games\ntime limit per test 1 second\nmemory limit per test 256 megabytes\ninput standard input\noutput standard output\n\nInput\nThe first line contains two integers, n and k (1≤n≤105; 1≤k≤109).\nEach of the next n lines contains a single non-empty string from the given group. The total length of all strings from the group doesn't exceed 105. Each string of the group consists only of lowercase English letters.\nOutput\nIf the player who moves first wins, print \"First\", otherwise print \"Second\" (without the quotes).\nSample test(s)\ninput\n\n    2 3\n    a\n    b\n\noutput\n\n    First\n\ninput\n\n    3 1\n    a\n    b\n    c\n\noutput\n\n    First\n\ninput\n\n    1 2\n    ab\n\noutput\n\n    Second\n\n\n<!--more-->\n\n\n----------\n题目大意：有两个人在玩一个游戏。首先输入n个字符串，然后这两个人就在一个空的字符串中填字母，填字母的规则是：保证添加字母后的字符串为n个字符串中某个字符串的前缀。二人每次轮流填一个字母，直到某人无法填入字母来满足规则。这个人就输了。然后开始下一局游戏。下一局的先手为上一局输的人。求在第k局的时候，是先手赢还是后手赢（这里说的先手为第一局的先手）。\n若先手赢则输出\"First\"否则输出\"Second\"\n\n在这里，对于先手（这里的先手为本局的先手）来说有四种情况，先手必输、先手必赢、先手可以控制自己的输赢、先手不可控自己的输赢（由后手控制）。\n\n我们用(xx)来表示这四种情况，第一位表示是否可以赢，第二位表示是否可以输。\n\n(01) 对于先手必输，那么下一局他还是先手(因为上一局他输了),然后一直输到k局，先手还是输，则输出\"Second\"。\n(10) 对于先手必赢，那么下一局他为后手，再下一局他又为先手，根据奇偶判断，当为奇数的时候先手赢，为偶数的时候后手赢。\n(11) 对于先手可控输赢，那么他可以使自己前k-1局都输，最后一局赢。\n(00) 对于先手不可控，那么对手可以让他前k-1局一直赢，最后一局输。\n  接下来就要开始思考，怎样来判断这四种情况。\n我们知道，当游戏结束的条件是，无法再往字符串中添加字母，也就是说，这个字符串已经和某个字符串相等了。因为是依次添加，所以只要知道这个字符串的长度的奇偶，就可以判断出先手的输赢。但是前缀可能不止一个串，例如：\nabcde abcedf\n这两个串，当填到abc的时候，就会发生分支，因为两个串的长度差1,所以会造成输赢的差异。当下一个填d的时候，先手赢，但是当c后面填e的时候，后手赢。所以本局游戏的胜负掌握在填第四个字母的人手里，4为偶，所以是后手掌握了输赢，所以用我们的数字表示即为(00)先手不可控输赢。但如果两个字符串的长度一样则会产生(10)或(01)的情况，因为不管选哪个，长度是一样的。\n所以我们需要保存每一次(xx)的情况。\n----------\n\n首先建立一颗字典树。数据结构如下\n\n    struct Trie;  \n    typedef struct Trie *PTrie;  \n    struct Trie{  \n        int info;   //字典值(0~25)  \n        int num;    //下节点数量  \n        PTrie next[M];  //下节点数;  \n        int aut;    //裁决人-下次选择的人  \n        //int val;  //返回值 (00 均不可控、01 输可控 10 赢可控 11 输赢均可控)  \n        Trie(int x, int y){  \n            info = x;  \n            num = 0;  \n            aut = y;  \n            for(int i=0;i<26;i++){  \n                next[i] = NULL;  \n            }  \n        }  \n    };  \n\n这不是一颗正常的字典树，info 值 在本程序里没有用上，不过不影响大局，只是内存多一点。\n首先根据叶子节点的aut值，来判断(xx)为多少，若aut == 1 那么 val = 2 (10)，若 aut == 0 那么 val = 1 (01) 。\n然后沿着字典树向上回溯，若他的上一个节点只有一个分支，那么就不需要判断，继续进行回溯，直到遇到有多个分支的节点。\n当如到有多个分支的节点，每个分支都有一个val值，如果这个节点的裁决人(aut)是先手，那么他便用有这些分支的所有情况，所以用'或'运算来统计该节点的val值，即 val |= next[i]->val\n同理，当该节点的裁决人是后手，那么，先手就无法控制这些情况，但是下属分支的val都一样，那么后手同样无法控制，则代表后手在这个节点的选择权无效，那么先手仍然有控制权，所以为了保证所有的情况都是一样的，进行与运算 val &= next[i]->val\n说的有点不清楚，自己举个例子就明白了。例如：abcde abcee 后手是有选择权的，但是结果最后还是(01)。\n基本上的思路有了，那么就进行回溯的操作。\n\n    int solo(PTrie pt){  \n        if(pt->num == 0){  \n            return pt->aut+1;    //1(01)为输,2(10)为赢  \n        }  \n        int i,va;  \n        if(pt->aut){  \n            va = 3;  \n            for(i=0;i<26;i++){  \n                if(pt->next[i]!=NULL){  \n                    va &= solo(pt->next[i]);  \n                }  \n            }  \n        }else{  \n            va = 0;  \n            for(i=0;i<26;i++){  \n                if(pt->next[i]!=NULL){  \n                    va |= solo(pt->next[i]);  \n                }  \n            }  \n        }  \n        return va;  \n    }  \n\n\n获得最后返回的va  然后根据va的值 转换成二进制 进行判断。\n\n    int x = solo(pt);  \n        //cout<<\"val = \"<<x<<endl;  \n        if(x == 1){  \n            cout<<\"Second\"<<endl;  \n        }else if(x == 3){  \n            cout<<\"First\"<<endl;  \n        }else if(x == 0){  \n            cout<<\"Second\"<<endl;  \n        }else if(k%2){  \n            cout<<\"First\"<<endl;  \n        }else{  \n            cout<<\"Second\"<<endl;  \n        }  \n\n最后贴完整代码，提示：内存可以优化，时间可以降低。因为这个递归进行了许多不必要的操作。\n因为不会用二维数组形式的字典树，只能用数据结构来写了\n\n    ///Time     Memory  \n    ///46 ms    12220 KB  \n    ///codeforces content#260 D A Lot of Games  \n      \n    #include <iostream>  \n    #include <string>  \n    using namespace std;  \n    const int M = 26;  \n    struct Trie;  \n    typedef struct Trie *PTrie;  \n    struct Trie{  \n        int info;   //字典值(0~25)  \n        int num;    //下节点数量  \n        PTrie next[M];  //下节点数;  \n        int aut;    //裁决人-下次选择的人  \n        int val;    //返回值 (00 均不可控一般不存在、01 输可控 10 赢可控 11 输赢均可控)  \n        Trie(int x, int y){  \n            info = x;  \n            num = 0;  \n            aut = y;  \n            for(int i=0;i<26;i++){  \n                next[i] = NULL;  \n            }  \n        }  \n    };  \n    int toi(char c){  \n            return c-'a';  \n    }  \n    PTrie new_t(int num,int aut){  \n        PTrie pt = new Trie(num,aut);  \n    }  \n    void insert(string s,PTrie pt){  \n        int n = s.length();  \n        int i,c;  \n        for(i=0;i<n;i++){  \n            c = toi(s[i]);  \n            if(pt->next[c]!=NULL){  \n                pt = pt->next[c];  \n                continue;  \n            }else{  \n                pt->next[c] = new Trie(c,(i+1)%2);  \n                pt->num++;  \n                pt = pt->next[c];  \n            }  \n        }  \n    }  \n    void output(PTrie pt){  \n        if(pt == NULL)return;  \n        cout<<\"==========\"<<endl;  \n        cout<<\"info= \"<<pt->info<<endl;  \n        cout<<\"num = \"<<pt->num<<endl;  \n        cout<<\"auto= \"<<pt->aut<<endl;  \n        if(pt->num == 0)return;  \n        int i;  \n        for(i=0;i<26;i++){  \n            if(pt->next[i]!=NULL)output(pt->next[i]);  \n        }  \n    }  \n    int solo(PTrie pt){  \n        if(pt->num == 0){  \n            return pt->aut+1;    //1(01)为输,2(10)为赢  \n        }  \n        int i,va;  \n        if(pt->aut){  \n            va = 3;  \n            for(i=0;i<26;i++){  \n                if(pt->next[i]!=NULL){  \n                    va &= solo(pt->next[i]);  \n                }  \n            }  \n        }else{  \n            va = 0;  \n            for(i=0;i<26;i++){  \n                if(pt->next[i]!=NULL){  \n                    va |= solo(pt->next[i]);  \n                }  \n            }  \n        }  \n        return va;  \n    }  \n    void test(){  \n        int y = 3&2;  \n        cout<<\"11&10 = \"<<y<<endl;  \n        y = 2|1;  \n        cout<<\"10|01 = \"<<y<<endl;  \n    }  \n    int main(){  \n        int n;  \n        long k;  \n        cin>>n>>k;  \n        string s;  \n        PTrie pt = new Trie(-1,0);  \n        for (int i = 0; i < n; ++i)  \n        {  \n            cin>>s;  \n            insert(s,pt);  \n        }  \n        //output(pt);  \n        int x = solo(pt);  \n        //cout<<\"val = \"<<x<<endl;  \n        if(x == 1){  \n            cout<<\"Second\"<<endl;  \n        }else if(x == 3){  \n            cout<<\"First\"<<endl;  \n        }else if(x == 0){  \n            cout<<\"Second\"<<endl;  \n        }else if(k%2){  \n            cout<<\"First\"<<endl;  \n        }else{  \n            cout<<\"Second\"<<endl;  \n        }  \n        return 0;  \n    }  \n\n","source":"_posts/11.md","raw":"title: codeforces content#260 D A Lot of Games\ncategories: 编程与算法\ndate: 2015-08-25 08:29:53\ntags: [codeforces,cf,trie]\n---\nD. A Lot of Games\ntime limit per test 1 second\nmemory limit per test 256 megabytes\ninput standard input\noutput standard output\n\nInput\nThe first line contains two integers, n and k (1≤n≤105; 1≤k≤109).\nEach of the next n lines contains a single non-empty string from the given group. The total length of all strings from the group doesn't exceed 105. Each string of the group consists only of lowercase English letters.\nOutput\nIf the player who moves first wins, print \"First\", otherwise print \"Second\" (without the quotes).\nSample test(s)\ninput\n\n    2 3\n    a\n    b\n\noutput\n\n    First\n\ninput\n\n    3 1\n    a\n    b\n    c\n\noutput\n\n    First\n\ninput\n\n    1 2\n    ab\n\noutput\n\n    Second\n\n\n<!--more-->\n\n\n----------\n题目大意：有两个人在玩一个游戏。首先输入n个字符串，然后这两个人就在一个空的字符串中填字母，填字母的规则是：保证添加字母后的字符串为n个字符串中某个字符串的前缀。二人每次轮流填一个字母，直到某人无法填入字母来满足规则。这个人就输了。然后开始下一局游戏。下一局的先手为上一局输的人。求在第k局的时候，是先手赢还是后手赢（这里说的先手为第一局的先手）。\n若先手赢则输出\"First\"否则输出\"Second\"\n\n在这里，对于先手（这里的先手为本局的先手）来说有四种情况，先手必输、先手必赢、先手可以控制自己的输赢、先手不可控自己的输赢（由后手控制）。\n\n我们用(xx)来表示这四种情况，第一位表示是否可以赢，第二位表示是否可以输。\n\n(01) 对于先手必输，那么下一局他还是先手(因为上一局他输了),然后一直输到k局，先手还是输，则输出\"Second\"。\n(10) 对于先手必赢，那么下一局他为后手，再下一局他又为先手，根据奇偶判断，当为奇数的时候先手赢，为偶数的时候后手赢。\n(11) 对于先手可控输赢，那么他可以使自己前k-1局都输，最后一局赢。\n(00) 对于先手不可控，那么对手可以让他前k-1局一直赢，最后一局输。\n  接下来就要开始思考，怎样来判断这四种情况。\n我们知道，当游戏结束的条件是，无法再往字符串中添加字母，也就是说，这个字符串已经和某个字符串相等了。因为是依次添加，所以只要知道这个字符串的长度的奇偶，就可以判断出先手的输赢。但是前缀可能不止一个串，例如：\nabcde abcedf\n这两个串，当填到abc的时候，就会发生分支，因为两个串的长度差1,所以会造成输赢的差异。当下一个填d的时候，先手赢，但是当c后面填e的时候，后手赢。所以本局游戏的胜负掌握在填第四个字母的人手里，4为偶，所以是后手掌握了输赢，所以用我们的数字表示即为(00)先手不可控输赢。但如果两个字符串的长度一样则会产生(10)或(01)的情况，因为不管选哪个，长度是一样的。\n所以我们需要保存每一次(xx)的情况。\n----------\n\n首先建立一颗字典树。数据结构如下\n\n    struct Trie;  \n    typedef struct Trie *PTrie;  \n    struct Trie{  \n        int info;   //字典值(0~25)  \n        int num;    //下节点数量  \n        PTrie next[M];  //下节点数;  \n        int aut;    //裁决人-下次选择的人  \n        //int val;  //返回值 (00 均不可控、01 输可控 10 赢可控 11 输赢均可控)  \n        Trie(int x, int y){  \n            info = x;  \n            num = 0;  \n            aut = y;  \n            for(int i=0;i<26;i++){  \n                next[i] = NULL;  \n            }  \n        }  \n    };  \n\n这不是一颗正常的字典树，info 值 在本程序里没有用上，不过不影响大局，只是内存多一点。\n首先根据叶子节点的aut值，来判断(xx)为多少，若aut == 1 那么 val = 2 (10)，若 aut == 0 那么 val = 1 (01) 。\n然后沿着字典树向上回溯，若他的上一个节点只有一个分支，那么就不需要判断，继续进行回溯，直到遇到有多个分支的节点。\n当如到有多个分支的节点，每个分支都有一个val值，如果这个节点的裁决人(aut)是先手，那么他便用有这些分支的所有情况，所以用'或'运算来统计该节点的val值，即 val |= next[i]->val\n同理，当该节点的裁决人是后手，那么，先手就无法控制这些情况，但是下属分支的val都一样，那么后手同样无法控制，则代表后手在这个节点的选择权无效，那么先手仍然有控制权，所以为了保证所有的情况都是一样的，进行与运算 val &= next[i]->val\n说的有点不清楚，自己举个例子就明白了。例如：abcde abcee 后手是有选择权的，但是结果最后还是(01)。\n基本上的思路有了，那么就进行回溯的操作。\n\n    int solo(PTrie pt){  \n        if(pt->num == 0){  \n            return pt->aut+1;    //1(01)为输,2(10)为赢  \n        }  \n        int i,va;  \n        if(pt->aut){  \n            va = 3;  \n            for(i=0;i<26;i++){  \n                if(pt->next[i]!=NULL){  \n                    va &= solo(pt->next[i]);  \n                }  \n            }  \n        }else{  \n            va = 0;  \n            for(i=0;i<26;i++){  \n                if(pt->next[i]!=NULL){  \n                    va |= solo(pt->next[i]);  \n                }  \n            }  \n        }  \n        return va;  \n    }  \n\n\n获得最后返回的va  然后根据va的值 转换成二进制 进行判断。\n\n    int x = solo(pt);  \n        //cout<<\"val = \"<<x<<endl;  \n        if(x == 1){  \n            cout<<\"Second\"<<endl;  \n        }else if(x == 3){  \n            cout<<\"First\"<<endl;  \n        }else if(x == 0){  \n            cout<<\"Second\"<<endl;  \n        }else if(k%2){  \n            cout<<\"First\"<<endl;  \n        }else{  \n            cout<<\"Second\"<<endl;  \n        }  \n\n最后贴完整代码，提示：内存可以优化，时间可以降低。因为这个递归进行了许多不必要的操作。\n因为不会用二维数组形式的字典树，只能用数据结构来写了\n\n    ///Time     Memory  \n    ///46 ms    12220 KB  \n    ///codeforces content#260 D A Lot of Games  \n      \n    #include <iostream>  \n    #include <string>  \n    using namespace std;  \n    const int M = 26;  \n    struct Trie;  \n    typedef struct Trie *PTrie;  \n    struct Trie{  \n        int info;   //字典值(0~25)  \n        int num;    //下节点数量  \n        PTrie next[M];  //下节点数;  \n        int aut;    //裁决人-下次选择的人  \n        int val;    //返回值 (00 均不可控一般不存在、01 输可控 10 赢可控 11 输赢均可控)  \n        Trie(int x, int y){  \n            info = x;  \n            num = 0;  \n            aut = y;  \n            for(int i=0;i<26;i++){  \n                next[i] = NULL;  \n            }  \n        }  \n    };  \n    int toi(char c){  \n            return c-'a';  \n    }  \n    PTrie new_t(int num,int aut){  \n        PTrie pt = new Trie(num,aut);  \n    }  \n    void insert(string s,PTrie pt){  \n        int n = s.length();  \n        int i,c;  \n        for(i=0;i<n;i++){  \n            c = toi(s[i]);  \n            if(pt->next[c]!=NULL){  \n                pt = pt->next[c];  \n                continue;  \n            }else{  \n                pt->next[c] = new Trie(c,(i+1)%2);  \n                pt->num++;  \n                pt = pt->next[c];  \n            }  \n        }  \n    }  \n    void output(PTrie pt){  \n        if(pt == NULL)return;  \n        cout<<\"==========\"<<endl;  \n        cout<<\"info= \"<<pt->info<<endl;  \n        cout<<\"num = \"<<pt->num<<endl;  \n        cout<<\"auto= \"<<pt->aut<<endl;  \n        if(pt->num == 0)return;  \n        int i;  \n        for(i=0;i<26;i++){  \n            if(pt->next[i]!=NULL)output(pt->next[i]);  \n        }  \n    }  \n    int solo(PTrie pt){  \n        if(pt->num == 0){  \n            return pt->aut+1;    //1(01)为输,2(10)为赢  \n        }  \n        int i,va;  \n        if(pt->aut){  \n            va = 3;  \n            for(i=0;i<26;i++){  \n                if(pt->next[i]!=NULL){  \n                    va &= solo(pt->next[i]);  \n                }  \n            }  \n        }else{  \n            va = 0;  \n            for(i=0;i<26;i++){  \n                if(pt->next[i]!=NULL){  \n                    va |= solo(pt->next[i]);  \n                }  \n            }  \n        }  \n        return va;  \n    }  \n    void test(){  \n        int y = 3&2;  \n        cout<<\"11&10 = \"<<y<<endl;  \n        y = 2|1;  \n        cout<<\"10|01 = \"<<y<<endl;  \n    }  \n    int main(){  \n        int n;  \n        long k;  \n        cin>>n>>k;  \n        string s;  \n        PTrie pt = new Trie(-1,0);  \n        for (int i = 0; i < n; ++i)  \n        {  \n            cin>>s;  \n            insert(s,pt);  \n        }  \n        //output(pt);  \n        int x = solo(pt);  \n        //cout<<\"val = \"<<x<<endl;  \n        if(x == 1){  \n            cout<<\"Second\"<<endl;  \n        }else if(x == 3){  \n            cout<<\"First\"<<endl;  \n        }else if(x == 0){  \n            cout<<\"Second\"<<endl;  \n        }else if(k%2){  \n            cout<<\"First\"<<endl;  \n        }else{  \n            cout<<\"Second\"<<endl;  \n        }  \n        return 0;  \n    }  \n\n","slug":"11","published":1,"updated":"2015-10-02T01:57:34.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cifj5gkj8004ns8vnwhtbl2pj"},{"title":"Trie树 hihoCoder","date":"2015-08-25T00:28:52.000Z","_content":"时间限制:10000ms\n单点时限:1000ms\n内存限制:256MB\n描述\n小Hi和小Ho是一对好朋友，出生在信息化社会的他们对编程产生了莫大的兴趣，他们约定好互相帮助，在编程的学习道路上一同前进。\n\n这一天，他们遇到了一本词典，于是小Hi就向小Ho提出了那个经典的问题：“小Ho，你能不能对于每一个我给出的字符串，都在这个词典里面找到以这个字符串开头的所有单词呢？”\n\n身经百战的小Ho答道：“怎么会不能呢！你每给我一个字符串，我就依次遍历词典里的所有单词，检查你给我的字符串是不是这个单词的前缀不就是了？”\n\n小Hi笑道：“你啊，还是太年轻了！~假设这本词典里有10万个单词，我询问你一万次，你得要算到哪年哪月去？”\n\n小Ho低头算了一算，看着那一堆堆的0，顿时感觉自己这辈子都要花在上面了...\n\n小Hi看着小Ho的囧样，也是继续笑道：“让我来提高一下你的知识水平吧~你知道树这样一种数据结构么？”\n\n小Ho想了想，说道：“知道~它是一种基础的数据结构，就像这里说的一样！”\n\n小Hi满意的点了点头，说道：“那你知道我怎么样用一棵树来表示整个词典么？”\n\n小Ho摇摇头表示自己不清楚。\n\n“你看，我们现在得到了这样一棵树，那么你看，如果我给你一个字符串ap，你要怎么找到所有以ap开头的单词呢？”小Hi又开始考校小Ho。\n\n“唔...一个个遍历所有的单词？”小Ho还是不忘自己最开始提出来的算法。\n\n“笨！这棵树难道就白构建了！”小Hi教训完小Ho，继续道：“看好了！”\n\n“那么现在！赶紧去用代码实现吧！”小Hi如是说道\n\n\n<!--more-->\n\n\n输入\n输入的第一行为一个正整数n，表示词典的大小，其后n行，每一行一个单词（不保证是英文单词，也有可能是火星文单词哦），单词由不超过10个的小写英文字母组成，可能存在相同的单词，此时应将其视作不同的单词。接下来的一行为一个正整数m，表示小Hi询问的次数，其后m行，每一行一个字符串，该字符串由不超过10个的小写英文字母组成，表示小Hi的一个询问。\n\n在20%的数据中n, m<=10，词典的字母表大小<=2.\n\n在60%的数据中n, m<=1000，词典的字母表大小<=5.\n\n在100%的数据中n, m<=100000，词典的字母表大小<=26.\n\n输出\n对于小Hi的每一个询问，输出一个整数Ans,表示词典中以小Hi给出的字符串为前缀的单词的个数。\n\n样例输入\n```\n5\nbabaab\nbabbbaaaa\nabba\naaaaabaa\nbabaababb\n5\nbabb\nbaabaaa\nbab\nbb\nbbabbaab\n```\n样例输出\n```\n1\n0\n3\n0\n0\n```\n\n\n----------\n建立一个自定义结构体\n```cpp\nstruct Tree;  \ntypedef struct Tree *PTree;   \nstruct Tree{  \n        char let;   //该结构体代表低字母  \n        int count;//经过该结点的单词数  \n        PTree next[MAX];//指向子结构  \n};  \n```\nlet貌似没有用上 不过没有关系 \n执行find函数后 查找到最后一个字母然后返回该结点低count即为结果\n```cpp\n#include <iostream>  \n#include <string>  \nusing namespace std;  \nconst int MAX=26;  \nstruct Tree;  \ntypedef struct Tree *PTree;   \nstruct Tree{  \n        char let;  \n        int count;  \n        PTree next[MAX];  \n};  \nPTree root[MAX];  \nvoid init(){  \n    for(int i=0;i<MAX;i++){  \n            root[i] = new Tree();  \n            root[i]->let = i+'a';  \n            root[i]->count = 0;  \n            for(int j=0;j<MAX;j++){  \n                    root[i]->next[j] = NULL;  \n            }  \n    }  \n      \n    }  \nvoid linkTree(PTree par,char let ){  \n        PTree t = new Tree();  \n        int n = let-'a';  \n        t->let = let;  \n        t->count = 0;  \n        for(int i=0;i<MAX;i++){  \n                t->next[i] = NULL;  \n        }  \n        par->next[n] = t;  \n}  \nvoid buildTree(string str){  \n        int n = str.length();  \n        int st = str[0]-'a';  \n        PTree p = root[st];  \n        p->count++;  \n        for(int i=1;i<n;i++){  \n                int num = str[i] - 'a';  \n                if(p->next[num] == NULL){  \n                        linkTree(p,str[i]);  \n                }  \n                p = p->next[num];  \n                p->count++;  \n        }  \n}  \nint find(string str){  \n        int n = str.length();  \n        int st = str[0]-'a';  \n        if(root[st] == NULL)return 0;  \n        PTree p = root[st];  \n        for(int i=1;i<n;i++){  \n                int x = str[i]-'a';  \n                if(p->next[x]!=NULL){  \n                        p = p->next[x];  \n                }else{  \n                        return 0;  \n                }  \n              \n        }  \n        return p->count;  \n}  \nint main(){  \n        int i,n;  \n        string s;  \n        init();  \n        cin>>n;  \n        for(i=0;i<n;i++){  \n            cin>>s;  \n            buildTree(s);  \n        }  \n        cin>>n;  \n        for(i=0;i<n;i++){  \n            cin>>s;  \n            cout<<find(s)<<endl;  \n        }  \n        return 0;  \n}  \n```","source":"_posts/10.md","raw":"title: Trie树 hihoCoder\ncategories: 编程与算法\ndate: 2015-08-25 08:28:52\ntags: [trie,acm,hihocoder]\n---\n时间限制:10000ms\n单点时限:1000ms\n内存限制:256MB\n描述\n小Hi和小Ho是一对好朋友，出生在信息化社会的他们对编程产生了莫大的兴趣，他们约定好互相帮助，在编程的学习道路上一同前进。\n\n这一天，他们遇到了一本词典，于是小Hi就向小Ho提出了那个经典的问题：“小Ho，你能不能对于每一个我给出的字符串，都在这个词典里面找到以这个字符串开头的所有单词呢？”\n\n身经百战的小Ho答道：“怎么会不能呢！你每给我一个字符串，我就依次遍历词典里的所有单词，检查你给我的字符串是不是这个单词的前缀不就是了？”\n\n小Hi笑道：“你啊，还是太年轻了！~假设这本词典里有10万个单词，我询问你一万次，你得要算到哪年哪月去？”\n\n小Ho低头算了一算，看着那一堆堆的0，顿时感觉自己这辈子都要花在上面了...\n\n小Hi看着小Ho的囧样，也是继续笑道：“让我来提高一下你的知识水平吧~你知道树这样一种数据结构么？”\n\n小Ho想了想，说道：“知道~它是一种基础的数据结构，就像这里说的一样！”\n\n小Hi满意的点了点头，说道：“那你知道我怎么样用一棵树来表示整个词典么？”\n\n小Ho摇摇头表示自己不清楚。\n\n“你看，我们现在得到了这样一棵树，那么你看，如果我给你一个字符串ap，你要怎么找到所有以ap开头的单词呢？”小Hi又开始考校小Ho。\n\n“唔...一个个遍历所有的单词？”小Ho还是不忘自己最开始提出来的算法。\n\n“笨！这棵树难道就白构建了！”小Hi教训完小Ho，继续道：“看好了！”\n\n“那么现在！赶紧去用代码实现吧！”小Hi如是说道\n\n\n<!--more-->\n\n\n输入\n输入的第一行为一个正整数n，表示词典的大小，其后n行，每一行一个单词（不保证是英文单词，也有可能是火星文单词哦），单词由不超过10个的小写英文字母组成，可能存在相同的单词，此时应将其视作不同的单词。接下来的一行为一个正整数m，表示小Hi询问的次数，其后m行，每一行一个字符串，该字符串由不超过10个的小写英文字母组成，表示小Hi的一个询问。\n\n在20%的数据中n, m<=10，词典的字母表大小<=2.\n\n在60%的数据中n, m<=1000，词典的字母表大小<=5.\n\n在100%的数据中n, m<=100000，词典的字母表大小<=26.\n\n输出\n对于小Hi的每一个询问，输出一个整数Ans,表示词典中以小Hi给出的字符串为前缀的单词的个数。\n\n样例输入\n```\n5\nbabaab\nbabbbaaaa\nabba\naaaaabaa\nbabaababb\n5\nbabb\nbaabaaa\nbab\nbb\nbbabbaab\n```\n样例输出\n```\n1\n0\n3\n0\n0\n```\n\n\n----------\n建立一个自定义结构体\n```cpp\nstruct Tree;  \ntypedef struct Tree *PTree;   \nstruct Tree{  \n        char let;   //该结构体代表低字母  \n        int count;//经过该结点的单词数  \n        PTree next[MAX];//指向子结构  \n};  \n```\nlet貌似没有用上 不过没有关系 \n执行find函数后 查找到最后一个字母然后返回该结点低count即为结果\n```cpp\n#include <iostream>  \n#include <string>  \nusing namespace std;  \nconst int MAX=26;  \nstruct Tree;  \ntypedef struct Tree *PTree;   \nstruct Tree{  \n        char let;  \n        int count;  \n        PTree next[MAX];  \n};  \nPTree root[MAX];  \nvoid init(){  \n    for(int i=0;i<MAX;i++){  \n            root[i] = new Tree();  \n            root[i]->let = i+'a';  \n            root[i]->count = 0;  \n            for(int j=0;j<MAX;j++){  \n                    root[i]->next[j] = NULL;  \n            }  \n    }  \n      \n    }  \nvoid linkTree(PTree par,char let ){  \n        PTree t = new Tree();  \n        int n = let-'a';  \n        t->let = let;  \n        t->count = 0;  \n        for(int i=0;i<MAX;i++){  \n                t->next[i] = NULL;  \n        }  \n        par->next[n] = t;  \n}  \nvoid buildTree(string str){  \n        int n = str.length();  \n        int st = str[0]-'a';  \n        PTree p = root[st];  \n        p->count++;  \n        for(int i=1;i<n;i++){  \n                int num = str[i] - 'a';  \n                if(p->next[num] == NULL){  \n                        linkTree(p,str[i]);  \n                }  \n                p = p->next[num];  \n                p->count++;  \n        }  \n}  \nint find(string str){  \n        int n = str.length();  \n        int st = str[0]-'a';  \n        if(root[st] == NULL)return 0;  \n        PTree p = root[st];  \n        for(int i=1;i<n;i++){  \n                int x = str[i]-'a';  \n                if(p->next[x]!=NULL){  \n                        p = p->next[x];  \n                }else{  \n                        return 0;  \n                }  \n              \n        }  \n        return p->count;  \n}  \nint main(){  \n        int i,n;  \n        string s;  \n        init();  \n        cin>>n;  \n        for(i=0;i<n;i++){  \n            cin>>s;  \n            buildTree(s);  \n        }  \n        cin>>n;  \n        for(i=0;i<n;i++){  \n            cin>>s;  \n            cout<<find(s)<<endl;  \n        }  \n        return 0;  \n}  \n```","slug":"10","published":1,"updated":"2015-10-02T02:41:05.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cifj5gkjh004vs8vnim10h0v4"}],"PostAsset":[],"PostCategory":[{"post_id":"cifj5gkf10000s8vnfcza5p92","category_id":"cifj5gkf50001s8vnek3awl0b","_id":"cifj5gkf70004s8vnnko1cjge"},{"post_id":"cifj5gkf90007s8vnvb6y75yd","category_id":"cifj5gkf50001s8vnek3awl0b","_id":"cifj5gkfa0008s8vn0f7fwvto"},{"post_id":"cifj5gkfc000ds8vnq3eltf3g","category_id":"cifj5gkfc000es8vn5zr2mzfw","_id":"cifj5gkfd000hs8vn7j0la254"},{"post_id":"cifj5gkfe000ks8vn69glqvxn","category_id":"cifj5gkf50001s8vnek3awl0b","_id":"cifj5gkff000ls8vnvuwf5f3v"},{"post_id":"cifj5gkfh000ps8vn63h0gkk1","category_id":"cifj5gkfc000es8vn5zr2mzfw","_id":"cifj5gkfj000qs8vnl6m6zd2m"},{"post_id":"cifj5gkfk000us8vn1hvan6ua","category_id":"cifj5gkfc000es8vn5zr2mzfw","_id":"cifj5gkfl000vs8vnpmsbj41w"},{"post_id":"cifj5gkfo0011s8vn2vnm4v0b","category_id":"cifj5gkfc000es8vn5zr2mzfw","_id":"cifj5gkfp0012s8vnkfvcx6lw"},{"post_id":"cifj5gkfr0016s8vnz0usdwrs","category_id":"cifj5gkfc000es8vn5zr2mzfw","_id":"cifj5gkfs0017s8vnp9khcdyh"},{"post_id":"cifj5gkft001ds8vn0sa617rm","category_id":"cifj5gkf50001s8vnek3awl0b","_id":"cifj5gkfu001es8vncgo9urby"},{"post_id":"cifj5gkfy001ns8vngpyco0wk","category_id":"cifj5gkf50001s8vnek3awl0b","_id":"cifj5gkfy001os8vn26ahmqep"},{"post_id":"cifj5gkg1001us8vnuoqdatfb","category_id":"cifj5gkf50001s8vnek3awl0b","_id":"cifj5gkg3001vs8vn3kf4nf6h"},{"post_id":"cifj5gkg60021s8vn3556ipze","category_id":"cifj5gkf50001s8vnek3awl0b","_id":"cifj5gkg60022s8vnf88z14yn"},{"post_id":"cifj5gkg90028s8vnmw0es1a7","category_id":"cifj5gkf50001s8vnek3awl0b","_id":"cifj5gkga0029s8vnju9dxfey"},{"post_id":"cifj5gkgc002es8vnyz6nm0b7","category_id":"cifj5gkf50001s8vnek3awl0b","_id":"cifj5gkgd002fs8vn2y06dy8o"},{"post_id":"cifj5gkgh002js8vnbhht3ss2","category_id":"cifj5gkfc000es8vn5zr2mzfw","_id":"cifj5gkgi002ks8vnd51tiw6a"},{"post_id":"cifj5gkgk002rs8vnleo7wc7c","category_id":"cifj5gkgk002ss8vncvoa0xb2","_id":"cifj5gkgl002vs8vnlmed6ngt"},{"post_id":"cifj5gkgm002ys8vnno3t7g7g","category_id":"cifj5gkfc000es8vn5zr2mzfw","_id":"cifj5gkgn002zs8vn192a2uh9"},{"post_id":"cifj5gkgp0036s8vn9kfbxidu","category_id":"cifj5gkf50001s8vnek3awl0b","_id":"cifj5gkgq0037s8vneym3aev2"},{"post_id":"cifj5gkgr003as8vn02q1ohwi","category_id":"cifj5gkf50001s8vnek3awl0b","_id":"cifj5gkgs003bs8vn3c25nf3u"},{"post_id":"cifj5gkgt003es8vn1k5bo3fy","category_id":"cifj5gkf50001s8vnek3awl0b","_id":"cifj5gkgu003fs8vnmrnrw13n"},{"post_id":"cifj5gkgv003hs8vnwnge6foz","category_id":"cifj5gkf50001s8vnek3awl0b","_id":"cifj5gkgw003is8vntamjhkff"},{"post_id":"cifj5gkgy003ks8vncm5o3u8t","category_id":"cifj5gkf50001s8vnek3awl0b","_id":"cifj5gkgy003ls8vn8n0rlrit"},{"post_id":"cifj5gkh0003ns8vn7snwoqxx","category_id":"cifj5gkf50001s8vnek3awl0b","_id":"cifj5gkh1003os8vnppssovh2"},{"post_id":"cifj5gkh2003qs8vnuai3xfzt","category_id":"cifj5gkf50001s8vnek3awl0b","_id":"cifj5gkh3003rs8vnu6kf4xpm"},{"post_id":"cifj5gkh6003vs8vnfwxxcyqt","category_id":"cifj5gkf50001s8vnek3awl0b","_id":"cifj5gkh7003ws8vngqabahqt"},{"post_id":"cifj5gkh8003ys8vno0wa7oea","category_id":"cifj5gkf50001s8vnek3awl0b","_id":"cifj5gkh9003zs8vnvzyyiq0m"},{"post_id":"cifj5gkha0041s8vng7x08k1q","category_id":"cifj5gkf50001s8vnek3awl0b","_id":"cifj5gkhb0042s8vnamflflcl"},{"post_id":"cifj5gkiw0044s8vn0atc7r2d","category_id":"cifj5gkf50001s8vnek3awl0b","_id":"cifj5gkix0045s8vn4xtcm7dw"},{"post_id":"cifj5gkiy0047s8vnxygcvq57","category_id":"cifj5gkf50001s8vnek3awl0b","_id":"cifj5gkiz0048s8vn7udbgfba"},{"post_id":"cifj5gkiz004as8vno4zf9cv1","category_id":"cifj5gkf50001s8vnek3awl0b","_id":"cifj5gkj0004bs8vncp8fgoa2"},{"post_id":"cifj5gkj2004ds8vnazacu7jg","category_id":"cifj5gkf50001s8vnek3awl0b","_id":"cifj5gkj2004es8vnminrg0kh"},{"post_id":"cifj5gkj5004js8vnizf9t3ad","category_id":"cifj5gkf50001s8vnek3awl0b","_id":"cifj5gkj5004ks8vnq1e0hkf9"},{"post_id":"cifj5gkj8004ns8vnwhtbl2pj","category_id":"cifj5gkf50001s8vnek3awl0b","_id":"cifj5gkj9004os8vn9rfqzhk7"},{"post_id":"cifj5gkjh004vs8vnim10h0v4","category_id":"cifj5gkf50001s8vnek3awl0b","_id":"cifj5gkji004ws8vny50d630i"}],"PostTag":[{"post_id":"cifj5gkf10000s8vnfcza5p92","tag_id":"cifj5gkf50002s8vniqy3yqhi","_id":"cifj5gkf70005s8vn0mh12oaf"},{"post_id":"cifj5gkf10000s8vnfcza5p92","tag_id":"cifj5gkf60003s8vnzgm1uq1s","_id":"cifj5gkf70006s8vnmehqdiv0"},{"post_id":"cifj5gkf90007s8vnvb6y75yd","tag_id":"cifj5gkfa0009s8vnnd82321e","_id":"cifj5gkfb000bs8vngfifa6ul"},{"post_id":"cifj5gkf90007s8vnvb6y75yd","tag_id":"cifj5gkfa000as8vn7i35flal","_id":"cifj5gkfb000cs8vn7631ns04"},{"post_id":"cifj5gkfc000ds8vnq3eltf3g","tag_id":"cifj5gkfc000fs8vngsuqooun","_id":"cifj5gkfd000is8vnf6f6ypl8"},{"post_id":"cifj5gkfc000ds8vnq3eltf3g","tag_id":"cifj5gkfd000gs8vnpsw1wozg","_id":"cifj5gkfd000js8vntttxazxv"},{"post_id":"cifj5gkfe000ks8vn69glqvxn","tag_id":"cifj5gkff000ms8vn09uw9ohi","_id":"cifj5gkfg000ns8vn46udrass"},{"post_id":"cifj5gkfe000ks8vn69glqvxn","tag_id":"cifj5gkfa0009s8vnnd82321e","_id":"cifj5gkfg000os8vnzoylrg5b"},{"post_id":"cifj5gkfh000ps8vn63h0gkk1","tag_id":"cifj5gkfc000fs8vngsuqooun","_id":"cifj5gkfj000ss8vnw29ra0ai"},{"post_id":"cifj5gkfh000ps8vn63h0gkk1","tag_id":"cifj5gkfj000rs8vna4n3p69o","_id":"cifj5gkfj000ts8vnmvhbvepu"},{"post_id":"cifj5gkfk000us8vn1hvan6ua","tag_id":"cifj5gkfc000fs8vngsuqooun","_id":"cifj5gkfm000ys8vnmm4y16vy"},{"post_id":"cifj5gkfk000us8vn1hvan6ua","tag_id":"cifj5gkfm000ws8vnrritx7d0","_id":"cifj5gkfm000zs8vnotgohpot"},{"post_id":"cifj5gkfk000us8vn1hvan6ua","tag_id":"cifj5gkfm000xs8vn7f1nxq5f","_id":"cifj5gkfm0010s8vnw9glunid"},{"post_id":"cifj5gkfo0011s8vn2vnm4v0b","tag_id":"cifj5gkfp0013s8vntzczn5lb","_id":"cifj5gkfq0014s8vn0nmhbth6"},{"post_id":"cifj5gkfo0011s8vn2vnm4v0b","tag_id":"cifj5gkfc000fs8vngsuqooun","_id":"cifj5gkfq0015s8vnqsc036bm"},{"post_id":"cifj5gkfr0016s8vnz0usdwrs","tag_id":"cifj5gkfc000fs8vngsuqooun","_id":"cifj5gkft001as8vnrf5ngvpn"},{"post_id":"cifj5gkfr0016s8vnz0usdwrs","tag_id":"cifj5gkfs0018s8vnq5kpof6p","_id":"cifj5gkft001bs8vn8rm543ir"},{"post_id":"cifj5gkfr0016s8vnz0usdwrs","tag_id":"cifj5gkfs0019s8vnfzu23rsf","_id":"cifj5gkft001cs8vnycxvamzz"},{"post_id":"cifj5gkft001ds8vn0sa617rm","tag_id":"cifj5gkfu001fs8vne2vu69d7","_id":"cifj5gkfw001js8vnynuurybc"},{"post_id":"cifj5gkft001ds8vn0sa617rm","tag_id":"cifj5gkfv001gs8vnvzp9tbsj","_id":"cifj5gkfx001ks8vngxfakp7r"},{"post_id":"cifj5gkft001ds8vn0sa617rm","tag_id":"cifj5gkfv001hs8vn9xls92e8","_id":"cifj5gkfx001ls8vn4r9kv9uf"},{"post_id":"cifj5gkft001ds8vn0sa617rm","tag_id":"cifj5gkfw001is8vn1q1jblu1","_id":"cifj5gkfx001ms8vn2s7h9xkz"},{"post_id":"cifj5gkfy001ns8vngpyco0wk","tag_id":"cifj5gkfu001fs8vne2vu69d7","_id":"cifj5gkg0001qs8vn50i0dp9z"},{"post_id":"cifj5gkfy001ns8vngpyco0wk","tag_id":"cifj5gkfv001gs8vnvzp9tbsj","_id":"cifj5gkg0001rs8vnq45pymht"},{"post_id":"cifj5gkfy001ns8vngpyco0wk","tag_id":"cifj5gkfv001hs8vn9xls92e8","_id":"cifj5gkg0001ss8vnkw38vqm6"},{"post_id":"cifj5gkfy001ns8vngpyco0wk","tag_id":"cifj5gkfz001ps8vnd2olnkt7","_id":"cifj5gkg1001ts8vn85qzeo0s"},{"post_id":"cifj5gkg1001us8vnuoqdatfb","tag_id":"cifj5gkfu001fs8vne2vu69d7","_id":"cifj5gkg4001xs8vn05by4sw0"},{"post_id":"cifj5gkg1001us8vnuoqdatfb","tag_id":"cifj5gkfv001gs8vnvzp9tbsj","_id":"cifj5gkg5001ys8vnpnf20a79"},{"post_id":"cifj5gkg1001us8vnuoqdatfb","tag_id":"cifj5gkfv001hs8vn9xls92e8","_id":"cifj5gkg5001zs8vnl0p4sgus"},{"post_id":"cifj5gkg1001us8vnuoqdatfb","tag_id":"cifj5gkg4001ws8vnj4ar7r23","_id":"cifj5gkg50020s8vn9v3nhhwq"},{"post_id":"cifj5gkg60021s8vn3556ipze","tag_id":"cifj5gkfu001fs8vne2vu69d7","_id":"cifj5gkg70024s8vnzri05afh"},{"post_id":"cifj5gkg60021s8vn3556ipze","tag_id":"cifj5gkfv001gs8vnvzp9tbsj","_id":"cifj5gkg80025s8vnazesvgmd"},{"post_id":"cifj5gkg60021s8vn3556ipze","tag_id":"cifj5gkfv001hs8vn9xls92e8","_id":"cifj5gkg80026s8vnutb3mo5n"},{"post_id":"cifj5gkg60021s8vn3556ipze","tag_id":"cifj5gkg70023s8vna77fr1a2","_id":"cifj5gkg80027s8vniqa3jpk2"},{"post_id":"cifj5gkg90028s8vnmw0es1a7","tag_id":"cifj5gkgb002as8vnz310bcsk","_id":"cifj5gkgc002cs8vnnb80qvvp"},{"post_id":"cifj5gkg90028s8vnmw0es1a7","tag_id":"cifj5gkgb002bs8vn8ofkj1i3","_id":"cifj5gkgc002ds8vne0zgthm9"},{"post_id":"cifj5gkgc002es8vnyz6nm0b7","tag_id":"cifj5gkfu001fs8vne2vu69d7","_id":"cifj5gkgd002gs8vn33x1zva6"},{"post_id":"cifj5gkgc002es8vnyz6nm0b7","tag_id":"cifj5gkfv001gs8vnvzp9tbsj","_id":"cifj5gkge002hs8vnabhddvft"},{"post_id":"cifj5gkgc002es8vnyz6nm0b7","tag_id":"cifj5gkfv001hs8vn9xls92e8","_id":"cifj5gkge002is8vn3w3by3fc"},{"post_id":"cifj5gkgh002js8vnbhht3ss2","tag_id":"cifj5gkgi002ls8vn6uxnlzff","_id":"cifj5gkgj002os8vnav7k0dr7"},{"post_id":"cifj5gkgh002js8vnbhht3ss2","tag_id":"cifj5gkgi002ms8vn0i69s5is","_id":"cifj5gkgj002ps8vnnoao43pr"},{"post_id":"cifj5gkgh002js8vnbhht3ss2","tag_id":"cifj5gkgi002ns8vnbp3s744j","_id":"cifj5gkgj002qs8vn0s3sokyi"},{"post_id":"cifj5gkgk002rs8vnleo7wc7c","tag_id":"cifj5gkgk002ts8vnagmjofjz","_id":"cifj5gkgl002ws8vnb0orq912"},{"post_id":"cifj5gkgk002rs8vnleo7wc7c","tag_id":"cifj5gkgl002us8vnppmtdz3a","_id":"cifj5gkgl002xs8vnqo2gu1nw"},{"post_id":"cifj5gkgm002ys8vnno3t7g7g","tag_id":"cifj5gkgn0030s8vnwd5pvjt9","_id":"cifj5gkgo0033s8vn2djm11fa"},{"post_id":"cifj5gkgm002ys8vnno3t7g7g","tag_id":"cifj5gkgn0031s8vn1uvzgk07","_id":"cifj5gkgo0034s8vncdw8wtbc"},{"post_id":"cifj5gkgm002ys8vnno3t7g7g","tag_id":"cifj5gkgo0032s8vnofrenxrq","_id":"cifj5gkgo0035s8vn8jjztq1r"},{"post_id":"cifj5gkgp0036s8vn9kfbxidu","tag_id":"cifj5gkgb002as8vnz310bcsk","_id":"cifj5gkgq0038s8vnoyf6s4w4"},{"post_id":"cifj5gkgp0036s8vn9kfbxidu","tag_id":"cifj5gkfm000xs8vn7f1nxq5f","_id":"cifj5gkgq0039s8vnjo29w2az"},{"post_id":"cifj5gkgr003as8vn02q1ohwi","tag_id":"cifj5gkgb002as8vnz310bcsk","_id":"cifj5gkgs003cs8vn7dla36x7"},{"post_id":"cifj5gkgr003as8vn02q1ohwi","tag_id":"cifj5gkfm000xs8vn7f1nxq5f","_id":"cifj5gkgt003ds8vn0urubeua"},{"post_id":"cifj5gkgt003es8vn1k5bo3fy","tag_id":"cifj5gkgb002as8vnz310bcsk","_id":"cifj5gkgu003gs8vn0n43pe0q"},{"post_id":"cifj5gkgv003hs8vnwnge6foz","tag_id":"cifj5gkgb002as8vnz310bcsk","_id":"cifj5gkgx003js8vn9xd9ifg2"},{"post_id":"cifj5gkgy003ks8vncm5o3u8t","tag_id":"cifj5gkgb002as8vnz310bcsk","_id":"cifj5gkgz003ms8vnsudn4ujz"},{"post_id":"cifj5gkh0003ns8vn7snwoqxx","tag_id":"cifj5gkgb002as8vnz310bcsk","_id":"cifj5gkh1003ps8vnkbhtou62"},{"post_id":"cifj5gkh2003qs8vnuai3xfzt","tag_id":"cifj5gkfv001gs8vnvzp9tbsj","_id":"cifj5gkh3003ts8vn5l5gs8g2"},{"post_id":"cifj5gkh2003qs8vnuai3xfzt","tag_id":"cifj5gkh3003ss8vnropvit62","_id":"cifj5gkh3003us8vnv31saqfz"},{"post_id":"cifj5gkh6003vs8vnfwxxcyqt","tag_id":"cifj5gkgb002as8vnz310bcsk","_id":"cifj5gkh7003xs8vn2edvfcf5"},{"post_id":"cifj5gkh8003ys8vno0wa7oea","tag_id":"cifj5gkgb002as8vnz310bcsk","_id":"cifj5gkh90040s8vncdas9k5r"},{"post_id":"cifj5gkha0041s8vng7x08k1q","tag_id":"cifj5gkgb002as8vnz310bcsk","_id":"cifj5gkhb0043s8vnyv6zo3c3"},{"post_id":"cifj5gkiw0044s8vn0atc7r2d","tag_id":"cifj5gkgb002as8vnz310bcsk","_id":"cifj5gkix0046s8vnj17nqeks"},{"post_id":"cifj5gkiy0047s8vnxygcvq57","tag_id":"cifj5gkgb002as8vnz310bcsk","_id":"cifj5gkiz0049s8vn0liwuyuf"},{"post_id":"cifj5gkiz004as8vno4zf9cv1","tag_id":"cifj5gkgb002as8vnz310bcsk","_id":"cifj5gkj0004cs8vnengtlkoc"},{"post_id":"cifj5gkj2004ds8vnazacu7jg","tag_id":"cifj5gkj2004fs8vnoo66o87x","_id":"cifj5gkj3004hs8vntdvwxli7"},{"post_id":"cifj5gkj2004ds8vnazacu7jg","tag_id":"cifj5gkj3004gs8vnipz905x6","_id":"cifj5gkj3004is8vnmfrayzn2"},{"post_id":"cifj5gkj5004js8vnizf9t3ad","tag_id":"cifj5gkj5004ls8vngjptr9sh","_id":"cifj5gkj6004ms8vn2qwghsb7"},{"post_id":"cifj5gkj8004ns8vnwhtbl2pj","tag_id":"cifj5gkj9004ps8vnezd9iz9b","_id":"cifj5gkjd004ss8vno6rfn2by"},{"post_id":"cifj5gkj8004ns8vnwhtbl2pj","tag_id":"cifj5gkja004qs8vnrr918602","_id":"cifj5gkjd004ts8vn1c2dievd"},{"post_id":"cifj5gkj8004ns8vnwhtbl2pj","tag_id":"cifj5gkja004rs8vn7kp54yvu","_id":"cifj5gkjd004us8vnm6l7rbjb"},{"post_id":"cifj5gkjh004vs8vnim10h0v4","tag_id":"cifj5gkja004rs8vn7kp54yvu","_id":"cifj5gkji004ys8vnkeytrufb"},{"post_id":"cifj5gkjh004vs8vnim10h0v4","tag_id":"cifj5gkff000ms8vn09uw9ohi","_id":"cifj5gkjj004zs8vnzm1vx31h"},{"post_id":"cifj5gkjh004vs8vnim10h0v4","tag_id":"cifj5gkji004xs8vnr0v3h8ob","_id":"cifj5gkjj0050s8vnheb9irgw"}],"Tag":[{"name":"asm","_id":"cifj5gkf50002s8vniqy3yqhi"},{"name":"课后练习","_id":"cifj5gkf60003s8vnzgm1uq1s"},{"name":"poj","_id":"cifj5gkfa0009s8vnnd82321e"},{"name":"uniun","_id":"cifj5gkfa000as8vn7i35flal"},{"name":"ubuntu","_id":"cifj5gkfc000fs8vngsuqooun"},{"name":"vpn","_id":"cifj5gkfd000gs8vnpsw1wozg"},{"name":"acm","_id":"cifj5gkff000ms8vn09uw9ohi"},{"name":"software","_id":"cifj5gkfj000rs8vna4n3p69o"},{"name":"shadowsocks","_id":"cifj5gkfm000ws8vnrritx7d0"},{"name":"ss","_id":"cifj5gkfm000xs8vn7f1nxq5f"},{"name":"Android","_id":"cifj5gkfp0013s8vntzczn5lb"},{"name":"virtualbox","_id":"cifj5gkfs0018s8vnq5kpof6p"},{"name":"error","_id":"cifj5gkfs0019s8vnfzu23rsf"},{"name":"最短路","_id":"cifj5gkfu001fs8vne2vu69d7"},{"name":"ACM","_id":"cifj5gkfv001gs8vnvzp9tbsj"},{"name":"图论","_id":"cifj5gkfv001hs8vn9xls92e8"},{"name":"spfa","_id":"cifj5gkfw001is8vn1q1jblu1"},{"name":"bellman-ford","_id":"cifj5gkfz001ps8vnd2olnkt7"},{"name":"dijkstra","_id":"cifj5gkg4001ws8vnj4ar7r23"},{"name":"floyd","_id":"cifj5gkg70023s8vna77fr1a2"},{"name":"python","_id":"cifj5gkgb002as8vnz310bcsk"},{"name":"编程","_id":"cifj5gkgb002bs8vn8ofkj1i3"},{"name":"django","_id":"cifj5gkgi002ls8vn6uxnlzff"},{"name":"uwsgi","_id":"cifj5gkgi002ms8vn0i69s5is"},{"name":"nginx","_id":"cifj5gkgi002ns8vnbp3s744j"},{"name":"innerac","_id":"cifj5gkgk002ts8vnagmjofjz"},{"name":"aboutme","_id":"cifj5gkgl002us8vnppmtdz3a"},{"name":"hexo","_id":"cifj5gkgn0030s8vnwd5pvjt9"},{"name":"github","_id":"cifj5gkgn0031s8vn1uvzgk07"},{"name":"blog","_id":"cifj5gkgo0032s8vnofrenxrq"},{"name":"区域赛","_id":"cifj5gkh3003ss8vnropvit62"},{"name":"QT","_id":"cifj5gkj2004fs8vnoo66o87x"},{"name":"VS","_id":"cifj5gkj3004gs8vnipz905x6"},{"name":"osgi","_id":"cifj5gkj5004ls8vngjptr9sh"},{"name":"codeforces","_id":"cifj5gkj9004ps8vnezd9iz9b"},{"name":"cf","_id":"cifj5gkja004qs8vnrr918602"},{"name":"trie","_id":"cifj5gkja004rs8vn7kp54yvu"},{"name":"hihocoder","_id":"cifj5gkji004xs8vnr0v3h8ob"}]}}